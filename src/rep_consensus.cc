
// A dynamic programming evaluator generated by GAP-C.
// 
//   GAP-C version:
//     bellmansgapc-2013.05.02
// 
//   GAP-C call:
//     /home/jhuang/local/gapc/bin/gapc -I ../../../ -p alg_ali_consensus ../../../ali_nodangle.gap -o rep_consensus.cc 
// 
// 


#define GAPC_MOD_TRANSLATION_UNIT
#include "rep_consensus.hh"

#include <rtlib/subopt.hh>
#include "rna.hh"
#include "Extensions/alifold.hh"
#include "Extensions/mfesubopt.hh"
#include "Extensions/probabilities.hh"
#include "Extensions/typesRNAfolding.hh"
//#include "Extensions/shapes.hh"

#include "Extensions/rnaoptions.hh"

rep_consensus_hash_h &  rep_consensus::nt_dangle(unsigned int t_0_i, unsigned int t_0_j)
{
  if (dangle_table.is_tabulated(t_0_i, t_0_j))
    {
      return dangle_table.get(t_0_i, t_0_j);
    }

  rep_consensus_hash_h answers;
  empty(answers);
  empty( answers);

  if (((t_0_j - t_0_i) >= 5))
  {
    TUSubsequence ret_3 = LOC(t_0_seq, t_0_j, t_0_j);
    TUSubsequence a_2 = ret_3;
    if (is_not_empty(a_2))
    {
      TUSubsequence ret_1 = LOC(t_0_seq, t_0_i, t_0_i);
      TUSubsequence a_0 = ret_1;
      if (is_not_empty(a_0))
      {
        rep_consensus_hash_h ret_2 = nt_strong(t_0_i, t_0_j);
        rep_consensus_hash_h a_1 = ret_2;
        if (is_not_empty(a_1))
          {
            for (rep_consensus_hash_h::iterator x_1_itr = a_1.ref().begin(); x_1_itr!=a_1.ref().end(); ++x_1_itr){
              Rope x_1 = *x_1_itr;
              Rope ans = drem(a_0, x_1, a_2);
              push_back( answers, ans);
            }
          }

        erase( a_1);
      }

      erase( a_0);
    }

    erase( a_2);
  }

  hash_filter( answers);
  finalize( answers);
  dangle_table.set( t_0_i, t_0_j, answers);
  return dangle_table.get(t_0_i, t_0_j);
}

Rope rep_consensus::nt_hairpin(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 5))
    {
      return Rope_zero;
    }

  Rope answers;
  empty( answers);
  Rope ret_0;
  if (((t_0_j - t_0_i) >= 5))
    {
      if (basepair(t_0_seq, t_0_i, t_0_j))
      {
        TUSubsequence ret_3 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
        TUSubsequence a_2 = ret_3;
        if (is_not_empty(a_2))
        {
          TUSubsequence ret_2;
          if ((minsize(t_0_seq, (t_0_i + 1), (t_0_j - 1), 3) && unpaired(t_0_seq, (t_0_i + 1), (t_0_j - 1))))
            {
              ret_2 = REGION(t_0_seq, (t_0_i + 1), (t_0_j - 1));
            }

          else
            {
              empty( ret_2);
            }

          TUSubsequence a_1 = ret_2;
          if (is_not_empty(a_1))
          {
            TUSubsequence ret_1 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
            TUSubsequence a_0 = ret_1;
            if (is_not_empty(a_0))
              {
                ret_0 = hl(a_0, a_1, a_2);
              }

            else
              {
                empty( ret_0);
              }

            erase( a_0);
          }

          else
            {
              empty( ret_0);
            }

          erase( a_1);
        }

        else
          {
            empty( ret_0);
          }

        erase( a_2);
      }

      else
      {
        empty( ret_0);
        empty( ret_0);
      }

    }

  else
    {
      empty( ret_0);
    }

  answers = ret_0;
  return answers;
}

rep_consensus_hash_h &  rep_consensus::nt_iloop(unsigned int t_0_i, unsigned int t_0_j)
{
  if (iloop_table.is_tabulated(t_0_i, t_0_j))
    {
      return iloop_table.get(t_0_i, t_0_j);
    }

  rep_consensus_hash_h answers;
  empty(answers);
  empty( answers);

  if (((t_0_j - t_0_i) >= 9))
    {
      if (basepair(t_0_seq, t_0_i, t_0_j))
        {
          for(          unsigned int t_0_k_0 = (t_0_i + 2); ((t_0_k_0 <= (t_0_j - 7)) && (t_0_k_0 <= (t_0_i + 31))); ++t_0_k_0)
          {
            for(            unsigned int t_0_k_1 = (((t_0_j - (t_0_k_0 + 5)) >= 31)) ? ((t_0_j - 31)) : ((t_0_k_0 + 5)); (t_0_k_1 <= (t_0_j - 2)); ++t_0_k_1)
            {
              TUSubsequence ret_5 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
              TUSubsequence a_4 = ret_5;
              if (is_not_empty(a_4))
              {
                TUSubsequence ret_4;
                if ((maxsize(t_0_seq, t_0_k_1, (t_0_j - 1), 30) && unpaired(t_0_seq, t_0_k_1, (t_0_j - 1))))
                  {
                    ret_4 = REGION(t_0_seq, t_0_k_1, (t_0_j - 1));
                  }

                else
                  {
                    empty( ret_4);
                  }

                TUSubsequence a_3 = ret_4;
                if (is_not_empty(a_3))
                {
                  TUSubsequence ret_2;
                  if ((maxsize(t_0_seq, (t_0_i + 1), t_0_k_0, 30) && unpaired(t_0_seq, (t_0_i + 1), t_0_k_0)))
                    {
                      ret_2 = REGION(t_0_seq, (t_0_i + 1), t_0_k_0);
                    }

                  else
                    {
                      empty( ret_2);
                    }

                  TUSubsequence a_1 = ret_2;
                  if (is_not_empty(a_1))
                  {
                    TUSubsequence ret_1 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
                    TUSubsequence a_0 = ret_1;
                    if (is_not_empty(a_0))
                    {
                      rep_consensus_hash_h ret_3 = nt_strong(t_0_k_0, t_0_k_1);
                      rep_consensus_hash_h a_2 = ret_3;
                      if (is_not_empty(a_2))
                        {
                          for (rep_consensus_hash_h::iterator x_2_itr = a_2.ref().begin(); x_2_itr!=a_2.ref().end(); ++x_2_itr){
                            Rope x_2 = *x_2_itr;
                            Rope ans = il(a_0, a_1, x_2, a_3, a_4);
                            push_back( answers, ans);
                          }
                        }

                      erase( a_2);
                    }

                    erase( a_0);
                  }

                  erase( a_1);
                }

                erase( a_3);
              }

              erase( a_4);
            }

          }

        }

      else
        {
          empty( answers);
        }

    }

  hash_filter( answers);
  finalize( answers);
  iloop_table.set( t_0_i, t_0_j, answers);
  return iloop_table.get(t_0_i, t_0_j);
}

rep_consensus_hash_h rep_consensus::nt_leftB(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 8))
    {
      return LRopeMhdecl0x2155c90_zero;
    }

  rep_consensus_hash_h answers;
  empty(answers);
  empty( answers);

  if (((t_0_j - t_0_i) >= 8))
    {
      if (basepair(t_0_seq, t_0_i, t_0_j))
        {
          for(          unsigned int t_0_k_0 = (t_0_i + 2); ((t_0_k_0 <= (t_0_j - 6)) && (t_0_k_0 <= (t_0_i + 31))); ++t_0_k_0)
          {
            TUSubsequence ret_4 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
            TUSubsequence a_3 = ret_4;
            if (is_not_empty(a_3))
            {
              TUSubsequence ret_2;
              if ((maxsize(t_0_seq, (t_0_i + 1), t_0_k_0, 30) && unpaired(t_0_seq, (t_0_i + 1), t_0_k_0)))
                {
                  ret_2 = REGION(t_0_seq, (t_0_i + 1), t_0_k_0);
                }

              else
                {
                  empty( ret_2);
                }

              TUSubsequence a_1 = ret_2;
              if (is_not_empty(a_1))
              {
                TUSubsequence ret_1 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
                TUSubsequence a_0 = ret_1;
                if (is_not_empty(a_0))
                {
                  rep_consensus_hash_h ret_3 = nt_strong(t_0_k_0, (t_0_j - 1));
                  rep_consensus_hash_h a_2 = ret_3;
                  if (is_not_empty(a_2))
                    {
                      for (rep_consensus_hash_h::iterator x_2_itr = a_2.ref().begin(); x_2_itr!=a_2.ref().end(); ++x_2_itr){
                        Rope x_2 = *x_2_itr;
                        Rope ans = bl(a_0, a_1, x_2, a_3);
                        push_back( answers, ans);
                      }
                    }

                  erase( a_2);
                }

                erase( a_0);
              }

              erase( a_1);
            }

            erase( a_3);
          }

        }

      else
        {
          empty( answers);
        }

    }

  hash_filter( answers);
  finalize( answers);
  return answers;
}

rep_consensus_hash_h &  rep_consensus::nt_ml_comps(unsigned int t_0_i, unsigned int t_0_j)
{
  if (ml_comps_table.is_tabulated(t_0_i, t_0_j))
    {
      return ml_comps_table.get(t_0_i, t_0_j);
    }

  rep_consensus_hash_h answers;
  empty(answers);
  empty( answers);

  if (((t_0_j - t_0_i) >= 11))
  {
    TUSubsequence ret_1;
    if (unpaired(t_0_seq, t_0_i, (t_0_i + 1)))
      {
        ret_1 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
      }

    else
      {
        empty( ret_1);
      }

    TUSubsequence a_0 = ret_1;
    if (is_not_empty(a_0))
    {
      rep_consensus_hash_h ret_2 = nt_ml_comps((t_0_i + 1), t_0_j);
      rep_consensus_hash_h a_1 = ret_2;
      if (is_not_empty(a_1))
        {
          for (rep_consensus_hash_h::iterator x_1_itr = a_1.ref().begin(); x_1_itr!=a_1.ref().end(); ++x_1_itr){
            Rope x_1 = *x_1_itr;
            Rope ans = sadd(a_0, x_1);
            push_back( answers, ans);
          }
        }

      erase( a_1);
    }

    erase( a_0);
  }


  if (((t_0_j - t_0_i) >= 10))
    {
      for(      unsigned int t_0_k_0 = (t_0_i + 5); (t_0_k_0 <= (t_0_j - 5)); ++t_0_k_0)
      {
        rep_consensus_hash_h ret_6 = nt_ml_comps1(t_0_k_0, t_0_j);
        rep_consensus_hash_h a_4 = ret_6;
        if (is_not_empty(a_4))
        {
          rep_consensus_hash_h ret_4;
          empty(ret_4);
          if (((t_0_k_0 - t_0_i) >= 5))
          {
            rep_consensus_hash_h ret_5 = nt_dangle(t_0_i, t_0_k_0);
            rep_consensus_hash_h a_3 = ret_5;
            if (is_not_empty(a_3))
              {
                for (rep_consensus_hash_h::iterator x_3_itr = a_3.ref().begin(); x_3_itr!=a_3.ref().end(); ++x_3_itr){
                  Rope x_3 = *x_3_itr;
                  Rope ans = incl(x_3);
                  push_back( ret_4, ans);
                }
              }

            erase( a_3);
          }

          finalize( ret_4);
          rep_consensus_hash_h a_2 = ret_4;
          if (is_not_empty(a_2))
            {
              for (rep_consensus_hash_h::iterator x_2_itr = a_2.ref().begin(); x_2_itr!=a_2.ref().end(); ++x_2_itr){
                Rope x_2 = *x_2_itr;
                for (rep_consensus_hash_h::iterator x_4_itr = a_4.ref().begin(); x_4_itr!=a_4.ref().end(); ++x_4_itr){
                  Rope x_4 = *x_4_itr;
                  Rope ans = cadd(x_2, x_4);
                  push_back( answers, ans);
                }
              }
            }

          erase( a_2);
        }

        erase( a_4);
      }

    }

  hash_filter( answers);
  finalize( answers);
  ml_comps_table.set( t_0_i, t_0_j, answers);
  return ml_comps_table.get(t_0_i, t_0_j);
}

rep_consensus_hash_h &  rep_consensus::nt_ml_comps1(unsigned int t_0_i, unsigned int t_0_j)
{
  if (ml_comps1_table.is_tabulated(t_0_i, t_0_j))
    {
      return ml_comps1_table.get(t_0_i, t_0_j);
    }

  rep_consensus_hash_h answers;
  empty(answers);
  empty( answers);

  if (((t_0_j - t_0_i) >= 6))
  {
    TUSubsequence ret_1;
    if (unpaired(t_0_seq, t_0_i, (t_0_i + 1)))
      {
        ret_1 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
      }

    else
      {
        empty( ret_1);
      }

    TUSubsequence a_0 = ret_1;
    if (is_not_empty(a_0))
    {
      rep_consensus_hash_h ret_2 = nt_ml_comps1((t_0_i + 1), t_0_j);
      rep_consensus_hash_h a_1 = ret_2;
      if (is_not_empty(a_1))
        {
          for (rep_consensus_hash_h::iterator x_1_itr = a_1.ref().begin(); x_1_itr!=a_1.ref().end(); ++x_1_itr){
            Rope x_1 = *x_1_itr;
            Rope ans = sadd(a_0, x_1);
            push_back( answers, ans);
          }
        }

      erase( a_1);
    }

    erase( a_0);
  }


  if (((t_0_j - t_0_i) >= 10))
    {
      for(      unsigned int t_0_k_0 = (t_0_i + 5); (t_0_k_0 <= (t_0_j - 5)); ++t_0_k_0)
      {
        rep_consensus_hash_h ret_6 = nt_ml_comps1(t_0_k_0, t_0_j);
        rep_consensus_hash_h a_4 = ret_6;
        if (is_not_empty(a_4))
        {
          rep_consensus_hash_h ret_4;
          empty(ret_4);
          if (((t_0_k_0 - t_0_i) >= 5))
          {
            rep_consensus_hash_h ret_5 = nt_dangle(t_0_i, t_0_k_0);
            rep_consensus_hash_h a_3 = ret_5;
            if (is_not_empty(a_3))
              {
                for (rep_consensus_hash_h::iterator x_3_itr = a_3.ref().begin(); x_3_itr!=a_3.ref().end(); ++x_3_itr){
                  Rope x_3 = *x_3_itr;
                  Rope ans = incl(x_3);
                  push_back( ret_4, ans);
                }
              }

            erase( a_3);
          }

          finalize( ret_4);
          rep_consensus_hash_h a_2 = ret_4;
          if (is_not_empty(a_2))
            {
              for (rep_consensus_hash_h::iterator x_2_itr = a_2.ref().begin(); x_2_itr!=a_2.ref().end(); ++x_2_itr){
                Rope x_2 = *x_2_itr;
                for (rep_consensus_hash_h::iterator x_4_itr = a_4.ref().begin(); x_4_itr!=a_4.ref().end(); ++x_4_itr){
                  Rope x_4 = *x_4_itr;
                  Rope ans = cadd(x_2, x_4);
                  push_back( answers, ans);
                }
              }
            }

          erase( a_2);
        }

        erase( a_4);
      }

    }


  if (((t_0_j - t_0_i) >= 5))
  {
    rep_consensus_hash_h ret_8 = nt_dangle(t_0_i, t_0_j);
    rep_consensus_hash_h a_5 = ret_8;
    if (is_not_empty(a_5))
      {
        for (rep_consensus_hash_h::iterator x_5_itr = a_5.ref().begin(); x_5_itr!=a_5.ref().end(); ++x_5_itr){
          Rope x_5 = *x_5_itr;
          Rope ans = incl(x_5);
          push_back( answers, ans);
        }
      }

    erase( a_5);
  }


  if (((t_0_j - t_0_i) >= 6))
    {
      for(      unsigned int t_0_k_1 = (t_0_i + 5); (t_0_k_1 <= (t_0_j - 1)); ++t_0_k_1)
      {
        TUSubsequence ret_12;
        if (unpaired(t_0_seq, t_0_k_1, t_0_j))
          {
            ret_12 = REGION(t_0_seq, t_0_k_1, t_0_j);
          }

        else
          {
            empty( ret_12);
          }

        TUSubsequence a_8 = ret_12;
        if (is_not_empty(a_8))
        {
          rep_consensus_hash_h ret_10;
          empty(ret_10);
          if (((t_0_k_1 - t_0_i) >= 5))
          {
            rep_consensus_hash_h ret_11 = nt_dangle(t_0_i, t_0_k_1);
            rep_consensus_hash_h a_7 = ret_11;
            if (is_not_empty(a_7))
              {
                for (rep_consensus_hash_h::iterator x_7_itr = a_7.ref().begin(); x_7_itr!=a_7.ref().end(); ++x_7_itr){
                  Rope x_7 = *x_7_itr;
                  Rope ans = incl(x_7);
                  push_back( ret_10, ans);
                }
              }

            erase( a_7);
          }

          finalize( ret_10);
          rep_consensus_hash_h a_6 = ret_10;
          if (is_not_empty(a_6))
            {
              for (rep_consensus_hash_h::iterator x_6_itr = a_6.ref().begin(); x_6_itr!=a_6.ref().end(); ++x_6_itr){
                Rope x_6 = *x_6_itr;
                Rope ans = addss(x_6, a_8);
                push_back( answers, ans);
              }
            }

          erase( a_6);
        }

        erase( a_8);
      }

    }

  hash_filter( answers);
  finalize( answers);
  ml_comps1_table.set( t_0_i, t_0_j, answers);
  return ml_comps1_table.get(t_0_i, t_0_j);
}

rep_consensus_hash_h rep_consensus::nt_multiloop(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 12))
    {
      return LRopeMhdecl0x2155c90_zero;
    }

  rep_consensus_hash_h answers;
  empty(answers);
  empty( answers);

  if (((t_0_j - t_0_i) >= 12))
    {
      if (basepair(t_0_seq, t_0_i, t_0_j))
      {
        TUSubsequence ret_3 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
        TUSubsequence a_2 = ret_3;
        if (is_not_empty(a_2))
        {
          TUSubsequence ret_1 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
          TUSubsequence a_0 = ret_1;
          if (is_not_empty(a_0))
          {
            rep_consensus_hash_h ret_2 = nt_ml_comps((t_0_i + 1), (t_0_j - 1));
            rep_consensus_hash_h a_1 = ret_2;
            if (is_not_empty(a_1))
              {
                for (rep_consensus_hash_h::iterator x_1_itr = a_1.ref().begin(); x_1_itr!=a_1.ref().end(); ++x_1_itr){
                  Rope x_1 = *x_1_itr;
                  Rope ans = ml(a_0, x_1, a_2);
                  push_back( answers, ans);
                }
              }

            erase( a_1);
          }

          erase( a_0);
        }

        erase( a_2);
      }

      else
        {
          empty( answers);
        }

    }

  hash_filter( answers);
  finalize( answers);
  return answers;
}

rep_consensus_hash_h rep_consensus::nt_rightB(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 8))
    {
      return LRopeMhdecl0x2155c90_zero;
    }

  rep_consensus_hash_h answers;
  empty(answers);
  empty( answers);

  if (((t_0_j - t_0_i) >= 8))
    {
      if (basepair(t_0_seq, t_0_i, t_0_j))
        {
          for(          unsigned int t_0_k_0 = (((t_0_j - (t_0_i + 6)) >= 31)) ? ((t_0_j - 31)) : ((t_0_i + 6)); (t_0_k_0 <= (t_0_j - 2)); ++t_0_k_0)
          {
            TUSubsequence ret_4 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
            TUSubsequence a_3 = ret_4;
            if (is_not_empty(a_3))
            {
              TUSubsequence ret_3;
              if ((maxsize(t_0_seq, t_0_k_0, (t_0_j - 1), 30) && unpaired(t_0_seq, t_0_k_0, (t_0_j - 1))))
                {
                  ret_3 = REGION(t_0_seq, t_0_k_0, (t_0_j - 1));
                }

              else
                {
                  empty( ret_3);
                }

              TUSubsequence a_2 = ret_3;
              if (is_not_empty(a_2))
              {
                TUSubsequence ret_1 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
                TUSubsequence a_0 = ret_1;
                if (is_not_empty(a_0))
                {
                  rep_consensus_hash_h ret_2 = nt_strong((t_0_i + 1), t_0_k_0);
                  rep_consensus_hash_h a_1 = ret_2;
                  if (is_not_empty(a_1))
                    {
                      for (rep_consensus_hash_h::iterator x_1_itr = a_1.ref().begin(); x_1_itr!=a_1.ref().end(); ++x_1_itr){
                        Rope x_1 = *x_1_itr;
                        Rope ans = br(a_0, x_1, a_2, a_3);
                        push_back( answers, ans);
                      }
                    }

                  erase( a_1);
                }

                erase( a_0);
              }

              erase( a_2);
            }

            erase( a_3);
          }

        }

      else
        {
          empty( answers);
        }

    }

  hash_filter( answers);
  finalize( answers);
  return answers;
}

rep_consensus_hash_h rep_consensus::nt_stack(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 7))
    {
      return LRopeMhdecl0x2155c90_zero;
    }

  rep_consensus_hash_h answers;
  empty(answers);
  empty( answers);

  if (((t_0_j - t_0_i) >= 7))
    {
      if (basepair(t_0_seq, t_0_i, t_0_j))
      {
        TUSubsequence ret_3 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
        TUSubsequence a_2 = ret_3;
        if (is_not_empty(a_2))
        {
          TUSubsequence ret_1 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
          TUSubsequence a_0 = ret_1;
          if (is_not_empty(a_0))
          {
            rep_consensus_hash_h ret_2 = nt_weak((t_0_i + 1), (t_0_j - 1));
            rep_consensus_hash_h a_1 = ret_2;
            if (is_not_empty(a_1))
              {
                for (rep_consensus_hash_h::iterator x_1_itr = a_1.ref().begin(); x_1_itr!=a_1.ref().end(); ++x_1_itr){
                  Rope x_1 = *x_1_itr;
                  Rope ans = sr(a_0, x_1, a_2);
                  push_back( answers, ans);
                }
              }

            erase( a_1);
          }

          erase( a_0);
        }

        erase( a_2);
      }

      else
        {
          empty( answers);
        }

    }

  hash_filter( answers);
  finalize( answers);
  return answers;
}

rep_consensus_hash_h &  rep_consensus::nt_strong(unsigned int t_0_i, unsigned int t_0_j)
{
  if (strong_table.is_tabulated(t_0_i, t_0_j))
    {
      return strong_table.get(t_0_i, t_0_j);
    }

  rep_consensus_hash_h answers;
  empty(answers);
  empty( answers);


  if (allowLonelyBasepairs(t_0_seq, t_0_i, t_0_j, false))
  {
    rep_consensus_hash_h ret_1;
    empty(ret_1);
    if (((t_0_j - t_0_i) >= 7))
      {
        if (basepair(t_0_seq, t_0_i, t_0_j))
        {
          TUSubsequence ret_4 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
          TUSubsequence a_2 = ret_4;
          if (is_not_empty(a_2))
          {
            TUSubsequence ret_2 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
            TUSubsequence a_0 = ret_2;
            if (is_not_empty(a_0))
            {
              rep_consensus_hash_h ret_3 = nt_weak((t_0_i + 1), (t_0_j - 1));
              rep_consensus_hash_h a_1 = ret_3;
              if (is_not_empty(a_1))
                {
                  for (rep_consensus_hash_h::iterator x_1_itr = a_1.ref().begin(); x_1_itr!=a_1.ref().end(); ++x_1_itr){
                    Rope x_1 = *x_1_itr;
                    Rope ans = sr(a_0, x_1, a_2);
                    push_back( ret_1, ans);
                  }
                }

              erase( a_1);
            }

            erase( a_0);
          }

          erase( a_2);
        }

        else
          {
            empty( ret_1);
          }

      }

    finalize( ret_1);
    append( answers, ret_1);
  }



  if (allowLonelyBasepairs(t_0_seq, t_0_i, t_0_j, true))
  {
    rep_consensus_hash_h ret_6 = nt_weak(t_0_i, t_0_j);
    append( answers, ret_6);
  }

  hash_filter( answers);
  finalize( answers);
  strong_table.set( t_0_i, t_0_j, answers);
  return strong_table.get(t_0_i, t_0_j);
}

rep_consensus_hash_h &  rep_consensus::nt_struct(unsigned int t_0_i)
{
  if (struct_table.is_tabulated(t_0_i))
    {
      return struct_table.get(t_0_i);
    }

  rep_consensus_hash_h answers;
  empty(answers);
  empty( answers);

  if (((t_0_right_most - t_0_i) >= 1))
  {
    TUSubsequence ret_1;
    if (unpaired(t_0_seq, t_0_i, (t_0_i + 1)))
      {
        ret_1 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
      }

    else
      {
        empty( ret_1);
      }

    TUSubsequence a_0 = ret_1;
    if (is_not_empty(a_0))
    {
      rep_consensus_hash_h ret_2 = nt_struct((t_0_i + 1));
      rep_consensus_hash_h a_1 = ret_2;
      if (is_not_empty(a_1))
        {
          for (rep_consensus_hash_h::iterator x_1_itr = a_1.ref().begin(); x_1_itr!=a_1.ref().end(); ++x_1_itr){
            Rope x_1 = *x_1_itr;
            Rope ans = sadd(a_0, x_1);
            push_back( answers, ans);
          }
        }

      erase( a_1);
    }

    erase( a_0);
  }


  if (((t_0_right_most - t_0_i) >= 5))
    {
      for(      unsigned int t_0_k_0 = (t_0_i + 5); (t_0_k_0 <= t_0_right_most); ++t_0_k_0)
      {
        rep_consensus_hash_h ret_5 = nt_struct(t_0_k_0);
        rep_consensus_hash_h a_3 = ret_5;
        if (is_not_empty(a_3))
        {
          rep_consensus_hash_h ret_4 = nt_dangle(t_0_i, t_0_k_0);
          rep_consensus_hash_h a_2 = ret_4;
          if (is_not_empty(a_2))
            {
              for (rep_consensus_hash_h::iterator x_2_itr = a_2.ref().begin(); x_2_itr!=a_2.ref().end(); ++x_2_itr){
                Rope x_2 = *x_2_itr;
                for (rep_consensus_hash_h::iterator x_3_itr = a_3.ref().begin(); x_3_itr!=a_3.ref().end(); ++x_3_itr){
                  Rope x_3 = *x_3_itr;
                  Rope ans = cadd(x_2, x_3);
                  push_back( answers, ans);
                }
              }
            }

          erase( a_2);
        }

        erase( a_3);
      }

    }

  Rope ret_6;
  if ((((t_0_right_most - t_0_i) >= 0) && ((t_0_right_most - t_0_i) <= 0)))
  {
    TUSubsequence ret_7 = LOC(t_0_seq, t_0_i, t_0_i);
    TUSubsequence a_4 = ret_7;
    if (is_not_empty(a_4))
      {
        ret_6 = nil(a_4);
      }

    else
      {
        empty( ret_6);
      }

    erase( a_4);
  }

  else
    {
      empty( ret_6);
    }

  if (is_not_empty(ret_6))
    {
      push_back( answers, ret_6);
    }

  hash_filter( answers);
  finalize( answers);
  struct_table.set( t_0_i, answers);
  return struct_table.get(t_0_i);
}

rep_consensus_hash_h &  rep_consensus::nt_weak(unsigned int t_0_i, unsigned int t_0_j)
{
  if (weak_table.is_tabulated(t_0_i, t_0_j))
    {
      return weak_table.get(t_0_i, t_0_j);
    }

  rep_consensus_hash_h answers;
  empty(answers);
  empty( answers);


  rep_consensus_hash_h ret_1 = nt_stack(t_0_i, t_0_j);
  append( answers, ret_1);
  Rope ret_2 = nt_hairpin(t_0_i, t_0_j);
  if (is_not_empty(ret_2))
    {
      push_back( answers, ret_2);
    }

  rep_consensus_hash_h ret_3 = nt_leftB(t_0_i, t_0_j);
  append( answers, ret_3);
  rep_consensus_hash_h ret_4 = nt_rightB(t_0_i, t_0_j);
  append( answers, ret_4);
  rep_consensus_hash_h ret_5 = nt_iloop(t_0_i, t_0_j);
  append( answers, ret_5);
  rep_consensus_hash_h ret_6 = nt_multiloop(t_0_i, t_0_j);
  append( answers, ret_6);
  hash_filter( answers);
  finalize( answers);
  weak_table.set( t_0_i, t_0_j, answers);
  return weak_table.get(t_0_i, t_0_j);
}


Rope rep_consensus::addss(const Rope & e, const TUSubsequence & rb)
{
#line 526 "../../../ali_nodangle.gap"
  Rope res;
  append( res, e);
  append_consensus( res, rb);
  return res;
#line 1009 "rep_consensus.cc"
}

Rope rep_consensus::bl(const TUSubsequence & lb, const TUSubsequence & lregion, const Rope & e, const TUSubsequence & rb)
{
#line 414 "../../../ali_nodangle.gap"
  Rope res;
  append_consensus( res, lb);
  append_consensus( res, lregion);
  append( res, e);
  append_consensus( res, rb);
  return res;
#line 1021 "rep_consensus.cc"
}

Rope rep_consensus::br(const TUSubsequence & lb, const Rope & e, const TUSubsequence & rregion, const TUSubsequence & rb)
{
#line 423 "../../../ali_nodangle.gap"
  Rope res;
  append_consensus( res, lb);
  append( res, e);
  append_consensus( res, rregion);
  append_consensus( res, rb);
  return res;
#line 1033 "rep_consensus.cc"
}

Rope rep_consensus::cadd(const Rope & le, const Rope & re)
{
#line 322 "../../../ali_nodangle.gap"
  Rope res;
  append( res, le);
  append( res, re);
  return res;
#line 1043 "rep_consensus.cc"
}

Rope rep_consensus::drem(const TUSubsequence & lloc, const Rope & e, const TUSubsequence & rloc)
{
#line 393 "../../../ali_nodangle.gap"
  return e;
#line 1050 "rep_consensus.cc"
}

Rope rep_consensus::hl(const TUSubsequence & lb, const TUSubsequence & region, const TUSubsequence & rb)
{
#line 405 "../../../ali_nodangle.gap"
  Rope res;
  append_consensus( res, lb);
  append_consensus( res, region);
  append_consensus( res, rb);
  return res;
#line 1061 "rep_consensus.cc"
}

Rope rep_consensus::il(const TUSubsequence & lb, const TUSubsequence & lregion, const Rope & e, const TUSubsequence & rregion, const TUSubsequence & rb)
{
#line 432 "../../../ali_nodangle.gap"
  Rope res;
  append_consensus( res, lb);
  append_consensus( res, lregion);
  append( res, e);
  append_consensus( res, rregion);
  append_consensus( res, rb);
  return res;
#line 1074 "rep_consensus.cc"
}

Rope rep_consensus::incl(const Rope & e)
{
#line 544 "../../../ali_nodangle.gap"
  return e;
#line 1081 "rep_consensus.cc"
}

Rope rep_consensus::ml(const TUSubsequence & lb, const Rope & e, const TUSubsequence & rb)
{
#line 442 "../../../ali_nodangle.gap"
  Rope res;
  append_consensus( res, lb);
  append( res, e);
  append_consensus( res, rb);
  return res;
#line 1092 "rep_consensus.cc"
}

Rope rep_consensus::nil(const TUSubsequence & loc)
{
#line 366 "../../../ali_nodangle.gap"
  Rope r;
  return r;
#line 1100 "rep_consensus.cc"
}

Rope rep_consensus::sadd(const TUSubsequence & lb, const Rope & e)
{
#line 315 "../../../ali_nodangle.gap"
  Rope res;
  append_consensus( res, lb);
  append( res, e);
  return res;
#line 1110 "rep_consensus.cc"
}

Rope rep_consensus::sr(const TUSubsequence & lb, const Rope & e, const TUSubsequence & rb)
{
#line 397 "../../../ali_nodangle.gap"
  Rope res;
  append_consensus( res, lb);
  append( res, e);
  append_consensus( res, rb);
  return res;
#line 1121 "rep_consensus.cc"
}


    void rep_consensus::cyk()
{

}



#ident "$Id: Compiled with gapc bellmansgapc-2013.05.02 $"

