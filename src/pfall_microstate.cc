
// A dynamic programming evaluator generated by GAP-C.
// 
//   GAP-C version:
//     bellmansgapc-2013.05.02
// 
//   GAP-C call:
//     /home/jhuang/local/gapc/bin/gapc -I ../../../ -p alg_ali_pfunc ../../../ali_microstate.gap -o pfall_microstate.cc 
// 
// 


#define GAPC_MOD_TRANSLATION_UNIT
#include "pfall_microstate.hh"

#include <rtlib/subopt.hh>
#include "rna.hh"
#include "Extensions/alifold.hh"
#include "Extensions/mfesubopt.hh"
#include "Extensions/probabilities.hh"
#include "Extensions/typesRNAfolding.hh"
//#include "Extensions/shapes.hh"

#include "Extensions/rnaoptions.hh"

double &  pfall_microstate::nt_dangle(unsigned int t_0_i, unsigned int t_0_j)
{
  if (dangle_table.is_tabulated(t_0_i, t_0_j))
    {
      return dangle_table.get(t_0_i, t_0_j);
    }

  double answers;
  empty(answers);
  empty( answers);
  double ret_0;
  if (((t_0_j - t_0_i) >= 6))
  {
    TUSubsequence ret_3 = LOC(t_0_seq, t_0_j, t_0_j);
    TUSubsequence a_2 = ret_3;
    if (is_not_empty(a_2))
    {
      TUSubsequence ret_1;
      if (unpaired(t_0_seq, t_0_i, (t_0_i + 1)))
        {
          ret_1 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
        }

      else
        {
          empty( ret_1);
        }

      TUSubsequence a_0 = ret_1;
      if (is_not_empty(a_0))
      {
        double ret_2 = nt_strong((t_0_i + 1), t_0_j);
        double a_1 = ret_2;
        if (is_not_empty(a_1))
          {
            ret_0 = edl(a_0, a_1, a_2);
          }

        else
          {
            empty( ret_0);
          }

        erase( a_1);
      }

      else
        {
          empty( ret_0);
        }

      erase( a_0);
    }

    else
      {
        empty( ret_0);
      }

    erase( a_2);
  }

  else
    {
      empty( ret_0);
    }

  if (is_not_empty(ret_0))
    {
      push_back_sum( answers, ret_0);
    }

  double ret_4;
  if (((t_0_j - t_0_i) >= 6))
  {
    TUSubsequence ret_7;
    if (unpaired(t_0_seq, (t_0_j - 1), t_0_j))
      {
        ret_7 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
      }

    else
      {
        empty( ret_7);
      }

    TUSubsequence a_5 = ret_7;
    if (is_not_empty(a_5))
    {
      TUSubsequence ret_5 = LOC(t_0_seq, t_0_i, t_0_i);
      TUSubsequence a_3 = ret_5;
      if (is_not_empty(a_3))
      {
        double ret_6 = nt_strong(t_0_i, (t_0_j - 1));
        double a_4 = ret_6;
        if (is_not_empty(a_4))
          {
            ret_4 = edr(a_3, a_4, a_5);
          }

        else
          {
            empty( ret_4);
          }

        erase( a_4);
      }

      else
        {
          empty( ret_4);
        }

      erase( a_3);
    }

    else
      {
        empty( ret_4);
      }

    erase( a_5);
  }

  else
    {
      empty( ret_4);
    }

  if (is_not_empty(ret_4))
    {
      push_back_sum( answers, ret_4);
    }

  double ret_8;
  if (((t_0_j - t_0_i) >= 7))
  {
    TUSubsequence ret_11;
    if (unpaired(t_0_seq, (t_0_j - 1), t_0_j))
      {
        ret_11 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
      }

    else
      {
        empty( ret_11);
      }

    TUSubsequence a_8 = ret_11;
    if (is_not_empty(a_8))
    {
      TUSubsequence ret_9;
      if (unpaired(t_0_seq, t_0_i, (t_0_i + 1)))
        {
          ret_9 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
        }

      else
        {
          empty( ret_9);
        }

      TUSubsequence a_6 = ret_9;
      if (is_not_empty(a_6))
      {
        double ret_10 = nt_strong((t_0_i + 1), (t_0_j - 1));
        double a_7 = ret_10;
        if (is_not_empty(a_7))
          {
            ret_8 = edlr(a_6, a_7, a_8);
          }

        else
          {
            empty( ret_8);
          }

        erase( a_7);
      }

      else
        {
          empty( ret_8);
        }

      erase( a_6);
    }

    else
      {
        empty( ret_8);
      }

    erase( a_8);
  }

  else
    {
      empty( ret_8);
    }

  if (is_not_empty(ret_8))
    {
      push_back_sum( answers, ret_8);
    }

  double ret_12;
  if (((t_0_j - t_0_i) >= 5))
  {
    TUSubsequence ret_15 = LOC(t_0_seq, t_0_j, t_0_j);
    TUSubsequence a_11 = ret_15;
    if (is_not_empty(a_11))
    {
      TUSubsequence ret_13 = LOC(t_0_seq, t_0_i, t_0_i);
      TUSubsequence a_9 = ret_13;
      if (is_not_empty(a_9))
      {
        double ret_14 = nt_strong(t_0_i, t_0_j);
        double a_10 = ret_14;
        if (is_not_empty(a_10))
          {
            ret_12 = drem(a_9, a_10, a_11);
          }

        else
          {
            empty( ret_12);
          }

        erase( a_10);
      }

      else
        {
          empty( ret_12);
        }

      erase( a_9);
    }

    else
      {
        empty( ret_12);
      }

    erase( a_11);
  }

  else
    {
      empty( ret_12);
    }

  if (is_not_empty(ret_12))
    {
      push_back_sum( answers, ret_12);
    }

  double eval = h(answers);
  erase( answers);
  dangle_table.set( t_0_i, t_0_j, eval);
  return dangle_table.get(t_0_i, t_0_j);
}

double pfall_microstate::nt_hairpin(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 5))
    {
      return float_zero;
    }

  double answers;
  empty(answers);
  empty( answers);
  double ret_0;
  if (((t_0_j - t_0_i) >= 5))
    {
      if (basepair(t_0_seq, t_0_i, t_0_j))
      {
        TUSubsequence ret_3 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
        TUSubsequence a_2 = ret_3;
        if (is_not_empty(a_2))
        {
          TUSubsequence ret_2;
          if ((minsize(t_0_seq, (t_0_i + 1), (t_0_j - 1), 3) && unpaired(t_0_seq, (t_0_i + 1), (t_0_j - 1))))
            {
              ret_2 = REGION(t_0_seq, (t_0_i + 1), (t_0_j - 1));
            }

          else
            {
              empty( ret_2);
            }

          TUSubsequence a_1 = ret_2;
          if (is_not_empty(a_1))
          {
            TUSubsequence ret_1 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
            TUSubsequence a_0 = ret_1;
            if (is_not_empty(a_0))
              {
                ret_0 = hl(a_0, a_1, a_2);
              }

            else
              {
                empty( ret_0);
              }

            erase( a_0);
          }

          else
            {
              empty( ret_0);
            }

          erase( a_1);
        }

        else
          {
            empty( ret_0);
          }

        erase( a_2);
      }

      else
      {
        empty( ret_0);
        empty( ret_0);
      }

    }

  else
    {
      empty( ret_0);
    }

  if (is_not_empty(ret_0))
    {
      push_back_sum( answers, ret_0);
    }

  double eval = h(answers);
  erase( answers);
  return eval;
}

double &  pfall_microstate::nt_iloop(unsigned int t_0_i, unsigned int t_0_j)
{
  if (iloop_table.is_tabulated(t_0_i, t_0_j))
    {
      return iloop_table.get(t_0_i, t_0_j);
    }

  double answers;
  empty(answers);
  empty( answers);

  if (((t_0_j - t_0_i) >= 9))
    {
      if (basepair(t_0_seq, t_0_i, t_0_j))
        {
          for(          unsigned int t_0_k_0 = (t_0_i + 2); ((t_0_k_0 <= (t_0_j - 7)) && (t_0_k_0 <= (t_0_i + 31))); ++t_0_k_0)
          {
            for(            unsigned int t_0_k_1 = (((t_0_j - (t_0_k_0 + 5)) >= 31)) ? ((t_0_j - 31)) : ((t_0_k_0 + 5)); (t_0_k_1 <= (t_0_j - 2)); ++t_0_k_1)
            {
              TUSubsequence ret_5 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
              TUSubsequence a_4 = ret_5;
              if (is_not_empty(a_4))
              {
                TUSubsequence ret_4;
                if ((maxsize(t_0_seq, t_0_k_1, (t_0_j - 1), 30) && unpaired(t_0_seq, t_0_k_1, (t_0_j - 1))))
                  {
                    ret_4 = REGION(t_0_seq, t_0_k_1, (t_0_j - 1));
                  }

                else
                  {
                    empty( ret_4);
                  }

                TUSubsequence a_3 = ret_4;
                if (is_not_empty(a_3))
                {
                  TUSubsequence ret_2;
                  if ((maxsize(t_0_seq, (t_0_i + 1), t_0_k_0, 30) && unpaired(t_0_seq, (t_0_i + 1), t_0_k_0)))
                    {
                      ret_2 = REGION(t_0_seq, (t_0_i + 1), t_0_k_0);
                    }

                  else
                    {
                      empty( ret_2);
                    }

                  TUSubsequence a_1 = ret_2;
                  if (is_not_empty(a_1))
                  {
                    TUSubsequence ret_1 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
                    TUSubsequence a_0 = ret_1;
                    if (is_not_empty(a_0))
                    {
                      double ret_3 = nt_strong(t_0_k_0, t_0_k_1);
                      double a_2 = ret_3;
                      if (is_not_empty(a_2))
                      {
                        double ans = il(a_0, a_1, a_2, a_3, a_4);
                        push_back_sum( answers, ans);
                      }

                      erase( a_2);
                    }

                    erase( a_0);
                  }

                  erase( a_1);
                }

                erase( a_3);
              }

              erase( a_4);
            }

          }

        }

      else
        {
          empty( answers);
        }

    }

  double eval = h(answers);
  erase( answers);
  iloop_table.set( t_0_i, t_0_j, eval);
  return iloop_table.get(t_0_i, t_0_j);
}

double pfall_microstate::nt_leftB(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 8))
    {
      return float_zero;
    }

  double answers;
  empty(answers);
  empty( answers);

  if (((t_0_j - t_0_i) >= 8))
    {
      if (basepair(t_0_seq, t_0_i, t_0_j))
        {
          for(          unsigned int t_0_k_0 = (t_0_i + 2); ((t_0_k_0 <= (t_0_j - 6)) && (t_0_k_0 <= (t_0_i + 31))); ++t_0_k_0)
          {
            TUSubsequence ret_4 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
            TUSubsequence a_3 = ret_4;
            if (is_not_empty(a_3))
            {
              TUSubsequence ret_2;
              if ((maxsize(t_0_seq, (t_0_i + 1), t_0_k_0, 30) && unpaired(t_0_seq, (t_0_i + 1), t_0_k_0)))
                {
                  ret_2 = REGION(t_0_seq, (t_0_i + 1), t_0_k_0);
                }

              else
                {
                  empty( ret_2);
                }

              TUSubsequence a_1 = ret_2;
              if (is_not_empty(a_1))
              {
                TUSubsequence ret_1 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
                TUSubsequence a_0 = ret_1;
                if (is_not_empty(a_0))
                {
                  double ret_3 = nt_strong(t_0_k_0, (t_0_j - 1));
                  double a_2 = ret_3;
                  if (is_not_empty(a_2))
                  {
                    double ans = bl(a_0, a_1, a_2, a_3);
                    push_back_sum( answers, ans);
                  }

                  erase( a_2);
                }

                erase( a_0);
              }

              erase( a_1);
            }

            erase( a_3);
          }

        }

      else
        {
          empty( answers);
        }

    }

  double eval = h(answers);
  erase( answers);
  return eval;
}

double &  pfall_microstate::nt_ml_comps(unsigned int t_0_i, unsigned int t_0_j)
{
  if (ml_comps_table.is_tabulated(t_0_i, t_0_j))
    {
      return ml_comps_table.get(t_0_i, t_0_j);
    }

  double answers;
  empty(answers);
  empty( answers);
  double ret_0;
  if (((t_0_j - t_0_i) >= 11))
  {
    TUSubsequence ret_1;
    if (unpaired(t_0_seq, t_0_i, (t_0_i + 1)))
      {
        ret_1 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
      }

    else
      {
        empty( ret_1);
      }

    TUSubsequence a_0 = ret_1;
    if (is_not_empty(a_0))
    {
      double ret_2 = nt_ml_comps((t_0_i + 1), t_0_j);
      double a_1 = ret_2;
      if (is_not_empty(a_1))
        {
          ret_0 = sadd(a_0, a_1);
        }

      else
        {
          empty( ret_0);
        }

      erase( a_1);
    }

    else
      {
        empty( ret_0);
      }

    erase( a_0);
  }

  else
    {
      empty( ret_0);
    }

  if (is_not_empty(ret_0))
    {
      push_back_sum( answers, ret_0);
    }


  if (((t_0_j - t_0_i) >= 10))
    {
      for(      unsigned int t_0_k_0 = (t_0_i + 5); (t_0_k_0 <= (t_0_j - 5)); ++t_0_k_0)
      {
        double ret_6 = nt_ml_comps1(t_0_k_0, t_0_j);
        double a_4 = ret_6;
        if (is_not_empty(a_4))
        {
          double ret_4;
          if (((t_0_k_0 - t_0_i) >= 5))
          {
            double ret_5 = nt_dangle(t_0_i, t_0_k_0);
            double a_3 = ret_5;
            if (is_not_empty(a_3))
              {
                ret_4 = incl(a_3);
              }

            else
              {
                empty( ret_4);
              }

            erase( a_3);
          }

          else
            {
              empty( ret_4);
            }

          double a_2 = ret_4;
          if (is_not_empty(a_2))
          {
            double ans = cadd(a_2, a_4);
            push_back_sum( answers, ans);
          }

          erase( a_2);
        }

        erase( a_4);
      }

    }

  double eval = h(answers);
  erase( answers);
  ml_comps_table.set( t_0_i, t_0_j, eval);
  return ml_comps_table.get(t_0_i, t_0_j);
}

double &  pfall_microstate::nt_ml_comps1(unsigned int t_0_i, unsigned int t_0_j)
{
  if (ml_comps1_table.is_tabulated(t_0_i, t_0_j))
    {
      return ml_comps1_table.get(t_0_i, t_0_j);
    }

  double answers;
  empty(answers);
  empty( answers);
  double ret_0;
  if (((t_0_j - t_0_i) >= 6))
  {
    TUSubsequence ret_1;
    if (unpaired(t_0_seq, t_0_i, (t_0_i + 1)))
      {
        ret_1 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
      }

    else
      {
        empty( ret_1);
      }

    TUSubsequence a_0 = ret_1;
    if (is_not_empty(a_0))
    {
      double ret_2 = nt_ml_comps1((t_0_i + 1), t_0_j);
      double a_1 = ret_2;
      if (is_not_empty(a_1))
        {
          ret_0 = sadd(a_0, a_1);
        }

      else
        {
          empty( ret_0);
        }

      erase( a_1);
    }

    else
      {
        empty( ret_0);
      }

    erase( a_0);
  }

  else
    {
      empty( ret_0);
    }

  if (is_not_empty(ret_0))
    {
      push_back_sum( answers, ret_0);
    }


  if (((t_0_j - t_0_i) >= 10))
    {
      for(      unsigned int t_0_k_0 = (t_0_i + 5); (t_0_k_0 <= (t_0_j - 5)); ++t_0_k_0)
      {
        double ret_6 = nt_ml_comps1(t_0_k_0, t_0_j);
        double a_4 = ret_6;
        if (is_not_empty(a_4))
        {
          double ret_4;
          if (((t_0_k_0 - t_0_i) >= 5))
          {
            double ret_5 = nt_dangle(t_0_i, t_0_k_0);
            double a_3 = ret_5;
            if (is_not_empty(a_3))
              {
                ret_4 = incl(a_3);
              }

            else
              {
                empty( ret_4);
              }

            erase( a_3);
          }

          else
            {
              empty( ret_4);
            }

          double a_2 = ret_4;
          if (is_not_empty(a_2))
          {
            double ans = cadd(a_2, a_4);
            push_back_sum( answers, ans);
          }

          erase( a_2);
        }

        erase( a_4);
      }

    }

  double ret_7;
  if (((t_0_j - t_0_i) >= 5))
  {
    double ret_8 = nt_dangle(t_0_i, t_0_j);
    double a_5 = ret_8;
    if (is_not_empty(a_5))
      {
        ret_7 = incl(a_5);
      }

    else
      {
        empty( ret_7);
      }

    erase( a_5);
  }

  else
    {
      empty( ret_7);
    }

  if (is_not_empty(ret_7))
    {
      push_back_sum( answers, ret_7);
    }


  if (((t_0_j - t_0_i) >= 6))
    {
      for(      unsigned int t_0_k_1 = (t_0_i + 5); (t_0_k_1 <= (t_0_j - 1)); ++t_0_k_1)
      {
        TUSubsequence ret_12;
        if (unpaired(t_0_seq, t_0_k_1, t_0_j))
          {
            ret_12 = REGION(t_0_seq, t_0_k_1, t_0_j);
          }

        else
          {
            empty( ret_12);
          }

        TUSubsequence a_8 = ret_12;
        if (is_not_empty(a_8))
        {
          double ret_10;
          if (((t_0_k_1 - t_0_i) >= 5))
          {
            double ret_11 = nt_dangle(t_0_i, t_0_k_1);
            double a_7 = ret_11;
            if (is_not_empty(a_7))
              {
                ret_10 = incl(a_7);
              }

            else
              {
                empty( ret_10);
              }

            erase( a_7);
          }

          else
            {
              empty( ret_10);
            }

          double a_6 = ret_10;
          if (is_not_empty(a_6))
          {
            double ans = addss(a_6, a_8);
            push_back_sum( answers, ans);
          }

          erase( a_6);
        }

        erase( a_8);
      }

    }

  double eval = h(answers);
  erase( answers);
  ml_comps1_table.set( t_0_i, t_0_j, eval);
  return ml_comps1_table.get(t_0_i, t_0_j);
}

double pfall_microstate::nt_multiloop(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 12))
    {
      return float_zero;
    }

  double answers;
  empty(answers);
  empty( answers);
  double ret_0;
  if (((t_0_j - t_0_i) >= 12))
    {
      if (basepair(t_0_seq, t_0_i, t_0_j))
      {
        TUSubsequence ret_3 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
        TUSubsequence a_2 = ret_3;
        if (is_not_empty(a_2))
        {
          TUSubsequence ret_1 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
          TUSubsequence a_0 = ret_1;
          if (is_not_empty(a_0))
          {
            double ret_2 = nt_ml_comps((t_0_i + 1), (t_0_j - 1));
            double a_1 = ret_2;
            if (is_not_empty(a_1))
              {
                ret_0 = ml(a_0, a_1, a_2);
              }

            else
              {
                empty( ret_0);
              }

            erase( a_1);
          }

          else
            {
              empty( ret_0);
            }

          erase( a_0);
        }

        else
          {
            empty( ret_0);
          }

        erase( a_2);
      }

      else
      {
        empty( ret_0);
        empty( ret_0);
      }

    }

  else
    {
      empty( ret_0);
    }

  if (is_not_empty(ret_0))
    {
      push_back_sum( answers, ret_0);
    }

  double ret_4;
  if (((t_0_j - t_0_i) >= 13))
    {
      if (basepair(t_0_seq, t_0_i, t_0_j))
      {
        TUSubsequence ret_8 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
        TUSubsequence a_6 = ret_8;
        if (is_not_empty(a_6))
        {
          TUSubsequence ret_6;
          if (unpaired(t_0_seq, (t_0_i + 1), ((t_0_i + 1) + 1)))
            {
              ret_6 = BASE(t_0_seq, (t_0_i + 1), ((t_0_i + 1) + 1));
            }

          else
            {
              empty( ret_6);
            }

          TUSubsequence a_4 = ret_6;
          if (is_not_empty(a_4))
          {
            TUSubsequence ret_5 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
            TUSubsequence a_3 = ret_5;
            if (is_not_empty(a_3))
            {
              double ret_7 = nt_ml_comps((t_0_i + 2), (t_0_j - 1));
              double a_5 = ret_7;
              if (is_not_empty(a_5))
                {
                  ret_4 = mldl(a_3, a_4, a_5, a_6);
                }

              else
                {
                  empty( ret_4);
                }

              erase( a_5);
            }

            else
              {
                empty( ret_4);
              }

            erase( a_3);
          }

          else
            {
              empty( ret_4);
            }

          erase( a_4);
        }

        else
          {
            empty( ret_4);
          }

        erase( a_6);
      }

      else
      {
        empty( ret_4);
        empty( ret_4);
      }

    }

  else
    {
      empty( ret_4);
    }

  if (is_not_empty(ret_4))
    {
      push_back_sum( answers, ret_4);
    }

  double ret_9;
  if (((t_0_j - t_0_i) >= 13))
    {
      if (basepair(t_0_seq, t_0_i, t_0_j))
      {
        TUSubsequence ret_13 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
        TUSubsequence a_10 = ret_13;
        if (is_not_empty(a_10))
        {
          TUSubsequence ret_12;
          if (unpaired(t_0_seq, (t_0_j - 2), (t_0_j - 1)))
            {
              ret_12 = BASE(t_0_seq, (t_0_j - 2), (t_0_j - 1));
            }

          else
            {
              empty( ret_12);
            }

          TUSubsequence a_9 = ret_12;
          if (is_not_empty(a_9))
          {
            TUSubsequence ret_10 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
            TUSubsequence a_7 = ret_10;
            if (is_not_empty(a_7))
            {
              double ret_11 = nt_ml_comps((t_0_i + 1), (t_0_j - 2));
              double a_8 = ret_11;
              if (is_not_empty(a_8))
                {
                  ret_9 = mldr(a_7, a_8, a_9, a_10);
                }

              else
                {
                  empty( ret_9);
                }

              erase( a_8);
            }

            else
              {
                empty( ret_9);
              }

            erase( a_7);
          }

          else
            {
              empty( ret_9);
            }

          erase( a_9);
        }

        else
          {
            empty( ret_9);
          }

        erase( a_10);
      }

      else
      {
        empty( ret_9);
        empty( ret_9);
      }

    }

  else
    {
      empty( ret_9);
    }

  if (is_not_empty(ret_9))
    {
      push_back_sum( answers, ret_9);
    }

  double ret_14;
  if (((t_0_j - t_0_i) >= 14))
    {
      if (basepair(t_0_seq, t_0_i, t_0_j))
      {
        TUSubsequence ret_19 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
        TUSubsequence a_15 = ret_19;
        if (is_not_empty(a_15))
        {
          TUSubsequence ret_18;
          if (unpaired(t_0_seq, (t_0_j - 2), (t_0_j - 1)))
            {
              ret_18 = BASE(t_0_seq, (t_0_j - 2), (t_0_j - 1));
            }

          else
            {
              empty( ret_18);
            }

          TUSubsequence a_14 = ret_18;
          if (is_not_empty(a_14))
          {
            TUSubsequence ret_16;
            if (unpaired(t_0_seq, (t_0_i + 1), ((t_0_i + 1) + 1)))
              {
                ret_16 = BASE(t_0_seq, (t_0_i + 1), ((t_0_i + 1) + 1));
              }

            else
              {
                empty( ret_16);
              }

            TUSubsequence a_12 = ret_16;
            if (is_not_empty(a_12))
            {
              TUSubsequence ret_15 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
              TUSubsequence a_11 = ret_15;
              if (is_not_empty(a_11))
              {
                double ret_17 = nt_ml_comps((t_0_i + 2), (t_0_j - 2));
                double a_13 = ret_17;
                if (is_not_empty(a_13))
                  {
                    ret_14 = mldlr(a_11, a_12, a_13, a_14, a_15);
                  }

                else
                  {
                    empty( ret_14);
                  }

                erase( a_13);
              }

              else
                {
                  empty( ret_14);
                }

              erase( a_11);
            }

            else
              {
                empty( ret_14);
              }

            erase( a_12);
          }

          else
            {
              empty( ret_14);
            }

          erase( a_14);
        }

        else
          {
            empty( ret_14);
          }

        erase( a_15);
      }

      else
      {
        empty( ret_14);
        empty( ret_14);
      }

    }

  else
    {
      empty( ret_14);
    }

  if (is_not_empty(ret_14))
    {
      push_back_sum( answers, ret_14);
    }

  double eval = h(answers);
  erase( answers);
  return eval;
}

double pfall_microstate::nt_rightB(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 8))
    {
      return float_zero;
    }

  double answers;
  empty(answers);
  empty( answers);

  if (((t_0_j - t_0_i) >= 8))
    {
      if (basepair(t_0_seq, t_0_i, t_0_j))
        {
          for(          unsigned int t_0_k_0 = (((t_0_j - (t_0_i + 6)) >= 31)) ? ((t_0_j - 31)) : ((t_0_i + 6)); (t_0_k_0 <= (t_0_j - 2)); ++t_0_k_0)
          {
            TUSubsequence ret_4 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
            TUSubsequence a_3 = ret_4;
            if (is_not_empty(a_3))
            {
              TUSubsequence ret_3;
              if ((maxsize(t_0_seq, t_0_k_0, (t_0_j - 1), 30) && unpaired(t_0_seq, t_0_k_0, (t_0_j - 1))))
                {
                  ret_3 = REGION(t_0_seq, t_0_k_0, (t_0_j - 1));
                }

              else
                {
                  empty( ret_3);
                }

              TUSubsequence a_2 = ret_3;
              if (is_not_empty(a_2))
              {
                TUSubsequence ret_1 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
                TUSubsequence a_0 = ret_1;
                if (is_not_empty(a_0))
                {
                  double ret_2 = nt_strong((t_0_i + 1), t_0_k_0);
                  double a_1 = ret_2;
                  if (is_not_empty(a_1))
                  {
                    double ans = br(a_0, a_1, a_2, a_3);
                    push_back_sum( answers, ans);
                  }

                  erase( a_1);
                }

                erase( a_0);
              }

              erase( a_2);
            }

            erase( a_3);
          }

        }

      else
        {
          empty( answers);
        }

    }

  double eval = h(answers);
  erase( answers);
  return eval;
}

double pfall_microstate::nt_stack(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 7))
    {
      return float_zero;
    }

  double answers;
  empty(answers);
  empty( answers);
  double ret_0;
  if (((t_0_j - t_0_i) >= 7))
    {
      if (basepair(t_0_seq, t_0_i, t_0_j))
      {
        TUSubsequence ret_3 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
        TUSubsequence a_2 = ret_3;
        if (is_not_empty(a_2))
        {
          TUSubsequence ret_1 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
          TUSubsequence a_0 = ret_1;
          if (is_not_empty(a_0))
          {
            double ret_2 = nt_weak((t_0_i + 1), (t_0_j - 1));
            double a_1 = ret_2;
            if (is_not_empty(a_1))
              {
                ret_0 = sr(a_0, a_1, a_2);
              }

            else
              {
                empty( ret_0);
              }

            erase( a_1);
          }

          else
            {
              empty( ret_0);
            }

          erase( a_0);
        }

        else
          {
            empty( ret_0);
          }

        erase( a_2);
      }

      else
      {
        empty( ret_0);
        empty( ret_0);
      }

    }

  else
    {
      empty( ret_0);
    }

  if (is_not_empty(ret_0))
    {
      push_back_sum( answers, ret_0);
    }

  double eval = h(answers);
  erase( answers);
  return eval;
}

double &  pfall_microstate::nt_strong(unsigned int t_0_i, unsigned int t_0_j)
{
  if (strong_table.is_tabulated(t_0_i, t_0_j))
    {
      return strong_table.get(t_0_i, t_0_j);
    }

  double answers;
  empty(answers);
  empty( answers);
  double ret_0;
  empty( ret_0);
  if (allowLonelyBasepairs(t_0_seq, t_0_i, t_0_j, false))
  {
    double ret_1;
    if (((t_0_j - t_0_i) >= 7))
      {
        if (basepair(t_0_seq, t_0_i, t_0_j))
        {
          TUSubsequence ret_4 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
          TUSubsequence a_2 = ret_4;
          if (is_not_empty(a_2))
          {
            TUSubsequence ret_2 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
            TUSubsequence a_0 = ret_2;
            if (is_not_empty(a_0))
            {
              double ret_3 = nt_weak((t_0_i + 1), (t_0_j - 1));
              double a_1 = ret_3;
              if (is_not_empty(a_1))
                {
                  ret_1 = sr(a_0, a_1, a_2);
                }

              else
                {
                  empty( ret_1);
                }

              erase( a_1);
            }

            else
              {
                empty( ret_1);
              }

            erase( a_0);
          }

          else
            {
              empty( ret_1);
            }

          erase( a_2);
        }

        else
        {
          empty( ret_1);
          empty( ret_1);
        }

      }

    else
      {
        empty( ret_1);
      }

    ret_0 = ret_1;
  }

  if (is_not_empty(ret_0))
    {
      push_back_sum( answers, ret_0);
    }

  double ret_5;
  empty( ret_5);
  if (allowLonelyBasepairs(t_0_seq, t_0_i, t_0_j, true))
  {
    double ret_6 = nt_weak(t_0_i, t_0_j);
    ret_5 = ret_6;
  }

  if (is_not_empty(ret_5))
    {
      push_back_sum( answers, ret_5);
    }

  double eval = h(answers);
  erase( answers);
  strong_table.set( t_0_i, t_0_j, eval);
  return strong_table.get(t_0_i, t_0_j);
}

double &  pfall_microstate::nt_struct(unsigned int t_0_i)
{
  if (struct_table.is_tabulated(t_0_i))
    {
      return struct_table.get(t_0_i);
    }

  double answers;
  empty(answers);
  empty( answers);
  double ret_0;
  if (((t_0_right_most - t_0_i) >= 1))
  {
    TUSubsequence ret_1;
    if (unpaired(t_0_seq, t_0_i, (t_0_i + 1)))
      {
        ret_1 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
      }

    else
      {
        empty( ret_1);
      }

    TUSubsequence a_0 = ret_1;
    if (is_not_empty(a_0))
    {
      double ret_2 = nt_struct((t_0_i + 1));
      double a_1 = ret_2;
      if (is_not_empty(a_1))
        {
          ret_0 = sadd(a_0, a_1);
        }

      else
        {
          empty( ret_0);
        }

      erase( a_1);
    }

    else
      {
        empty( ret_0);
      }

    erase( a_0);
  }

  else
    {
      empty( ret_0);
    }

  if (is_not_empty(ret_0))
    {
      push_back_sum( answers, ret_0);
    }


  if (((t_0_right_most - t_0_i) >= 5))
    {
      for(      unsigned int t_0_k_0 = (t_0_i + 5); (t_0_k_0 <= t_0_right_most); ++t_0_k_0)
      {
        double ret_5 = nt_struct(t_0_k_0);
        double a_3 = ret_5;
        if (is_not_empty(a_3))
        {
          double ret_4 = nt_dangle(t_0_i, t_0_k_0);
          double a_2 = ret_4;
          if (is_not_empty(a_2))
          {
            double ans = cadd(a_2, a_3);
            push_back_sum( answers, ans);
          }

          erase( a_2);
        }

        erase( a_3);
      }

    }

  double ret_6;
  if ((((t_0_right_most - t_0_i) >= 0) && ((t_0_right_most - t_0_i) <= 0)))
  {
    TUSubsequence ret_7 = LOC(t_0_seq, t_0_i, t_0_i);
    TUSubsequence a_4 = ret_7;
    if (is_not_empty(a_4))
      {
        ret_6 = nil(a_4);
      }

    else
      {
        empty( ret_6);
      }

    erase( a_4);
  }

  else
    {
      empty( ret_6);
    }

  if (is_not_empty(ret_6))
    {
      push_back_sum( answers, ret_6);
    }

  double eval = h(answers);
  erase( answers);
  struct_table.set( t_0_i, eval);
  return struct_table.get(t_0_i);
}

double &  pfall_microstate::nt_weak(unsigned int t_0_i, unsigned int t_0_j)
{
  if (weak_table.is_tabulated(t_0_i, t_0_j))
    {
      return weak_table.get(t_0_i, t_0_j);
    }

  double answers;
  empty(answers);
  empty( answers);


  double ret_1 = nt_stack(t_0_i, t_0_j);
  if (is_not_empty(ret_1))
    {
      push_back_sum( answers, ret_1);
    }

  double ret_2 = nt_hairpin(t_0_i, t_0_j);
  if (is_not_empty(ret_2))
    {
      push_back_sum( answers, ret_2);
    }

  double ret_3 = nt_leftB(t_0_i, t_0_j);
  if (is_not_empty(ret_3))
    {
      push_back_sum( answers, ret_3);
    }

  double ret_4 = nt_rightB(t_0_i, t_0_j);
  if (is_not_empty(ret_4))
    {
      push_back_sum( answers, ret_4);
    }

  double ret_5 = nt_iloop(t_0_i, t_0_j);
  if (is_not_empty(ret_5))
    {
      push_back_sum( answers, ret_5);
    }

  double ret_6 = nt_multiloop(t_0_i, t_0_j);
  if (is_not_empty(ret_6))
    {
      push_back_sum( answers, ret_6);
    }

  double eval = h(answers);
  erase( answers);
  weak_table.set( t_0_i, t_0_j, eval);
  return weak_table.get(t_0_i, t_0_j);
}


double pfall_microstate::addss(double x, const TUSubsequence & r)
{
#line 1800 "../../../ali_microstate.gap"
  return ((x * scale((r.j - r.i))) * mk_pf((ss_energy(r) / float(rows(r)))));
#line 1634 "pfall_microstate.cc"
}

double pfall_microstate::bl(const TUSubsequence & lb, const TUSubsequence & lr, double x, const TUSubsequence & rb)
{
#line 1775 "../../../ali_microstate.gap"
  return ((x * scale(((2 + lr.j) - lr.i))) * mk_pf(((bl_energy(lr, rb) / float(rows(lb))) + covscore(lb, lb.i, rb.i))));
#line 1641 "pfall_microstate.cc"
}

double pfall_microstate::br(const TUSubsequence & lb, double x, const TUSubsequence & rr, const TUSubsequence & rb)
{
#line 1778 "../../../ali_microstate.gap"
  return ((x * scale(((2 + rr.j) - rr.i))) * mk_pf(((br_energy(lb, rr) / float(rows(lb))) + covscore(lb, lb.i, rb.i))));
#line 1648 "pfall_microstate.cc"
}

double pfall_microstate::cadd(double x, double y)
{
#line 1743 "../../../ali_microstate.gap"
  return (x * y);
#line 1655 "pfall_microstate.cc"
}

double pfall_microstate::drem(const TUSubsequence & lb, double x, const TUSubsequence & rb)
{
#line 1766 "../../../ali_microstate.gap"
  return (x * mk_pf((termau_energy(lb, rb) / float(rows(lb)))));
#line 1662 "pfall_microstate.cc"
}

double pfall_microstate::edl(const TUSubsequence & ldangle, double x, const TUSubsequence & rb)
{
#line 1746 "../../../ali_microstate.gap"
  TUSubsequence lb = ldangle;
  lb.i = (ldangle.i + 1);
  return ((x * scale(1)) * mk_pf(( ( (termau_energy(lb, rb) + dl_energy(lb, rb)) )  / float(rows(ldangle)))));
#line 1671 "pfall_microstate.cc"
}

double pfall_microstate::edlr(const TUSubsequence & ldangle, double x, const TUSubsequence & rdangle)
{
#line 1758 "../../../ali_microstate.gap"
  TUSubsequence lb = ldangle;
  lb.i = (ldangle.i + 1);
  TUSubsequence rb = rdangle;
  rb.j = (rdangle.j - 1);
  return ((x * scale(2)) * mk_pf(( ( (termau_energy(lb, rb) + ext_mismatch_energy(lb, rb)) )  / float(rows(ldangle)))));
#line 1682 "pfall_microstate.cc"
}

double pfall_microstate::edr(const TUSubsequence & lb, double x, const TUSubsequence & rdangle)
{
#line 1752 "../../../ali_microstate.gap"
  TUSubsequence rb = rdangle;
  rb.j = (rdangle.j - 1);
  return ((x * scale(1)) * mk_pf(( ( (termau_energy(lb, rb) + dr_energy(lb, rb)) )  / float(rows(lb)))));
#line 1691 "pfall_microstate.cc"
}

double pfall_microstate::h(double i)
{
  return i;
  return sum(i);
}

double pfall_microstate::hl(const TUSubsequence & lb, const TUSubsequence & r, const TUSubsequence & rb)
{
#line 1772 "../../../ali_microstate.gap"
  return (scale(((2 + r.j) - r.i)) * mk_pf((int((hl_energy(r) / float(rows(r)))) + covscore(lb, lb.i, rb.i))));
#line 1704 "pfall_microstate.cc"
}

double pfall_microstate::il(const TUSubsequence & lb, const TUSubsequence & lr, double x, const TUSubsequence & rr, const TUSubsequence & rb)
{
#line 1781 "../../../ali_microstate.gap"
  return ((x * scale(((((2 + lr.j) - lr.i) + rr.j) - rr.i))) * mk_pf(((il_energy(lr, rr) / float(rows(lr))) + covscore(lb, lb.i, rb.i))));
#line 1711 "pfall_microstate.cc"
}

double pfall_microstate::incl(double x)
{
#line 1797 "../../../ali_microstate.gap"
  return (x * mk_pf(ul_energy()));
#line 1718 "pfall_microstate.cc"
}

double pfall_microstate::ml(const TUSubsequence & lb, double x, const TUSubsequence & rb)
{
#line 1794 "../../../ali_microstate.gap"
  return ((x * scale(2)) * mk_pf((((ml_energy() + ul_energy()) +  ( (termau_energy(lb, rb) / float(rows(lb))) ) ) + covscore(lb, lb.i, rb.i))));
#line 1725 "pfall_microstate.cc"
}

double pfall_microstate::mldl(const TUSubsequence & lb, const TUSubsequence & dl, double x, const TUSubsequence & rb)
{
#line 1785 "../../../ali_microstate.gap"
  return ((x * scale(3)) * mk_pf((((ml_energy() + ul_energy()) +  ( ( ( (termau_energy(lb, rb) + dli_energy(lb, rb)) )  / float(rows(lb))) ) ) + covscore(lb, lb.i, rb.i))));
#line 1732 "pfall_microstate.cc"
}

double pfall_microstate::mldlr(const TUSubsequence & lb, const TUSubsequence & dl, double x, const TUSubsequence & dr, const TUSubsequence & rb)
{
#line 1791 "../../../ali_microstate.gap"
  return ((x * scale(4)) * mk_pf((((ml_energy() + ul_energy()) +  ( ( ( (termau_energy(lb, rb) + ml_mismatch_energy(lb, rb)) )  / float(rows(lb))) ) ) + covscore(lb, lb.i, rb.i))));
#line 1739 "pfall_microstate.cc"
}

double pfall_microstate::mldr(const TUSubsequence & lb, double x, const TUSubsequence & dr, const TUSubsequence & rb)
{
#line 1788 "../../../ali_microstate.gap"
  return ((x * scale(3)) * mk_pf((((ml_energy() + ul_energy()) +  ( ( ( (termau_energy(lb, rb) + dri_energy(lb, rb)) )  / float(rows(lb))) ) ) + covscore(lb, lb.i, rb.i))));
#line 1746 "pfall_microstate.cc"
}

double pfall_microstate::nil(const TUSubsequence & n)
{
#line 1803 "../../../ali_microstate.gap"
  return 1.000000e+00;
#line 1753 "pfall_microstate.cc"
}

double pfall_microstate::sadd(const TUSubsequence & lb, double x)
{
#line 1734 "../../../ali_microstate.gap"
  double sbase_sum = 0;
  for(  int k = 0; (k < int(rows(lb)));   k = (k + 1))
  {
    if ((column(seq_char(lb, lb.i), k) != GAP_BASE))
      {
        sbase_sum = (sbase_sum + sbase_energy());
      }

  }

  return ((x * scale(1)) * mk_pf((sbase_sum / float(rows(lb)))));
#line 1770 "pfall_microstate.cc"
}

double pfall_microstate::sr(const TUSubsequence & lb, double x, const TUSubsequence & rb)
{
#line 1769 "../../../ali_microstate.gap"
  return ((x * scale(2)) * mk_pf((int((sr_energy(lb, rb) / float(rows(lb)))) + covscore(lb, lb.i, rb.i))));
#line 1777 "pfall_microstate.cc"
}


    void pfall_microstate::cyk()
{

}



#ident "$Id: Compiled with gapc bellmansgapc-2013.05.02 $"

