
// A dynamic programming evaluator generated by GAP-C.
// 
//   GAP-C version:
//     bellmansgapc-2013.05.02
// 
//   GAP-C call:
//     /home/jhuang/local/gapc/bin/gapc -I ../../../ -p ((alg_ali_hishape_h * (alg_ali_mfe % alg_ali_pfunc)) suchthat filterLowProbShapes) * (alg_ali_dotBracket * alg_ali_pfunc) ../../../ali_microstate.gap --kbacktrace --no-coopt-class --kbest -o probs_h_microstate.cc 
// 
// 


#ifndef probs_h_microstate_hh
#define probs_h_microstate_hh

#include "rtlib/adp.hh"

typedef Basic_Subsequence<M_Char, unsigned> TUSubsequence;

typedef Shape shape_t;
#include <rtlib/subopt.hh>
#include "rna.hh"
#include "Extensions/alifold.hh"
#include "Extensions/mfesubopt.hh"
#include "Extensions/probabilities.hh"
#include "Extensions/typesRNAfolding.hh"
//#include "Extensions/shapes.hh"

#include "Extensions/rnaoptions.hh"

class probs_h_microstate_insp_hash_h {
public:
typedef std::pair<Rope, std::pair<mfecovar, double> >  type;
private:
filterLowProbShapes<type> filterLowProbShapes_;
static uint32_t k_;
public:
uint32_t hash(const type &x) const
{
return hashable_value(left_most(x));
}
type init(const type &src) const
{
type dst(src);
{
  return src;
}
}
void update(type &dst, const type &src) 
{
  update_filter( filterLowProbShapes_, src);
  if ((src.second.first < dst.second.first))
    {
      dst.second.first = src.second.first;
    }

  dst.second.second += src.second.second;
}
bool equal(const type &a, const type &b) const
{
return left_most(a) == left_most(b);
}
bool filter() const { return true; }
bool filter(const type &x) const
{
bool b0 = !filterLowProbShapes_.ok(x);
return b0 ;
}
void finalize(type &src) const
{
}
static void set_k(uint32_t a) { k_ = a; }
uint32_t k() const
{
  return k_;
}
bool cutoff() const
{
  return true;
}
bool equal_score(const type &src, const type &dst) const
{
  return (src.second.first == dst.second.first);
}
struct compare {
bool operator()(const type &src, const type &dst) const
{
  return (src.second.first < dst.second.first);
}
};
};

typedef Hash::Ref<std::pair<Rope, std::pair<mfecovar, double> > , probs_h_microstate_insp_hash_h > probs_h_microstate_hash_h;


class probs_h_microstate {

  public:
Basic_Sequence<M_Char> t_0_seq;
unsigned int t_0_left_most;
unsigned int t_0_right_most;

probs_h_microstate_hash_h LBRope_firstG_Bmfecovar_firstG_float_secondG_E_secondG_EMhdecl0x2077aa0_zero;

class dangle_table_t {

private:

unsigned int t_0_left_most;
unsigned int t_0_right_most;
std::vector<probs_h_microstate_hash_h > array;
std::vector<bool> tabulated;
unsigned int t_0_n;
probs_h_microstate_hash_h zero;
unsigned int size()
{
  return (1 * ((((t_0_n * (t_0_n + 1)) / 2) + t_0_n) + 1));
}


public:

dangle_table_t()
{
  empty(zero);
}

void init(unsigned int t_0_n_, const std::string &tname)
{
t_0_n = t_0_n_;
t_0_left_most = 0;
t_0_right_most = t_0_n;
unsigned int newsize = size();
array.resize(newsize);
tabulated.clear();
tabulated.resize(newsize);
}
bool is_tabulated(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 5))
    {
      return true;
    }

  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  return tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void clear() { tabulated.clear(); }
probs_h_microstate_hash_h &  get(unsigned int t_0_i, unsigned int t_0_j)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 5))
    {
      return zero;
    }

  assert( tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))]);
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  return array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void set(unsigned int t_0_i, unsigned int t_0_j,  const probs_h_microstate_hash_h &  e)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 5))
    {
      assert( 0);
    }

  assert( !is_tabulated(t_0_i, t_0_j));
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = e;
  tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = true;
}


};
dangle_table_t dangle_table;


class iloop_table_t {

private:

unsigned int t_0_left_most;
unsigned int t_0_right_most;
std::vector<probs_h_microstate_hash_h > array;
std::vector<bool> tabulated;
unsigned int t_0_n;
probs_h_microstate_hash_h zero;
unsigned int size()
{
  return (1 * ((((t_0_n * (t_0_n + 1)) / 2) + t_0_n) + 1));
}


public:

iloop_table_t()
{
  empty(zero);
}

void init(unsigned int t_0_n_, const std::string &tname)
{
t_0_n = t_0_n_;
t_0_left_most = 0;
t_0_right_most = t_0_n;
unsigned int newsize = size();
array.resize(newsize);
tabulated.clear();
tabulated.resize(newsize);
}
bool is_tabulated(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 9))
    {
      return true;
    }

  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  return tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void clear() { tabulated.clear(); }
probs_h_microstate_hash_h &  get(unsigned int t_0_i, unsigned int t_0_j)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 9))
    {
      return zero;
    }

  assert( tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))]);
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  return array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void set(unsigned int t_0_i, unsigned int t_0_j,  const probs_h_microstate_hash_h &  e)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 9))
    {
      assert( 0);
    }

  assert( !is_tabulated(t_0_i, t_0_j));
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = e;
  tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = true;
}


};
iloop_table_t iloop_table;


class ml_comps_table_t {

private:

unsigned int t_0_left_most;
unsigned int t_0_right_most;
std::vector<probs_h_microstate_hash_h > array;
std::vector<bool> tabulated;
unsigned int t_0_n;
probs_h_microstate_hash_h zero;
unsigned int size()
{
  return (1 * ((((t_0_n * (t_0_n + 1)) / 2) + t_0_n) + 1));
}


public:

ml_comps_table_t()
{
  empty(zero);
}

void init(unsigned int t_0_n_, const std::string &tname)
{
t_0_n = t_0_n_;
t_0_left_most = 0;
t_0_right_most = t_0_n;
unsigned int newsize = size();
array.resize(newsize);
tabulated.clear();
tabulated.resize(newsize);
}
bool is_tabulated(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 10))
    {
      return true;
    }

  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  return tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void clear() { tabulated.clear(); }
probs_h_microstate_hash_h &  get(unsigned int t_0_i, unsigned int t_0_j)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 10))
    {
      return zero;
    }

  assert( tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))]);
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  return array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void set(unsigned int t_0_i, unsigned int t_0_j,  const probs_h_microstate_hash_h &  e)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 10))
    {
      assert( 0);
    }

  assert( !is_tabulated(t_0_i, t_0_j));
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = e;
  tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = true;
}


};
ml_comps_table_t ml_comps_table;


class ml_comps1_table_t {

private:

unsigned int t_0_left_most;
unsigned int t_0_right_most;
std::vector<probs_h_microstate_hash_h > array;
std::vector<bool> tabulated;
unsigned int t_0_n;
probs_h_microstate_hash_h zero;
unsigned int size()
{
  return (1 * ((((t_0_n * (t_0_n + 1)) / 2) + t_0_n) + 1));
}


public:

ml_comps1_table_t()
{
  empty(zero);
}

void init(unsigned int t_0_n_, const std::string &tname)
{
t_0_n = t_0_n_;
t_0_left_most = 0;
t_0_right_most = t_0_n;
unsigned int newsize = size();
array.resize(newsize);
tabulated.clear();
tabulated.resize(newsize);
}
bool is_tabulated(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 5))
    {
      return true;
    }

  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  return tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void clear() { tabulated.clear(); }
probs_h_microstate_hash_h &  get(unsigned int t_0_i, unsigned int t_0_j)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 5))
    {
      return zero;
    }

  assert( tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))]);
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  return array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void set(unsigned int t_0_i, unsigned int t_0_j,  const probs_h_microstate_hash_h &  e)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 5))
    {
      assert( 0);
    }

  assert( !is_tabulated(t_0_i, t_0_j));
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = e;
  tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = true;
}


};
ml_comps1_table_t ml_comps1_table;


class strong_table_t {

private:

unsigned int t_0_left_most;
unsigned int t_0_right_most;
std::vector<probs_h_microstate_hash_h > array;
std::vector<bool> tabulated;
unsigned int t_0_n;
probs_h_microstate_hash_h zero;
unsigned int size()
{
  return (1 * ((((t_0_n * (t_0_n + 1)) / 2) + t_0_n) + 1));
}


public:

strong_table_t()
{
  empty(zero);
}

void init(unsigned int t_0_n_, const std::string &tname)
{
t_0_n = t_0_n_;
t_0_left_most = 0;
t_0_right_most = t_0_n;
unsigned int newsize = size();
array.resize(newsize);
tabulated.clear();
tabulated.resize(newsize);
}
bool is_tabulated(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 5))
    {
      return true;
    }

  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  return tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void clear() { tabulated.clear(); }
probs_h_microstate_hash_h &  get(unsigned int t_0_i, unsigned int t_0_j)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 5))
    {
      return zero;
    }

  assert( tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))]);
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  return array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void set(unsigned int t_0_i, unsigned int t_0_j,  const probs_h_microstate_hash_h &  e)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 5))
    {
      assert( 0);
    }

  assert( !is_tabulated(t_0_i, t_0_j));
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = e;
  tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = true;
}


};
strong_table_t strong_table;


class struct_table_t {

private:

unsigned int t_0_left_most;
unsigned int t_0_right_most;
std::vector<probs_h_microstate_hash_h > array;
std::vector<bool> tabulated;
unsigned int t_0_n;
probs_h_microstate_hash_h zero;
unsigned int size()
{
  return (1 * ((t_0_n + 1) * 1));
}


public:

struct_table_t()
{
  empty(zero);
}

void init(unsigned int t_0_n_, const std::string &tname)
{
t_0_n = t_0_n_;
t_0_left_most = 0;
t_0_right_most = t_0_n;
unsigned int newsize = size();
array.resize(newsize);
tabulated.clear();
tabulated.resize(newsize);
}
bool is_tabulated(unsigned int t_0_i)
{
  unsigned int t_0_j = t_0_n;
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if ((t_0_j < (t_0_n - 0)))
    {
      return true;
    }

  unsigned int t_0_real_j = (t_0_n - t_0_j);
  return tabulated[(0 + (1 * (t_0_i + (t_0_real_j * (t_0_n + 1)))))];
}


void clear() { tabulated.clear(); }
probs_h_microstate_hash_h &  get(unsigned int t_0_i)
{
  unsigned int t_0_j = t_0_n;
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if ((t_0_j < (t_0_n - 0)))
    {
      return zero;
    }

  unsigned int t_0_real_j = (t_0_n - t_0_j);
  assert( tabulated[(0 + (1 * (t_0_i + (t_0_real_j * (t_0_n + 1)))))]);
  assert( ((0 + (1 * (t_0_i + (t_0_real_j * (t_0_n + 1))))) < size()));
  return array[(0 + (1 * (t_0_i + (t_0_real_j * (t_0_n + 1)))))];
}


void set(unsigned int t_0_i,  const probs_h_microstate_hash_h &  e)
{
  unsigned int t_0_j = t_0_n;
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if ((t_0_j < (t_0_n - 0)))
    {
      return;
    }

  unsigned int t_0_real_j = (t_0_n - t_0_j);
  assert( !is_tabulated(t_0_i));
  assert( ((0 + (1 * (t_0_i + (t_0_real_j * (t_0_n + 1))))) < size()));
  array[(0 + (1 * (t_0_i + (t_0_real_j * (t_0_n + 1)))))] = e;
  tabulated[(0 + (1 * (t_0_i + (t_0_real_j * (t_0_n + 1)))))] = true;
}


};
struct_table_t struct_table;


class weak_table_t {

private:

unsigned int t_0_left_most;
unsigned int t_0_right_most;
std::vector<probs_h_microstate_hash_h > array;
std::vector<bool> tabulated;
unsigned int t_0_n;
probs_h_microstate_hash_h zero;
unsigned int size()
{
  return (1 * ((((t_0_n * (t_0_n + 1)) / 2) + t_0_n) + 1));
}


public:

weak_table_t()
{
  empty(zero);
}

void init(unsigned int t_0_n_, const std::string &tname)
{
t_0_n = t_0_n_;
t_0_left_most = 0;
t_0_right_most = t_0_n;
unsigned int newsize = size();
array.resize(newsize);
tabulated.clear();
tabulated.resize(newsize);
}
bool is_tabulated(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 5))
    {
      return true;
    }

  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  return tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void clear() { tabulated.clear(); }
probs_h_microstate_hash_h &  get(unsigned int t_0_i, unsigned int t_0_j)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 5))
    {
      return zero;
    }

  assert( tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))]);
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  return array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void set(unsigned int t_0_i, unsigned int t_0_j,  const probs_h_microstate_hash_h &  e)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 5))
    {
      assert( 0);
    }

  assert( !is_tabulated(t_0_i, t_0_j));
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = e;
  tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = true;
}


};
weak_table_t weak_table;



//void init(const gapc::Opts &opts)
void init(const std::vector<std::pair<const char *, unsigned> > &inp, uint32_t kbest, const std::string &matchStr, const bool exact, const float thresh)
{
//const std::vector<std::pair<const char *, unsigned> > &inp = opts.inputs;
if(inp.size() != 1)
  throw gapc::OptException("Number of input sequences does not match.");

  t_0_seq.copy(inp[0].first, inp[0].second);
char_to_rna(t_0_seq);
  dangle_table.init( t_0_seq.size(), "dangle_table");
  iloop_table.init( t_0_seq.size(), "iloop_table");
  ml_comps_table.init( t_0_seq.size(), "ml_comps_table");
  ml_comps1_table.init( t_0_seq.size(), "ml_comps1_table");
  strong_table.init( t_0_seq.size(), "strong_table");
  struct_table.init( t_0_seq.size(), "struct_table");
  weak_table.init( t_0_seq.size(), "weak_table");
empty(LBRope_firstG_Bmfecovar_firstG_float_secondG_E_secondG_EMhdecl0x2077aa0_zero);

t_0_left_most = 0;
t_0_right_most = t_0_seq.size();
probs_h_microstate_insp_hash_h::set_k(kbest);
    std::vector<std::string> tokens;      
    const std::string delimiters = ",";   
    // Skip delimiters at beginning.
    std::string::size_type lastPos = matchStr.find_first_not_of(delimiters, 0);
    // Find first "non-delimiter".
    std::string::size_type pos     = matchStr.find_first_of(delimiters, lastPos);
    while (std::string::npos != pos || std::string::npos != lastPos)
    {
        // Found a token, add it to the vector.
        tokens.push_back(matchStr.substr(lastPos, pos - lastPos));
        // Skip delimiters.  Note the "not_of"
        lastPos = matchStr.find_first_not_of(delimiters, pos);
        // Find next "non-delimiter"
        pos = matchStr.find_first_of(delimiters, lastPos);
    }


    std::vector<std::string>::iterator it;
    for ( it=tokens.begin() ; it < tokens.end(); it++ ) {
      std::string tmp = *it;
      if (tmp[tmp.length()-1] == 'm') {
        tmp.erase(tmp.length()-1);
        _match_tokens_m.push_back(tmp);
      } else if (tmp[tmp.length()-1] == 'i') {
        tmp.erase(tmp.length()-1);
        _match_tokens_i.push_back(tmp);
      } else if (tmp[tmp.length()-1] == 'b') {
        tmp.erase(tmp.length()-1);
        _match_tokens_b.push_back(tmp);
      } else {
        _match_tokens_h.push_back(tmp);
      }
    }
    _matchStr = matchStr;
    _exact = exact;
    _thresh = thresh;
}

  private:
    std::vector<std::string> _match_tokens_h, _match_tokens_m, _match_tokens_i, _match_tokens_b;
    std::string _matchStr;
    bool _exact; 
    float _thresh;
    probs_h_microstate_hash_h &  nt_dangle(unsigned int t_0_i, unsigned int t_0_j);
    probs_h_microstate_hash_h nt_hairpin(unsigned int t_0_i, unsigned int t_0_j);
    probs_h_microstate_hash_h &  nt_iloop(unsigned int t_0_i, unsigned int t_0_j);
    probs_h_microstate_hash_h nt_leftB(unsigned int t_0_i, unsigned int t_0_j);
    probs_h_microstate_hash_h &  nt_ml_comps(unsigned int t_0_i, unsigned int t_0_j);
    probs_h_microstate_hash_h &  nt_ml_comps1(unsigned int t_0_i, unsigned int t_0_j);
    probs_h_microstate_hash_h nt_multiloop(unsigned int t_0_i, unsigned int t_0_j);
    probs_h_microstate_hash_h nt_rightB(unsigned int t_0_i, unsigned int t_0_j);
    probs_h_microstate_hash_h nt_stack(unsigned int t_0_i, unsigned int t_0_j);
    probs_h_microstate_hash_h &  nt_strong(unsigned int t_0_i, unsigned int t_0_j);
    probs_h_microstate_hash_h &  nt_struct(unsigned int t_0_i);
    probs_h_microstate_hash_h &  nt_weak(unsigned int t_0_i, unsigned int t_0_j);

    std::pair<Rope, std::pair<mfecovar, double> >  addss(const std::pair<Rope, std::pair<mfecovar, double> > & p_e, const TUSubsequence & p_rb);
    std::pair<Rope, std::pair<mfecovar, double> >  bl(const TUSubsequence & p_lb, const TUSubsequence & p_lregion, const std::pair<Rope, std::pair<mfecovar, double> > & p_e, const TUSubsequence & p_rb);
    std::pair<Rope, std::pair<mfecovar, double> >  br(const TUSubsequence & p_lb, const std::pair<Rope, std::pair<mfecovar, double> > & p_e, const TUSubsequence & p_rregion, const TUSubsequence & p_rb);
    std::pair<Rope, std::pair<mfecovar, double> >  cadd(const std::pair<Rope, std::pair<mfecovar, double> > & p_le, const std::pair<Rope, std::pair<mfecovar, double> > & p_re);
    std::pair<Rope, std::pair<mfecovar, double> >  drem(const TUSubsequence & p_lloc, const std::pair<Rope, std::pair<mfecovar, double> > & p_e, const TUSubsequence & p_rloc);
    std::pair<Rope, std::pair<mfecovar, double> >  edl(const TUSubsequence & p_lb, const std::pair<Rope, std::pair<mfecovar, double> > & p_e, const TUSubsequence & p_rloc);
    std::pair<Rope, std::pair<mfecovar, double> >  edlr(const TUSubsequence & p_lb, const std::pair<Rope, std::pair<mfecovar, double> > & p_e, const TUSubsequence & p_rb);
    std::pair<Rope, std::pair<mfecovar, double> >  edr(const TUSubsequence & p_lloc, const std::pair<Rope, std::pair<mfecovar, double> > & p_e, const TUSubsequence & p_rb);
template <typename Iterator>
    probs_h_microstate_hash_h h(std::pair<Iterator, Iterator> i)
;
    std::pair<Rope, std::pair<mfecovar, double> >  hl(const TUSubsequence & p_lb, const TUSubsequence & p_region, const TUSubsequence & p_rb);
    std::pair<Rope, std::pair<mfecovar, double> >  il(const TUSubsequence & p_lb, const TUSubsequence & p_lregion, const std::pair<Rope, std::pair<mfecovar, double> > & p_e, const TUSubsequence & p_rregion, const TUSubsequence & p_rb);
    std::pair<Rope, std::pair<mfecovar, double> >  incl(const std::pair<Rope, std::pair<mfecovar, double> > & p_e);
    std::pair<Rope, std::pair<mfecovar, double> >  ml(const TUSubsequence & p_lb, const std::pair<Rope, std::pair<mfecovar, double> > & p_e, const TUSubsequence & p_rb);
    std::pair<Rope, std::pair<mfecovar, double> >  mldl(const TUSubsequence & p_lb, const TUSubsequence & p_dl, const std::pair<Rope, std::pair<mfecovar, double> > & p_e, const TUSubsequence & p_rb);
    std::pair<Rope, std::pair<mfecovar, double> >  mldlr(const TUSubsequence & p_lb, const TUSubsequence & p_dl, const std::pair<Rope, std::pair<mfecovar, double> > & p_e, const TUSubsequence & p_dr, const TUSubsequence & p_rb);
    std::pair<Rope, std::pair<mfecovar, double> >  mldr(const TUSubsequence & p_lb, const std::pair<Rope, std::pair<mfecovar, double> > & p_e, const TUSubsequence & p_dr, const TUSubsequence & p_rb);
    std::pair<Rope, std::pair<mfecovar, double> >  nil(const TUSubsequence & p_loc);
    std::pair<Rope, std::pair<mfecovar, double> >  sadd(const TUSubsequence & p_b, const std::pair<Rope, std::pair<mfecovar, double> > & p_e);
    std::pair<Rope, std::pair<mfecovar, double> >  sr(const TUSubsequence & p_lb, const std::pair<Rope, std::pair<mfecovar, double> > & p_e, const TUSubsequence & p_rb);


    Rope addss_l(const Rope & e, const TUSubsequence & rb);
    Rope bl_l(const TUSubsequence & lb, const TUSubsequence & lregion, const Rope & e, const TUSubsequence & rb);
    Rope br_l(const TUSubsequence & lb, const Rope & e, const TUSubsequence & rregion, const TUSubsequence & rb);
    Rope cadd_l(const Rope & le, const Rope & re);
    Rope drem_l(const TUSubsequence & lloc, const Rope & e, const TUSubsequence & rloc);
    Rope edl_l(const TUSubsequence & lb, const Rope & e, const TUSubsequence & rloc);
    Rope edlr_l(const TUSubsequence & lb, const Rope & e, const TUSubsequence & rb);
    Rope edr_l(const TUSubsequence & lloc, const Rope & e, const TUSubsequence & rb);
    Rope hl_l(const TUSubsequence & lb, const TUSubsequence & region, const TUSubsequence & rb);
    Rope il_l(const TUSubsequence & lb, const TUSubsequence & lregion, const Rope & e, const TUSubsequence & rregion, const TUSubsequence & rb);
    Rope incl_l(const Rope & e);
    Rope ml_l(const TUSubsequence & lb, const Rope & e, const TUSubsequence & rb);
    Rope mldl_l(const TUSubsequence & lb, const TUSubsequence & dl, const Rope & e, const TUSubsequence & rb);
    Rope mldlr_l(const TUSubsequence & lb, const TUSubsequence & dl, const Rope & e, const TUSubsequence & dr, const TUSubsequence & rb);
    Rope mldr_l(const TUSubsequence & lb, const Rope & e, const TUSubsequence & dr, const TUSubsequence & rb);
    Rope nil_l(const TUSubsequence & loc);
    Rope sadd_l(const TUSubsequence & b, const Rope & e);
    Rope sr_l(const TUSubsequence & lb, const Rope & e, const TUSubsequence & rb);


    std::pair<mfecovar, double>  addss_r(const std::pair<mfecovar, double> & p_x, const TUSubsequence & p_r);
    std::pair<mfecovar, double>  bl_r(const TUSubsequence & p_lb, const TUSubsequence & p_lr, const std::pair<mfecovar, double> & p_x, const TUSubsequence & p_rb);
    std::pair<mfecovar, double>  br_r(const TUSubsequence & p_lb, const std::pair<mfecovar, double> & p_x, const TUSubsequence & p_rr, const TUSubsequence & p_rb);
    std::pair<mfecovar, double>  cadd_r(const std::pair<mfecovar, double> & p_x, const std::pair<mfecovar, double> & p_y);
    std::pair<mfecovar, double>  drem_r(const TUSubsequence & p_lb, const std::pair<mfecovar, double> & p_x, const TUSubsequence & p_rb);
    std::pair<mfecovar, double>  edl_r(const TUSubsequence & p_ldangle, const std::pair<mfecovar, double> & p_x, const TUSubsequence & p_rb);
    std::pair<mfecovar, double>  edlr_r(const TUSubsequence & p_ldangle, const std::pair<mfecovar, double> & p_x, const TUSubsequence & p_rdangle);
    std::pair<mfecovar, double>  edr_r(const TUSubsequence & p_lb, const std::pair<mfecovar, double> & p_x, const TUSubsequence & p_rdangle);
    std::pair<mfecovar, double>  hl_r(const TUSubsequence & p_lb, const TUSubsequence & p_r, const TUSubsequence & p_rb);
    std::pair<mfecovar, double>  il_r(const TUSubsequence & p_lb, const TUSubsequence & p_lr, const std::pair<mfecovar, double> & p_x, const TUSubsequence & p_rr, const TUSubsequence & p_rb);
    std::pair<mfecovar, double>  incl_r(const std::pair<mfecovar, double> & p_x);
    std::pair<mfecovar, double>  ml_r(const TUSubsequence & p_lb, const std::pair<mfecovar, double> & p_x, const TUSubsequence & p_rb);
    std::pair<mfecovar, double>  mldl_r(const TUSubsequence & p_lb, const TUSubsequence & p_dl, const std::pair<mfecovar, double> & p_x, const TUSubsequence & p_rb);
    std::pair<mfecovar, double>  mldlr_r(const TUSubsequence & p_lb, const TUSubsequence & p_dl, const std::pair<mfecovar, double> & p_x, const TUSubsequence & p_dr, const TUSubsequence & p_rb);
    std::pair<mfecovar, double>  mldr_r(const TUSubsequence & p_lb, const std::pair<mfecovar, double> & p_x, const TUSubsequence & p_dr, const TUSubsequence & p_rb);
    std::pair<mfecovar, double>  nil_r(const TUSubsequence & p_n);
    std::pair<mfecovar, double>  sadd_r(const TUSubsequence & p_lb, const std::pair<mfecovar, double> & p_x);
    std::pair<mfecovar, double>  sr_r(const TUSubsequence & p_lb, const std::pair<mfecovar, double> & p_x, const TUSubsequence & p_rb);


    mfecovar addss_r_l(const mfecovar & x, const TUSubsequence & r);
    mfecovar bl_r_l(const TUSubsequence & lb, const TUSubsequence & lr, const mfecovar & x, const TUSubsequence & rb);
    mfecovar br_r_l(const TUSubsequence & lb, const mfecovar & x, const TUSubsequence & rr, const TUSubsequence & rb);
    mfecovar cadd_r_l(const mfecovar & x, const mfecovar & y);
    mfecovar drem_r_l(const TUSubsequence & lb, const mfecovar & x, const TUSubsequence & rb);
    mfecovar edl_r_l(const TUSubsequence & ldangle, const mfecovar & x, const TUSubsequence & rb);
    mfecovar edlr_r_l(const TUSubsequence & ldangle, const mfecovar & x, const TUSubsequence & rdangle);
    mfecovar edr_r_l(const TUSubsequence & lb, const mfecovar & x, const TUSubsequence & rdangle);
    mfecovar hl_r_l(const TUSubsequence & lb, const TUSubsequence & r, const TUSubsequence & rb);
    mfecovar il_r_l(const TUSubsequence & lb, const TUSubsequence & lr, const mfecovar & x, const TUSubsequence & rr, const TUSubsequence & rb);
    mfecovar incl_r_l(const mfecovar & x);
    mfecovar ml_r_l(const TUSubsequence & lb, const mfecovar & x, const TUSubsequence & rb);
    mfecovar mldl_r_l(const TUSubsequence & lb, const TUSubsequence & dl, const mfecovar & x, const TUSubsequence & rb);
    mfecovar mldlr_r_l(const TUSubsequence & lb, const TUSubsequence & dl, const mfecovar & x, const TUSubsequence & dr, const TUSubsequence & rb);
    mfecovar mldr_r_l(const TUSubsequence & lb, const mfecovar & x, const TUSubsequence & dr, const TUSubsequence & rb);
    mfecovar nil_r_l(const TUSubsequence & n);
    mfecovar sadd_r_l(const TUSubsequence & lb, const mfecovar & x);
    mfecovar sr_r_l(const TUSubsequence & lb, const mfecovar & x, const TUSubsequence & rb);


    double addss_r_r(double x, const TUSubsequence & r);
    double bl_r_r(const TUSubsequence & lb, const TUSubsequence & lr, double x, const TUSubsequence & rb);
    double br_r_r(const TUSubsequence & lb, double x, const TUSubsequence & rr, const TUSubsequence & rb);
    double cadd_r_r(double x, double y);
    double drem_r_r(const TUSubsequence & lb, double x, const TUSubsequence & rb);
    double edl_r_r(const TUSubsequence & ldangle, double x, const TUSubsequence & rb);
    double edlr_r_r(const TUSubsequence & ldangle, double x, const TUSubsequence & rdangle);
    double edr_r_r(const TUSubsequence & lb, double x, const TUSubsequence & rdangle);
    double hl_r_r(const TUSubsequence & lb, const TUSubsequence & r, const TUSubsequence & rb);
    double il_r_r(const TUSubsequence & lb, const TUSubsequence & lr, double x, const TUSubsequence & rr, const TUSubsequence & rb);
    double incl_r_r(double x);
    double ml_r_r(const TUSubsequence & lb, double x, const TUSubsequence & rb);
    double mldl_r_r(const TUSubsequence & lb, const TUSubsequence & dl, double x, const TUSubsequence & rb);
    double mldlr_r_r(const TUSubsequence & lb, const TUSubsequence & dl, double x, const TUSubsequence & dr, const TUSubsequence & rb);
    double mldr_r_r(const TUSubsequence & lb, double x, const TUSubsequence & dr, const TUSubsequence & rb);
    double nil_r_r(const TUSubsequence & n);
    double sadd_r_r(const TUSubsequence & lb, double x);
    double sr_r_r(const TUSubsequence & lb, double x, const TUSubsequence & rb);


 public:
   void cyk();

 public:
   probs_h_microstate_hash_h &  run()
{
  return nt_struct(t_0_left_most);
}
void print_stats(std::ostream &o)
{
#ifdef STATS
      o << "\n\nN = " << seq.size() << '\n';
      dangle_table.print_stats(o, "dangle_table");
      iloop_table.print_stats(o, "iloop_table");
      ml_comps_table.print_stats(o, "ml_comps_table");
      ml_comps1_table.print_stats(o, "ml_comps1_table");
      strong_table.print_stats(o, "strong_table");
      struct_table.print_stats(o, "struct_table");
      weak_table.print_stats(o, "weak_table");
#endif
}

template <typename Value, typename pos_int>
struct Backtrace_addss : Backtrace_Score<std::pair<Rope, std::pair<mfecovar, double> > , Value, pos_int> {
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_e;
      TUSubsequence arg_p_rb;

Backtrace_addss(intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_e_, TUSubsequence arg_p_rb_)
 : arg_p_e(arg_p_e_), arg_p_rb(arg_p_rb_)
{}

~Backtrace_addss()
{
erase(arg_p_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      String addss_l(const String & e, const TUSubsequence & rb)
      {
#line 184 ""
        String res;
        append( res, e);
        append( res, '.', size(rb));
        return res;
#line 844 ""
      }


      double addss_r(double x, const TUSubsequence & r)
      {
#line 1800 ""
        return ((x * scale((r.j - r.i))) * mk_pf((ss_energy(r) / float(rows(r)))));
#line 852 ""
      }


      std::pair<String, double>  addss(const std::pair<String, double> & p_e, const TUSubsequence & p_rb)
      {
        String l_0 = p_e.first;
        TUSubsequence l_1 = p_rb;
        double r_0 = p_e.second;
        TUSubsequence r_1 = p_rb;
        String ret_left = addss_l(l_0, l_1);
        double ret_right = addss_r(r_0, r_1);
        std::pair<String, double>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_p_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_p_e);
        if (!arg_p_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_e_bt = arg_p_e;
          intrusive_ptr<Eval_List<Value> > arg_p_e_elist = evaluate(arg_p_e_bt);
          for (typename Eval_List<Value>::iterator arg_p_e_elem_itr = arg_p_e_elist->begin(); arg_p_e_elem_itr != arg_p_e_elist->end(); ++ arg_p_e_elem_itr) {
            std::pair<String, double>  arg_p_e_elem = *arg_p_e_elem_itr;
            std::pair<String, double>  ret = addss(arg_p_e_elem, arg_p_rb);
            push_back( answer, ret);
          }
          erase( arg_p_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_p_e_bt_itr = arg_p_e_t->begin(); arg_p_e_bt_itr != arg_p_e_t->end(); ++ arg_p_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_e_bt = *arg_p_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_p_e_elist = evaluate(arg_p_e_bt);
          for (typename Eval_List<Value>::iterator arg_p_e_elem_itr = arg_p_e_elist->begin(); arg_p_e_elem_itr != arg_p_e_elist->end(); ++ arg_p_e_elem_itr) {
            std::pair<String, double>  arg_p_e_elem = *arg_p_e_elem_itr;
            std::pair<String, double>  ret = addss(arg_p_e_elem, arg_p_rb);
            push_back( answer, ret);
          }
          erase( arg_p_e_elist);
        }
        erase( arg_p_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_bl : Backtrace_Score<std::pair<Rope, std::pair<mfecovar, double> > , Value, pos_int> {
      TUSubsequence arg_p_lb;
      TUSubsequence arg_p_lregion;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_e;
      TUSubsequence arg_p_rb;

Backtrace_bl(TUSubsequence arg_p_lb_, TUSubsequence arg_p_lregion_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_e_, TUSubsequence arg_p_rb_)
 : arg_p_lb(arg_p_lb_), arg_p_lregion(arg_p_lregion_), arg_p_e(arg_p_e_), arg_p_rb(arg_p_rb_)
{}

~Backtrace_bl()
{
erase(arg_p_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      String bl_l(const TUSubsequence & lb, const TUSubsequence & lregion, const String & e, const TUSubsequence & rb)
      {
#line 120 ""
        String res;
        append( res, '(');
        append( res, '.', size(lregion));
        append( res, e);
        append( res, ')');
        return res;
#line 929 ""
      }


      double bl_r(const TUSubsequence & lb, const TUSubsequence & lr, double x, const TUSubsequence & rb)
      {
#line 1775 ""
        return ((x * scale(((2 + lr.j) - lr.i))) * mk_pf(((bl_energy(lr, rb) / float(rows(lb))) + covscore(lb, lb.i, rb.i))));
#line 937 ""
      }


      std::pair<String, double>  bl(const TUSubsequence & p_lb, const TUSubsequence & p_lregion, const std::pair<String, double> & p_e, const TUSubsequence & p_rb)
      {
        TUSubsequence l_0 = p_lb;
        TUSubsequence l_1 = p_lregion;
        String l_2 = p_e.first;
        TUSubsequence l_3 = p_rb;
        TUSubsequence r_0 = p_lb;
        TUSubsequence r_1 = p_lregion;
        double r_2 = p_e.second;
        TUSubsequence r_3 = p_rb;
        String ret_left = bl_l(l_0, l_1, l_2, l_3);
        double ret_right = bl_r(r_0, r_1, r_2, r_3);
        std::pair<String, double>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_p_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_p_e);
        if (!arg_p_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_e_bt = arg_p_e;
          intrusive_ptr<Eval_List<Value> > arg_p_e_elist = evaluate(arg_p_e_bt);
          for (typename Eval_List<Value>::iterator arg_p_e_elem_itr = arg_p_e_elist->begin(); arg_p_e_elem_itr != arg_p_e_elist->end(); ++ arg_p_e_elem_itr) {
            std::pair<String, double>  arg_p_e_elem = *arg_p_e_elem_itr;
            std::pair<String, double>  ret = bl(arg_p_lb, arg_p_lregion, arg_p_e_elem, arg_p_rb);
            push_back( answer, ret);
          }
          erase( arg_p_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_p_e_bt_itr = arg_p_e_t->begin(); arg_p_e_bt_itr != arg_p_e_t->end(); ++ arg_p_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_e_bt = *arg_p_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_p_e_elist = evaluate(arg_p_e_bt);
          for (typename Eval_List<Value>::iterator arg_p_e_elem_itr = arg_p_e_elist->begin(); arg_p_e_elem_itr != arg_p_e_elist->end(); ++ arg_p_e_elem_itr) {
            std::pair<String, double>  arg_p_e_elem = *arg_p_e_elem_itr;
            std::pair<String, double>  ret = bl(arg_p_lb, arg_p_lregion, arg_p_e_elem, arg_p_rb);
            push_back( answer, ret);
          }
          erase( arg_p_e_elist);
        }
        erase( arg_p_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_br : Backtrace_Score<std::pair<Rope, std::pair<mfecovar, double> > , Value, pos_int> {
      TUSubsequence arg_p_lb;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_e;
      TUSubsequence arg_p_rregion;
      TUSubsequence arg_p_rb;

Backtrace_br(TUSubsequence arg_p_lb_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_e_, TUSubsequence arg_p_rregion_, TUSubsequence arg_p_rb_)
 : arg_p_lb(arg_p_lb_), arg_p_e(arg_p_e_), arg_p_rregion(arg_p_rregion_), arg_p_rb(arg_p_rb_)
{}

~Backtrace_br()
{
erase(arg_p_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      String br_l(const TUSubsequence & lb, const String & e, const TUSubsequence & rregion, const TUSubsequence & rb)
      {
#line 129 ""
        String res;
        append( res, '(');
        append( res, e);
        append( res, '.', size(rregion));
        append( res, ')');
        return res;
#line 1018 ""
      }


      double br_r(const TUSubsequence & lb, double x, const TUSubsequence & rr, const TUSubsequence & rb)
      {
#line 1778 ""
        return ((x * scale(((2 + rr.j) - rr.i))) * mk_pf(((br_energy(lb, rr) / float(rows(lb))) + covscore(lb, lb.i, rb.i))));
#line 1026 ""
      }


      std::pair<String, double>  br(const TUSubsequence & p_lb, const std::pair<String, double> & p_e, const TUSubsequence & p_rregion, const TUSubsequence & p_rb)
      {
        TUSubsequence l_0 = p_lb;
        String l_1 = p_e.first;
        TUSubsequence l_2 = p_rregion;
        TUSubsequence l_3 = p_rb;
        TUSubsequence r_0 = p_lb;
        double r_1 = p_e.second;
        TUSubsequence r_2 = p_rregion;
        TUSubsequence r_3 = p_rb;
        String ret_left = br_l(l_0, l_1, l_2, l_3);
        double ret_right = br_r(r_0, r_1, r_2, r_3);
        std::pair<String, double>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_p_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_p_e);
        if (!arg_p_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_e_bt = arg_p_e;
          intrusive_ptr<Eval_List<Value> > arg_p_e_elist = evaluate(arg_p_e_bt);
          for (typename Eval_List<Value>::iterator arg_p_e_elem_itr = arg_p_e_elist->begin(); arg_p_e_elem_itr != arg_p_e_elist->end(); ++ arg_p_e_elem_itr) {
            std::pair<String, double>  arg_p_e_elem = *arg_p_e_elem_itr;
            std::pair<String, double>  ret = br(arg_p_lb, arg_p_e_elem, arg_p_rregion, arg_p_rb);
            push_back( answer, ret);
          }
          erase( arg_p_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_p_e_bt_itr = arg_p_e_t->begin(); arg_p_e_bt_itr != arg_p_e_t->end(); ++ arg_p_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_e_bt = *arg_p_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_p_e_elist = evaluate(arg_p_e_bt);
          for (typename Eval_List<Value>::iterator arg_p_e_elem_itr = arg_p_e_elist->begin(); arg_p_e_elem_itr != arg_p_e_elist->end(); ++ arg_p_e_elem_itr) {
            std::pair<String, double>  arg_p_e_elem = *arg_p_e_elem_itr;
            std::pair<String, double>  ret = br(arg_p_lb, arg_p_e_elem, arg_p_rregion, arg_p_rb);
            push_back( answer, ret);
          }
          erase( arg_p_e_elist);
        }
        erase( arg_p_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_cadd : Backtrace_Score<std::pair<Rope, std::pair<mfecovar, double> > , Value, pos_int> {
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_le;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_re;

Backtrace_cadd(intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_le_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_re_)
 : arg_p_le(arg_p_le_), arg_p_re(arg_p_re_)
{}

~Backtrace_cadd()
{
erase(arg_p_le);
erase(arg_p_re);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      String cadd_l(const String & le, const String & re)
      {
#line 65 ""
        String res;
        append( res, le);
        append( res, re);
        return res;
#line 1104 ""
      }


      double cadd_r(double x, double y)
      {
#line 1743 ""
        return (x * y);
#line 1112 ""
      }


      std::pair<String, double>  cadd(const std::pair<String, double> & p_le, const std::pair<String, double> & p_re)
      {
        String l_0 = p_le.first;
        String l_1 = p_re.first;
        double r_0 = p_le.second;
        double r_1 = p_re.second;
        String ret_left = cadd_l(l_0, l_1);
        double ret_right = cadd_r(r_0, r_1);
        std::pair<String, double>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_p_le_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_p_le);
        if (!arg_p_le_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_le_bt = arg_p_le;
          intrusive_ptr<Backtrace_List<Value, pos_int> > arg_p_re_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_p_re);
          if (!arg_p_re_t) {
            intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_re_bt = arg_p_re;
            intrusive_ptr<Eval_List<Value> > arg_p_le_elist = evaluate(arg_p_le_bt);
            intrusive_ptr<Eval_List<Value> > arg_p_re_elist = evaluate(arg_p_re_bt);
            for (typename Eval_List<Value>::iterator arg_p_le_elem_itr = arg_p_le_elist->begin(); arg_p_le_elem_itr != arg_p_le_elist->end(); ++ arg_p_le_elem_itr) {
              std::pair<String, double>  arg_p_le_elem = *arg_p_le_elem_itr;
              for (typename Eval_List<Value>::iterator arg_p_re_elem_itr = arg_p_re_elist->begin(); arg_p_re_elem_itr != arg_p_re_elist->end(); ++ arg_p_re_elem_itr) {
                std::pair<String, double>  arg_p_re_elem = *arg_p_re_elem_itr;
                std::pair<String, double>  ret = cadd(arg_p_le_elem, arg_p_re_elem);
                push_back( answer, ret);
              }
            }
            erase( arg_p_le_elist);
            erase( arg_p_re_elist);
          } else 
          for (typename Backtrace_List<Value, pos_int>::iterator arg_p_re_bt_itr = arg_p_re_t->begin(); arg_p_re_bt_itr != arg_p_re_t->end(); ++ arg_p_re_bt_itr) {
            intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_re_bt = *arg_p_re_bt_itr;
            intrusive_ptr<Eval_List<Value> > arg_p_le_elist = evaluate(arg_p_le_bt);
            intrusive_ptr<Eval_List<Value> > arg_p_re_elist = evaluate(arg_p_re_bt);
            for (typename Eval_List<Value>::iterator arg_p_le_elem_itr = arg_p_le_elist->begin(); arg_p_le_elem_itr != arg_p_le_elist->end(); ++ arg_p_le_elem_itr) {
              std::pair<String, double>  arg_p_le_elem = *arg_p_le_elem_itr;
              for (typename Eval_List<Value>::iterator arg_p_re_elem_itr = arg_p_re_elist->begin(); arg_p_re_elem_itr != arg_p_re_elist->end(); ++ arg_p_re_elem_itr) {
                std::pair<String, double>  arg_p_re_elem = *arg_p_re_elem_itr;
                std::pair<String, double>  ret = cadd(arg_p_le_elem, arg_p_re_elem);
                push_back( answer, ret);
              }
            }
            erase( arg_p_le_elist);
            erase( arg_p_re_elist);
          }
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_p_le_bt_itr = arg_p_le_t->begin(); arg_p_le_bt_itr != arg_p_le_t->end(); ++ arg_p_le_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_le_bt = *arg_p_le_bt_itr;
          intrusive_ptr<Backtrace_List<Value, pos_int> > arg_p_re_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_p_re);
          if (!arg_p_re_t) {
            intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_re_bt = arg_p_re;
            intrusive_ptr<Eval_List<Value> > arg_p_le_elist = evaluate(arg_p_le_bt);
            intrusive_ptr<Eval_List<Value> > arg_p_re_elist = evaluate(arg_p_re_bt);
            for (typename Eval_List<Value>::iterator arg_p_le_elem_itr = arg_p_le_elist->begin(); arg_p_le_elem_itr != arg_p_le_elist->end(); ++ arg_p_le_elem_itr) {
              std::pair<String, double>  arg_p_le_elem = *arg_p_le_elem_itr;
              for (typename Eval_List<Value>::iterator arg_p_re_elem_itr = arg_p_re_elist->begin(); arg_p_re_elem_itr != arg_p_re_elist->end(); ++ arg_p_re_elem_itr) {
                std::pair<String, double>  arg_p_re_elem = *arg_p_re_elem_itr;
                std::pair<String, double>  ret = cadd(arg_p_le_elem, arg_p_re_elem);
                push_back( answer, ret);
              }
            }
            erase( arg_p_le_elist);
            erase( arg_p_re_elist);
          } else 
          for (typename Backtrace_List<Value, pos_int>::iterator arg_p_re_bt_itr = arg_p_re_t->begin(); arg_p_re_bt_itr != arg_p_re_t->end(); ++ arg_p_re_bt_itr) {
            intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_re_bt = *arg_p_re_bt_itr;
            intrusive_ptr<Eval_List<Value> > arg_p_le_elist = evaluate(arg_p_le_bt);
            intrusive_ptr<Eval_List<Value> > arg_p_re_elist = evaluate(arg_p_re_bt);
            for (typename Eval_List<Value>::iterator arg_p_le_elem_itr = arg_p_le_elist->begin(); arg_p_le_elem_itr != arg_p_le_elist->end(); ++ arg_p_le_elem_itr) {
              std::pair<String, double>  arg_p_le_elem = *arg_p_le_elem_itr;
              for (typename Eval_List<Value>::iterator arg_p_re_elem_itr = arg_p_re_elist->begin(); arg_p_re_elem_itr != arg_p_re_elist->end(); ++ arg_p_re_elem_itr) {
                std::pair<String, double>  arg_p_re_elem = *arg_p_re_elem_itr;
                std::pair<String, double>  ret = cadd(arg_p_le_elem, arg_p_re_elem);
                push_back( answer, ret);
              }
            }
            erase( arg_p_le_elist);
            erase( arg_p_re_elist);
          }
        }
        erase( arg_p_le);
        erase( arg_p_re);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_drem : Backtrace_Score<std::pair<Rope, std::pair<mfecovar, double> > , Value, pos_int> {
      TUSubsequence arg_p_lloc;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_e;
      TUSubsequence arg_p_rloc;

Backtrace_drem(TUSubsequence arg_p_lloc_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_e_, TUSubsequence arg_p_rloc_)
 : arg_p_lloc(arg_p_lloc_), arg_p_e(arg_p_e_), arg_p_rloc(arg_p_rloc_)
{}

~Backtrace_drem()
{
erase(arg_p_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      String drem_l(const TUSubsequence & lloc, const String & e, const TUSubsequence & rloc)
      {
#line 99 ""
        return e;
#line 1232 ""
      }


      double drem_r(const TUSubsequence & lb, double x, const TUSubsequence & rb)
      {
#line 1766 ""
        return (x * mk_pf((termau_energy(lb, rb) / float(rows(lb)))));
#line 1240 ""
      }


      std::pair<String, double>  drem(const TUSubsequence & p_lloc, const std::pair<String, double> & p_e, const TUSubsequence & p_rloc)
      {
        TUSubsequence l_0 = p_lloc;
        String l_1 = p_e.first;
        TUSubsequence l_2 = p_rloc;
        TUSubsequence r_0 = p_lloc;
        double r_1 = p_e.second;
        TUSubsequence r_2 = p_rloc;
        String ret_left = drem_l(l_0, l_1, l_2);
        double ret_right = drem_r(r_0, r_1, r_2);
        std::pair<String, double>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_p_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_p_e);
        if (!arg_p_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_e_bt = arg_p_e;
          intrusive_ptr<Eval_List<Value> > arg_p_e_elist = evaluate(arg_p_e_bt);
          for (typename Eval_List<Value>::iterator arg_p_e_elem_itr = arg_p_e_elist->begin(); arg_p_e_elem_itr != arg_p_e_elist->end(); ++ arg_p_e_elem_itr) {
            std::pair<String, double>  arg_p_e_elem = *arg_p_e_elem_itr;
            std::pair<String, double>  ret = drem(arg_p_lloc, arg_p_e_elem, arg_p_rloc);
            push_back( answer, ret);
          }
          erase( arg_p_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_p_e_bt_itr = arg_p_e_t->begin(); arg_p_e_bt_itr != arg_p_e_t->end(); ++ arg_p_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_e_bt = *arg_p_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_p_e_elist = evaluate(arg_p_e_bt);
          for (typename Eval_List<Value>::iterator arg_p_e_elem_itr = arg_p_e_elist->begin(); arg_p_e_elem_itr != arg_p_e_elist->end(); ++ arg_p_e_elem_itr) {
            std::pair<String, double>  arg_p_e_elem = *arg_p_e_elem_itr;
            std::pair<String, double>  ret = drem(arg_p_lloc, arg_p_e_elem, arg_p_rloc);
            push_back( answer, ret);
          }
          erase( arg_p_e_elist);
        }
        erase( arg_p_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_edl : Backtrace_Score<std::pair<Rope, std::pair<mfecovar, double> > , Value, pos_int> {
      TUSubsequence arg_p_lb;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_e;
      TUSubsequence arg_p_loc;

Backtrace_edl(TUSubsequence arg_p_lb_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_e_, TUSubsequence arg_p_loc_)
 : arg_p_lb(arg_p_lb_), arg_p_e(arg_p_e_), arg_p_loc(arg_p_loc_)
{}

~Backtrace_edl()
{
erase(arg_p_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      String edl_l(const TUSubsequence & lb, const String & e, const TUSubsequence & loc)
      {
#line 77 ""
        String res;
        append( res, '.');
        append( res, e);
        return res;
#line 1316 ""
      }


      double edl_r(const TUSubsequence & ldangle, double x, const TUSubsequence & rb)
      {
        TUSubsequence lb = ldangle;
        lb.i = (ldangle.i + 1);
        return ((x * scale(1)) * mk_pf(( ( (termau_energy(lb, rb) + dl_energy(lb, rb)) )  / float(rows(ldangle)))));
      }


      std::pair<String, double>  edl(const TUSubsequence & p_lb, const std::pair<String, double> & p_e, const TUSubsequence & p_loc)
      {
        TUSubsequence l_0 = p_lb;
        String l_1 = p_e.first;
        TUSubsequence l_2 = p_loc;
        TUSubsequence r_0 = p_lb;
        double r_1 = p_e.second;
        TUSubsequence r_2 = p_loc;
        String ret_left = edl_l(l_0, l_1, l_2);
        double ret_right = edl_r(r_0, r_1, r_2);
        std::pair<String, double>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_p_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_p_e);
        if (!arg_p_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_e_bt = arg_p_e;
          intrusive_ptr<Eval_List<Value> > arg_p_e_elist = evaluate(arg_p_e_bt);
          for (typename Eval_List<Value>::iterator arg_p_e_elem_itr = arg_p_e_elist->begin(); arg_p_e_elem_itr != arg_p_e_elist->end(); ++ arg_p_e_elem_itr) {
            std::pair<String, double>  arg_p_e_elem = *arg_p_e_elem_itr;
            std::pair<String, double>  ret = edl(arg_p_lb, arg_p_e_elem, arg_p_loc);
            push_back( answer, ret);
          }
          erase( arg_p_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_p_e_bt_itr = arg_p_e_t->begin(); arg_p_e_bt_itr != arg_p_e_t->end(); ++ arg_p_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_e_bt = *arg_p_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_p_e_elist = evaluate(arg_p_e_bt);
          for (typename Eval_List<Value>::iterator arg_p_e_elem_itr = arg_p_e_elist->begin(); arg_p_e_elem_itr != arg_p_e_elist->end(); ++ arg_p_e_elem_itr) {
            std::pair<String, double>  arg_p_e_elem = *arg_p_e_elem_itr;
            std::pair<String, double>  ret = edl(arg_p_lb, arg_p_e_elem, arg_p_loc);
            push_back( answer, ret);
          }
          erase( arg_p_e_elist);
        }
        erase( arg_p_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_edlr : Backtrace_Score<std::pair<Rope, std::pair<mfecovar, double> > , Value, pos_int> {
      TUSubsequence arg_p_lb;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_e;
      TUSubsequence arg_p_rb;

Backtrace_edlr(TUSubsequence arg_p_lb_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_e_, TUSubsequence arg_p_rb_)
 : arg_p_lb(arg_p_lb_), arg_p_e(arg_p_e_), arg_p_rb(arg_p_rb_)
{}

~Backtrace_edlr()
{
erase(arg_p_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      String edlr_l(const TUSubsequence & lb, const String & e, const TUSubsequence & rb)
      {
#line 91 ""
        String res;
        append( res, '.');
        append( res, e);
        append( res, '.');
        return res;
#line 1401 ""
      }


      double edlr_r(const TUSubsequence & ldangle, double x, const TUSubsequence & rdangle)
      {
        TUSubsequence lb = ldangle;
        lb.i = (ldangle.i + 1);
        TUSubsequence rb = rdangle;
        rb.j = (rdangle.j - 1);
        return ((x * scale(2)) * mk_pf(( ( (termau_energy(lb, rb) + ext_mismatch_energy(lb, rb)) )  / float(rows(ldangle)))));
      }


      std::pair<String, double>  edlr(const TUSubsequence & p_lb, const std::pair<String, double> & p_e, const TUSubsequence & p_rb)
      {
        TUSubsequence l_0 = p_lb;
        String l_1 = p_e.first;
        TUSubsequence l_2 = p_rb;
        TUSubsequence r_0 = p_lb;
        double r_1 = p_e.second;
        TUSubsequence r_2 = p_rb;
        String ret_left = edlr_l(l_0, l_1, l_2);
        double ret_right = edlr_r(r_0, r_1, r_2);
        std::pair<String, double>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_p_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_p_e);
        if (!arg_p_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_e_bt = arg_p_e;
          intrusive_ptr<Eval_List<Value> > arg_p_e_elist = evaluate(arg_p_e_bt);
          for (typename Eval_List<Value>::iterator arg_p_e_elem_itr = arg_p_e_elist->begin(); arg_p_e_elem_itr != arg_p_e_elist->end(); ++ arg_p_e_elem_itr) {
            std::pair<String, double>  arg_p_e_elem = *arg_p_e_elem_itr;
            std::pair<String, double>  ret = edlr(arg_p_lb, arg_p_e_elem, arg_p_rb);
            push_back( answer, ret);
          }
          erase( arg_p_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_p_e_bt_itr = arg_p_e_t->begin(); arg_p_e_bt_itr != arg_p_e_t->end(); ++ arg_p_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_e_bt = *arg_p_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_p_e_elist = evaluate(arg_p_e_bt);
          for (typename Eval_List<Value>::iterator arg_p_e_elem_itr = arg_p_e_elist->begin(); arg_p_e_elem_itr != arg_p_e_elist->end(); ++ arg_p_e_elem_itr) {
            std::pair<String, double>  arg_p_e_elem = *arg_p_e_elem_itr;
            std::pair<String, double>  ret = edlr(arg_p_lb, arg_p_e_elem, arg_p_rb);
            push_back( answer, ret);
          }
          erase( arg_p_e_elist);
        }
        erase( arg_p_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_edr : Backtrace_Score<std::pair<Rope, std::pair<mfecovar, double> > , Value, pos_int> {
      TUSubsequence arg_p_loc;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_e;
      TUSubsequence arg_p_rb;

Backtrace_edr(TUSubsequence arg_p_loc_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_e_, TUSubsequence arg_p_rb_)
 : arg_p_loc(arg_p_loc_), arg_p_e(arg_p_e_), arg_p_rb(arg_p_rb_)
{}

~Backtrace_edr()
{
erase(arg_p_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      String edr_l(const TUSubsequence & loc, const String & e, const TUSubsequence & rb)
      {
#line 84 ""
        String res;
        append( res, e);
        append( res, '.');
        return res;
#line 1487 ""
      }


      double edr_r(const TUSubsequence & lb, double x, const TUSubsequence & rdangle)
      {
        TUSubsequence rb = rdangle;
        rb.j = (rdangle.j - 1);
        return ((x * scale(1)) * mk_pf(( ( (termau_energy(lb, rb) + dr_energy(lb, rb)) )  / float(rows(lb)))));
      }


      std::pair<String, double>  edr(const TUSubsequence & p_loc, const std::pair<String, double> & p_e, const TUSubsequence & p_rb)
      {
        TUSubsequence l_0 = p_loc;
        String l_1 = p_e.first;
        TUSubsequence l_2 = p_rb;
        TUSubsequence r_0 = p_loc;
        double r_1 = p_e.second;
        TUSubsequence r_2 = p_rb;
        String ret_left = edr_l(l_0, l_1, l_2);
        double ret_right = edr_r(r_0, r_1, r_2);
        std::pair<String, double>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_p_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_p_e);
        if (!arg_p_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_e_bt = arg_p_e;
          intrusive_ptr<Eval_List<Value> > arg_p_e_elist = evaluate(arg_p_e_bt);
          for (typename Eval_List<Value>::iterator arg_p_e_elem_itr = arg_p_e_elist->begin(); arg_p_e_elem_itr != arg_p_e_elist->end(); ++ arg_p_e_elem_itr) {
            std::pair<String, double>  arg_p_e_elem = *arg_p_e_elem_itr;
            std::pair<String, double>  ret = edr(arg_p_loc, arg_p_e_elem, arg_p_rb);
            push_back( answer, ret);
          }
          erase( arg_p_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_p_e_bt_itr = arg_p_e_t->begin(); arg_p_e_bt_itr != arg_p_e_t->end(); ++ arg_p_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_e_bt = *arg_p_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_p_e_elist = evaluate(arg_p_e_bt);
          for (typename Eval_List<Value>::iterator arg_p_e_elem_itr = arg_p_e_elist->begin(); arg_p_e_elem_itr != arg_p_e_elist->end(); ++ arg_p_e_elem_itr) {
            std::pair<String, double>  arg_p_e_elem = *arg_p_e_elem_itr;
            std::pair<String, double>  ret = edr(arg_p_loc, arg_p_e_elem, arg_p_rb);
            push_back( answer, ret);
          }
          erase( arg_p_e_elist);
        }
        erase( arg_p_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_hl : Backtrace_Score<std::pair<Rope, std::pair<mfecovar, double> > , Value, pos_int> {
      TUSubsequence arg_p_lb;
      TUSubsequence arg_p_region;
      TUSubsequence arg_p_rb;

Backtrace_hl(TUSubsequence arg_p_lb_, TUSubsequence arg_p_region_, TUSubsequence arg_p_rb_)
 : arg_p_lb(arg_p_lb_), arg_p_region(arg_p_region_), arg_p_rb(arg_p_rb_)
{}

~Backtrace_hl()
{
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      String hl_l(const TUSubsequence & lb, const TUSubsequence & region, const TUSubsequence & rb)
      {
#line 111 ""
        String res;
        append( res, '(');
        append( res, '.', size(region));
        append( res, ')');
        return res;
#line 1571 ""
      }


      double hl_r(const TUSubsequence & lb, const TUSubsequence & r, const TUSubsequence & rb)
      {
#line 1772 ""
        return (scale(((2 + r.j) - r.i)) * mk_pf((int((hl_energy(r) / float(rows(r)))) + covscore(lb, lb.i, rb.i))));
#line 1579 ""
      }


      std::pair<String, double>  hl(const TUSubsequence & p_lb, const TUSubsequence & p_region, const TUSubsequence & p_rb)
      {
        TUSubsequence l_0 = p_lb;
        TUSubsequence l_1 = p_region;
        TUSubsequence l_2 = p_rb;
        TUSubsequence r_0 = p_lb;
        TUSubsequence r_1 = p_region;
        TUSubsequence r_2 = p_rb;
        String ret_left = hl_l(l_0, l_1, l_2);
        double ret_right = hl_r(r_0, r_1, r_2);
        std::pair<String, double>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        std::pair<String, double>  ret = hl(arg_p_lb, arg_p_region, arg_p_rb);
        push_back( answer, ret);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_il : Backtrace_Score<std::pair<Rope, std::pair<mfecovar, double> > , Value, pos_int> {
      TUSubsequence arg_p_lb;
      TUSubsequence arg_p_lregion;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_e;
      TUSubsequence arg_p_rregion;
      TUSubsequence arg_p_rb;

Backtrace_il(TUSubsequence arg_p_lb_, TUSubsequence arg_p_lregion_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_e_, TUSubsequence arg_p_rregion_, TUSubsequence arg_p_rb_)
 : arg_p_lb(arg_p_lb_), arg_p_lregion(arg_p_lregion_), arg_p_e(arg_p_e_), arg_p_rregion(arg_p_rregion_), arg_p_rb(arg_p_rb_)
{}

~Backtrace_il()
{
erase(arg_p_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      String il_l(const TUSubsequence & lb, const TUSubsequence & lregion, const String & e, const TUSubsequence & rregion, const TUSubsequence & rb)
      {
#line 138 ""
        String res;
        append( res, '(');
        append( res, '.', size(lregion));
        append( res, e);
        append( res, '.', size(rregion));
        append( res, ')');
        return res;
#line 1640 ""
      }


      double il_r(const TUSubsequence & lb, const TUSubsequence & lr, double x, const TUSubsequence & rr, const TUSubsequence & rb)
      {
#line 1781 ""
        return ((x * scale(((((2 + lr.j) - lr.i) + rr.j) - rr.i))) * mk_pf(((il_energy(lr, rr) / float(rows(lr))) + covscore(lb, lb.i, rb.i))));
#line 1648 ""
      }


      std::pair<String, double>  il(const TUSubsequence & p_lb, const TUSubsequence & p_lregion, const std::pair<String, double> & p_e, const TUSubsequence & p_rregion, const TUSubsequence & p_rb)
      {
        TUSubsequence l_0 = p_lb;
        TUSubsequence l_1 = p_lregion;
        String l_2 = p_e.first;
        TUSubsequence l_3 = p_rregion;
        TUSubsequence l_4 = p_rb;
        TUSubsequence r_0 = p_lb;
        TUSubsequence r_1 = p_lregion;
        double r_2 = p_e.second;
        TUSubsequence r_3 = p_rregion;
        TUSubsequence r_4 = p_rb;
        String ret_left = il_l(l_0, l_1, l_2, l_3, l_4);
        double ret_right = il_r(r_0, r_1, r_2, r_3, r_4);
        std::pair<String, double>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_p_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_p_e);
        if (!arg_p_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_e_bt = arg_p_e;
          intrusive_ptr<Eval_List<Value> > arg_p_e_elist = evaluate(arg_p_e_bt);
          for (typename Eval_List<Value>::iterator arg_p_e_elem_itr = arg_p_e_elist->begin(); arg_p_e_elem_itr != arg_p_e_elist->end(); ++ arg_p_e_elem_itr) {
            std::pair<String, double>  arg_p_e_elem = *arg_p_e_elem_itr;
            std::pair<String, double>  ret = il(arg_p_lb, arg_p_lregion, arg_p_e_elem, arg_p_rregion, arg_p_rb);
            push_back( answer, ret);
          }
          erase( arg_p_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_p_e_bt_itr = arg_p_e_t->begin(); arg_p_e_bt_itr != arg_p_e_t->end(); ++ arg_p_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_e_bt = *arg_p_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_p_e_elist = evaluate(arg_p_e_bt);
          for (typename Eval_List<Value>::iterator arg_p_e_elem_itr = arg_p_e_elist->begin(); arg_p_e_elem_itr != arg_p_e_elist->end(); ++ arg_p_e_elem_itr) {
            std::pair<String, double>  arg_p_e_elem = *arg_p_e_elem_itr;
            std::pair<String, double>  ret = il(arg_p_lb, arg_p_lregion, arg_p_e_elem, arg_p_rregion, arg_p_rb);
            push_back( answer, ret);
          }
          erase( arg_p_e_elist);
        }
        erase( arg_p_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_incl : Backtrace_Score<std::pair<Rope, std::pair<mfecovar, double> > , Value, pos_int> {
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_e;

Backtrace_incl(intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_e_)
 : arg_p_e(arg_p_e_)
{}

~Backtrace_incl()
{
erase(arg_p_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      String incl_l(const String & e)
      {
#line 191 ""
        return e;
#line 1723 ""
      }


      double incl_r(double x)
      {
#line 1797 ""
        return (x * mk_pf(ul_energy()));
#line 1731 ""
      }


      std::pair<String, double>  incl(const std::pair<String, double> & p_e)
      {
        String l_0 = p_e.first;
        double r_0 = p_e.second;
        String ret_left = incl_l(l_0);
        double ret_right = incl_r(r_0);
        std::pair<String, double>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_p_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_p_e);
        if (!arg_p_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_e_bt = arg_p_e;
          intrusive_ptr<Eval_List<Value> > arg_p_e_elist = evaluate(arg_p_e_bt);
          for (typename Eval_List<Value>::iterator arg_p_e_elem_itr = arg_p_e_elist->begin(); arg_p_e_elem_itr != arg_p_e_elist->end(); ++ arg_p_e_elem_itr) {
            std::pair<String, double>  arg_p_e_elem = *arg_p_e_elem_itr;
            std::pair<String, double>  ret = incl(arg_p_e_elem);
            push_back( answer, ret);
          }
          erase( arg_p_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_p_e_bt_itr = arg_p_e_t->begin(); arg_p_e_bt_itr != arg_p_e_t->end(); ++ arg_p_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_e_bt = *arg_p_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_p_e_elist = evaluate(arg_p_e_bt);
          for (typename Eval_List<Value>::iterator arg_p_e_elem_itr = arg_p_e_elist->begin(); arg_p_e_elem_itr != arg_p_e_elist->end(); ++ arg_p_e_elem_itr) {
            std::pair<String, double>  arg_p_e_elem = *arg_p_e_elem_itr;
            std::pair<String, double>  ret = incl(arg_p_e_elem);
            push_back( answer, ret);
          }
          erase( arg_p_e_elist);
        }
        erase( arg_p_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_ml : Backtrace_Score<std::pair<Rope, std::pair<mfecovar, double> > , Value, pos_int> {
      TUSubsequence arg_p_lb;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_e;
      TUSubsequence arg_p_rb;

Backtrace_ml(TUSubsequence arg_p_lb_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_e_, TUSubsequence arg_p_rb_)
 : arg_p_lb(arg_p_lb_), arg_p_e(arg_p_e_), arg_p_rb(arg_p_rb_)
{}

~Backtrace_ml()
{
erase(arg_p_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      String ml_l(const TUSubsequence & lb, const String & e, const TUSubsequence & rb)
      {
#line 148 ""
        String res;
        append( res, '(');
        append( res, e);
        append( res, ')');
        return res;
#line 1804 ""
      }


      double ml_r(const TUSubsequence & lb, double x, const TUSubsequence & rb)
      {
#line 1794 ""
        return ((x * scale(2)) * mk_pf((((ml_energy() + ul_energy()) +  ( (termau_energy(lb, rb) / float(rows(lb))) ) ) + covscore(lb, lb.i, rb.i))));
#line 1812 ""
      }


      std::pair<String, double>  ml(const TUSubsequence & p_lb, const std::pair<String, double> & p_e, const TUSubsequence & p_rb)
      {
        TUSubsequence l_0 = p_lb;
        String l_1 = p_e.first;
        TUSubsequence l_2 = p_rb;
        TUSubsequence r_0 = p_lb;
        double r_1 = p_e.second;
        TUSubsequence r_2 = p_rb;
        String ret_left = ml_l(l_0, l_1, l_2);
        double ret_right = ml_r(r_0, r_1, r_2);
        std::pair<String, double>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_p_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_p_e);
        if (!arg_p_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_e_bt = arg_p_e;
          intrusive_ptr<Eval_List<Value> > arg_p_e_elist = evaluate(arg_p_e_bt);
          for (typename Eval_List<Value>::iterator arg_p_e_elem_itr = arg_p_e_elist->begin(); arg_p_e_elem_itr != arg_p_e_elist->end(); ++ arg_p_e_elem_itr) {
            std::pair<String, double>  arg_p_e_elem = *arg_p_e_elem_itr;
            std::pair<String, double>  ret = ml(arg_p_lb, arg_p_e_elem, arg_p_rb);
            push_back( answer, ret);
          }
          erase( arg_p_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_p_e_bt_itr = arg_p_e_t->begin(); arg_p_e_bt_itr != arg_p_e_t->end(); ++ arg_p_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_e_bt = *arg_p_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_p_e_elist = evaluate(arg_p_e_bt);
          for (typename Eval_List<Value>::iterator arg_p_e_elem_itr = arg_p_e_elist->begin(); arg_p_e_elem_itr != arg_p_e_elist->end(); ++ arg_p_e_elem_itr) {
            std::pair<String, double>  arg_p_e_elem = *arg_p_e_elem_itr;
            std::pair<String, double>  ret = ml(arg_p_lb, arg_p_e_elem, arg_p_rb);
            push_back( answer, ret);
          }
          erase( arg_p_e_elist);
        }
        erase( arg_p_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_mldl : Backtrace_Score<std::pair<Rope, std::pair<mfecovar, double> > , Value, pos_int> {
      TUSubsequence arg_p_lb;
      TUSubsequence arg_p_dl;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_e;
      TUSubsequence arg_p_rb;

Backtrace_mldl(TUSubsequence arg_p_lb_, TUSubsequence arg_p_dl_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_e_, TUSubsequence arg_p_rb_)
 : arg_p_lb(arg_p_lb_), arg_p_dl(arg_p_dl_), arg_p_e(arg_p_e_), arg_p_rb(arg_p_rb_)
{}

~Backtrace_mldl()
{
erase(arg_p_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      String mldl_l(const TUSubsequence & lb, const TUSubsequence & dl, const String & e, const TUSubsequence & rb)
      {
#line 175 ""
        String res;
        append( res, '(');
        append( res, '.');
        append( res, e);
        append( res, ')');
        return res;
#line 1891 ""
      }


      double mldl_r(const TUSubsequence & lb, const TUSubsequence & dl, double x, const TUSubsequence & rb)
      {
#line 1785 ""
        return ((x * scale(3)) * mk_pf((((ml_energy() + ul_energy()) +  ( ( ( (termau_energy(lb, rb) + dli_energy(lb, rb)) )  / float(rows(lb))) ) ) + covscore(lb, lb.i, rb.i))));
#line 1899 ""
      }


      std::pair<String, double>  mldl(const TUSubsequence & p_lb, const TUSubsequence & p_dl, const std::pair<String, double> & p_e, const TUSubsequence & p_rb)
      {
        TUSubsequence l_0 = p_lb;
        TUSubsequence l_1 = p_dl;
        String l_2 = p_e.first;
        TUSubsequence l_3 = p_rb;
        TUSubsequence r_0 = p_lb;
        TUSubsequence r_1 = p_dl;
        double r_2 = p_e.second;
        TUSubsequence r_3 = p_rb;
        String ret_left = mldl_l(l_0, l_1, l_2, l_3);
        double ret_right = mldl_r(r_0, r_1, r_2, r_3);
        std::pair<String, double>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_p_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_p_e);
        if (!arg_p_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_e_bt = arg_p_e;
          intrusive_ptr<Eval_List<Value> > arg_p_e_elist = evaluate(arg_p_e_bt);
          for (typename Eval_List<Value>::iterator arg_p_e_elem_itr = arg_p_e_elist->begin(); arg_p_e_elem_itr != arg_p_e_elist->end(); ++ arg_p_e_elem_itr) {
            std::pair<String, double>  arg_p_e_elem = *arg_p_e_elem_itr;
            std::pair<String, double>  ret = mldl(arg_p_lb, arg_p_dl, arg_p_e_elem, arg_p_rb);
            push_back( answer, ret);
          }
          erase( arg_p_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_p_e_bt_itr = arg_p_e_t->begin(); arg_p_e_bt_itr != arg_p_e_t->end(); ++ arg_p_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_e_bt = *arg_p_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_p_e_elist = evaluate(arg_p_e_bt);
          for (typename Eval_List<Value>::iterator arg_p_e_elem_itr = arg_p_e_elist->begin(); arg_p_e_elem_itr != arg_p_e_elist->end(); ++ arg_p_e_elem_itr) {
            std::pair<String, double>  arg_p_e_elem = *arg_p_e_elem_itr;
            std::pair<String, double>  ret = mldl(arg_p_lb, arg_p_dl, arg_p_e_elem, arg_p_rb);
            push_back( answer, ret);
          }
          erase( arg_p_e_elist);
        }
        erase( arg_p_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_mldlr : Backtrace_Score<std::pair<Rope, std::pair<mfecovar, double> > , Value, pos_int> {
      TUSubsequence arg_p_lb;
      TUSubsequence arg_p_dl;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_e;
      TUSubsequence arg_p_dr;
      TUSubsequence arg_p_rb;

Backtrace_mldlr(TUSubsequence arg_p_lb_, TUSubsequence arg_p_dl_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_e_, TUSubsequence arg_p_dr_, TUSubsequence arg_p_rb_)
 : arg_p_lb(arg_p_lb_), arg_p_dl(arg_p_dl_), arg_p_e(arg_p_e_), arg_p_dr(arg_p_dr_), arg_p_rb(arg_p_rb_)
{}

~Backtrace_mldlr()
{
erase(arg_p_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      String mldlr_l(const TUSubsequence & lb, const TUSubsequence & dl, const String & e, const TUSubsequence & dr, const TUSubsequence & rb)
      {
#line 165 ""
        String res;
        append( res, '(');
        append( res, '.');
        append( res, e);
        append( res, '.');
        append( res, ')');
        return res;
#line 1982 ""
      }


      double mldlr_r(const TUSubsequence & lb, const TUSubsequence & dl, double x, const TUSubsequence & dr, const TUSubsequence & rb)
      {
#line 1791 ""
        return ((x * scale(4)) * mk_pf((((ml_energy() + ul_energy()) +  ( ( ( (termau_energy(lb, rb) + ml_mismatch_energy(lb, rb)) )  / float(rows(lb))) ) ) + covscore(lb, lb.i, rb.i))));
#line 1990 ""
      }


      std::pair<String, double>  mldlr(const TUSubsequence & p_lb, const TUSubsequence & p_dl, const std::pair<String, double> & p_e, const TUSubsequence & p_dr, const TUSubsequence & p_rb)
      {
        TUSubsequence l_0 = p_lb;
        TUSubsequence l_1 = p_dl;
        String l_2 = p_e.first;
        TUSubsequence l_3 = p_dr;
        TUSubsequence l_4 = p_rb;
        TUSubsequence r_0 = p_lb;
        TUSubsequence r_1 = p_dl;
        double r_2 = p_e.second;
        TUSubsequence r_3 = p_dr;
        TUSubsequence r_4 = p_rb;
        String ret_left = mldlr_l(l_0, l_1, l_2, l_3, l_4);
        double ret_right = mldlr_r(r_0, r_1, r_2, r_3, r_4);
        std::pair<String, double>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_p_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_p_e);
        if (!arg_p_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_e_bt = arg_p_e;
          intrusive_ptr<Eval_List<Value> > arg_p_e_elist = evaluate(arg_p_e_bt);
          for (typename Eval_List<Value>::iterator arg_p_e_elem_itr = arg_p_e_elist->begin(); arg_p_e_elem_itr != arg_p_e_elist->end(); ++ arg_p_e_elem_itr) {
            std::pair<String, double>  arg_p_e_elem = *arg_p_e_elem_itr;
            std::pair<String, double>  ret = mldlr(arg_p_lb, arg_p_dl, arg_p_e_elem, arg_p_dr, arg_p_rb);
            push_back( answer, ret);
          }
          erase( arg_p_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_p_e_bt_itr = arg_p_e_t->begin(); arg_p_e_bt_itr != arg_p_e_t->end(); ++ arg_p_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_e_bt = *arg_p_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_p_e_elist = evaluate(arg_p_e_bt);
          for (typename Eval_List<Value>::iterator arg_p_e_elem_itr = arg_p_e_elist->begin(); arg_p_e_elem_itr != arg_p_e_elist->end(); ++ arg_p_e_elem_itr) {
            std::pair<String, double>  arg_p_e_elem = *arg_p_e_elem_itr;
            std::pair<String, double>  ret = mldlr(arg_p_lb, arg_p_dl, arg_p_e_elem, arg_p_dr, arg_p_rb);
            push_back( answer, ret);
          }
          erase( arg_p_e_elist);
        }
        erase( arg_p_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_mldr : Backtrace_Score<std::pair<Rope, std::pair<mfecovar, double> > , Value, pos_int> {
      TUSubsequence arg_p_lb;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_e;
      TUSubsequence arg_p_dr;
      TUSubsequence arg_p_rb;

Backtrace_mldr(TUSubsequence arg_p_lb_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_e_, TUSubsequence arg_p_dr_, TUSubsequence arg_p_rb_)
 : arg_p_lb(arg_p_lb_), arg_p_e(arg_p_e_), arg_p_dr(arg_p_dr_), arg_p_rb(arg_p_rb_)
{}

~Backtrace_mldr()
{
erase(arg_p_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      String mldr_l(const TUSubsequence & lb, const String & e, const TUSubsequence & dr, const TUSubsequence & rb)
      {
#line 156 ""
        String res;
        append( res, '(');
        append( res, e);
        append( res, '.');
        append( res, ')');
        return res;
#line 2073 ""
      }


      double mldr_r(const TUSubsequence & lb, double x, const TUSubsequence & dr, const TUSubsequence & rb)
      {
#line 1788 ""
        return ((x * scale(3)) * mk_pf((((ml_energy() + ul_energy()) +  ( ( ( (termau_energy(lb, rb) + dri_energy(lb, rb)) )  / float(rows(lb))) ) ) + covscore(lb, lb.i, rb.i))));
#line 2081 ""
      }


      std::pair<String, double>  mldr(const TUSubsequence & p_lb, const std::pair<String, double> & p_e, const TUSubsequence & p_dr, const TUSubsequence & p_rb)
      {
        TUSubsequence l_0 = p_lb;
        String l_1 = p_e.first;
        TUSubsequence l_2 = p_dr;
        TUSubsequence l_3 = p_rb;
        TUSubsequence r_0 = p_lb;
        double r_1 = p_e.second;
        TUSubsequence r_2 = p_dr;
        TUSubsequence r_3 = p_rb;
        String ret_left = mldr_l(l_0, l_1, l_2, l_3);
        double ret_right = mldr_r(r_0, r_1, r_2, r_3);
        std::pair<String, double>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_p_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_p_e);
        if (!arg_p_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_e_bt = arg_p_e;
          intrusive_ptr<Eval_List<Value> > arg_p_e_elist = evaluate(arg_p_e_bt);
          for (typename Eval_List<Value>::iterator arg_p_e_elem_itr = arg_p_e_elist->begin(); arg_p_e_elem_itr != arg_p_e_elist->end(); ++ arg_p_e_elem_itr) {
            std::pair<String, double>  arg_p_e_elem = *arg_p_e_elem_itr;
            std::pair<String, double>  ret = mldr(arg_p_lb, arg_p_e_elem, arg_p_dr, arg_p_rb);
            push_back( answer, ret);
          }
          erase( arg_p_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_p_e_bt_itr = arg_p_e_t->begin(); arg_p_e_bt_itr != arg_p_e_t->end(); ++ arg_p_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_e_bt = *arg_p_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_p_e_elist = evaluate(arg_p_e_bt);
          for (typename Eval_List<Value>::iterator arg_p_e_elem_itr = arg_p_e_elist->begin(); arg_p_e_elem_itr != arg_p_e_elist->end(); ++ arg_p_e_elem_itr) {
            std::pair<String, double>  arg_p_e_elem = *arg_p_e_elem_itr;
            std::pair<String, double>  ret = mldr(arg_p_lb, arg_p_e_elem, arg_p_dr, arg_p_rb);
            push_back( answer, ret);
          }
          erase( arg_p_e_elist);
        }
        erase( arg_p_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_nil : Backtrace_Score<std::pair<Rope, std::pair<mfecovar, double> > , Value, pos_int> {
      TUSubsequence arg_p_loc;

Backtrace_nil(TUSubsequence arg_p_loc_)
 : arg_p_loc(arg_p_loc_)
{}

~Backtrace_nil()
{
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      String nil_l(const TUSubsequence & loc)
      {
#line 72 ""
        String r;
        return r;
#line 2154 ""
      }


      double nil_r(const TUSubsequence & n)
      {
#line 1803 ""
        return 1.000000e+00;
#line 2162 ""
      }


      std::pair<String, double>  nil(const TUSubsequence & p_loc)
      {
        TUSubsequence l_0 = p_loc;
        TUSubsequence r_0 = p_loc;
        String ret_left = nil_l(l_0);
        double ret_right = nil_r(r_0);
        std::pair<String, double>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        std::pair<String, double>  ret = nil(arg_p_loc);
        push_back( answer, ret);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_sadd : Backtrace_Score<std::pair<Rope, std::pair<mfecovar, double> > , Value, pos_int> {
      TUSubsequence arg_p_lb;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_e;

Backtrace_sadd(TUSubsequence arg_p_lb_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_e_)
 : arg_p_lb(arg_p_lb_), arg_p_e(arg_p_e_)
{}

~Backtrace_sadd()
{
erase(arg_p_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      String sadd_l(const TUSubsequence & lb, const String & e)
      {
#line 58 ""
        String res;
        append( res, '.');
        append( res, e);
        return res;
#line 2213 ""
      }


      double sadd_r(const TUSubsequence & lb, double x)
      {
        double sbase_sum = 0;
        for(        int k = 0; (k < int(rows(lb)));         k = (k + 1))
        {
          if ((column(seq_char(lb, lb.i), k) != GAP_BASE))
            {
              sbase_sum = (sbase_sum + sbase_energy());
            }

        }

        return ((x * scale(1)) * mk_pf((sbase_sum / float(rows(lb)))));
      }


      std::pair<String, double>  sadd(const TUSubsequence & p_lb, const std::pair<String, double> & p_e)
      {
        TUSubsequence l_0 = p_lb;
        String l_1 = p_e.first;
        TUSubsequence r_0 = p_lb;
        double r_1 = p_e.second;
        String ret_left = sadd_l(l_0, l_1);
        double ret_right = sadd_r(r_0, r_1);
        std::pair<String, double>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_p_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_p_e);
        if (!arg_p_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_e_bt = arg_p_e;
          intrusive_ptr<Eval_List<Value> > arg_p_e_elist = evaluate(arg_p_e_bt);
          for (typename Eval_List<Value>::iterator arg_p_e_elem_itr = arg_p_e_elist->begin(); arg_p_e_elem_itr != arg_p_e_elist->end(); ++ arg_p_e_elem_itr) {
            std::pair<String, double>  arg_p_e_elem = *arg_p_e_elem_itr;
            std::pair<String, double>  ret = sadd(arg_p_lb, arg_p_e_elem);
            push_back( answer, ret);
          }
          erase( arg_p_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_p_e_bt_itr = arg_p_e_t->begin(); arg_p_e_bt_itr != arg_p_e_t->end(); ++ arg_p_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_e_bt = *arg_p_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_p_e_elist = evaluate(arg_p_e_bt);
          for (typename Eval_List<Value>::iterator arg_p_e_elem_itr = arg_p_e_elist->begin(); arg_p_e_elem_itr != arg_p_e_elist->end(); ++ arg_p_e_elem_itr) {
            std::pair<String, double>  arg_p_e_elem = *arg_p_e_elem_itr;
            std::pair<String, double>  ret = sadd(arg_p_lb, arg_p_e_elem);
            push_back( answer, ret);
          }
          erase( arg_p_e_elist);
        }
        erase( arg_p_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_sr : Backtrace_Score<std::pair<Rope, std::pair<mfecovar, double> > , Value, pos_int> {
      TUSubsequence arg_p_lb;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_e;
      TUSubsequence arg_p_rb;

Backtrace_sr(TUSubsequence arg_p_lb_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_e_, TUSubsequence arg_p_rb_)
 : arg_p_lb(arg_p_lb_), arg_p_e(arg_p_e_), arg_p_rb(arg_p_rb_)
{}

~Backtrace_sr()
{
erase(arg_p_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      String sr_l(const TUSubsequence & lb, const String & e, const TUSubsequence & rb)
      {
#line 103 ""
        String res;
        append( res, '(');
        append( res, e);
        append( res, ')');
        return res;
#line 2304 ""
      }


      double sr_r(const TUSubsequence & lb, double x, const TUSubsequence & rb)
      {
#line 1769 ""
        return ((x * scale(2)) * mk_pf((int((sr_energy(lb, rb) / float(rows(lb)))) + covscore(lb, lb.i, rb.i))));
#line 2312 ""
      }


      std::pair<String, double>  sr(const TUSubsequence & p_lb, const std::pair<String, double> & p_e, const TUSubsequence & p_rb)
      {
        TUSubsequence l_0 = p_lb;
        String l_1 = p_e.first;
        TUSubsequence l_2 = p_rb;
        TUSubsequence r_0 = p_lb;
        double r_1 = p_e.second;
        TUSubsequence r_2 = p_rb;
        String ret_left = sr_l(l_0, l_1, l_2);
        double ret_right = sr_r(r_0, r_1, r_2);
        std::pair<String, double>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_p_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_p_e);
        if (!arg_p_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_e_bt = arg_p_e;
          intrusive_ptr<Eval_List<Value> > arg_p_e_elist = evaluate(arg_p_e_bt);
          for (typename Eval_List<Value>::iterator arg_p_e_elem_itr = arg_p_e_elist->begin(); arg_p_e_elem_itr != arg_p_e_elist->end(); ++ arg_p_e_elem_itr) {
            std::pair<String, double>  arg_p_e_elem = *arg_p_e_elem_itr;
            std::pair<String, double>  ret = sr(arg_p_lb, arg_p_e_elem, arg_p_rb);
            push_back( answer, ret);
          }
          erase( arg_p_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_p_e_bt_itr = arg_p_e_t->begin(); arg_p_e_bt_itr != arg_p_e_t->end(); ++ arg_p_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_e_bt = *arg_p_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_p_e_elist = evaluate(arg_p_e_bt);
          for (typename Eval_List<Value>::iterator arg_p_e_elem_itr = arg_p_e_elist->begin(); arg_p_e_elem_itr != arg_p_e_elist->end(); ++ arg_p_e_elem_itr) {
            std::pair<String, double>  arg_p_e_elem = *arg_p_e_elem_itr;
            std::pair<String, double>  ret = sr(arg_p_lb, arg_p_e_elem, arg_p_rb);
            push_back( answer, ret);
          }
          erase( arg_p_e_elist);
        }
        erase( arg_p_e);
        return answer;
      }


};
template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_struct_Back : public Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfecovar, double> > , Klass, Value, pos_int>
{
pos_int t_0_i;
Backtrace_nt_struct_Back(Klass *klass_, pos_int t_0_i_)
  : Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfecovar, double> > , Klass, Value, pos_int>(klass_), t_0_i(t_0_i_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_struct(t_0_i));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_struct_Front : public Backtrace_Score<std::pair<Rope, std::pair<mfecovar, double> >  , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_struct_Back<probs_h_microstate, Value, pos_int> > back;

Backtrace_nt_struct_Front(intrusive_ptr<Backtrace_nt_struct_Back<probs_h_microstate, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfecovar, double> > , probs_h_microstate, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_dangle_Back : public Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfecovar, double> > , Klass, Value, pos_int>
{
pos_int t_0_i;
pos_int t_0_j;
Backtrace_nt_dangle_Back(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_)
  : Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfecovar, double> > , Klass, Value, pos_int>(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_dangle(t_0_i, t_0_j));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_dangle_Front : public Backtrace_Score<std::pair<Rope, std::pair<mfecovar, double> >  , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_dangle_Back<probs_h_microstate, Value, pos_int> > back;

Backtrace_nt_dangle_Front(intrusive_ptr<Backtrace_nt_dangle_Back<probs_h_microstate, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfecovar, double> > , probs_h_microstate, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_strong_Back : public Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfecovar, double> > , Klass, Value, pos_int>
{
pos_int t_0_i;
pos_int t_0_j;
Backtrace_nt_strong_Back(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_)
  : Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfecovar, double> > , Klass, Value, pos_int>(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_strong(t_0_i, t_0_j));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_strong_Front : public Backtrace_Score<std::pair<Rope, std::pair<mfecovar, double> >  , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_strong_Back<probs_h_microstate, Value, pos_int> > back;

Backtrace_nt_strong_Front(intrusive_ptr<Backtrace_nt_strong_Back<probs_h_microstate, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfecovar, double> > , probs_h_microstate, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_weak_Back : public Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfecovar, double> > , Klass, Value, pos_int>
{
pos_int t_0_i;
pos_int t_0_j;
Backtrace_nt_weak_Back(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_)
  : Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfecovar, double> > , Klass, Value, pos_int>(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_weak(t_0_i, t_0_j));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_weak_Front : public Backtrace_Score<std::pair<Rope, std::pair<mfecovar, double> >  , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_weak_Back<probs_h_microstate, Value, pos_int> > back;

Backtrace_nt_weak_Front(intrusive_ptr<Backtrace_nt_weak_Back<probs_h_microstate, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfecovar, double> > , probs_h_microstate, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_stack_Back : public Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfecovar, double> > , Klass, Value, pos_int>
{
pos_int t_0_i;
pos_int t_0_j;
Backtrace_nt_stack_Back(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_)
  : Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfecovar, double> > , Klass, Value, pos_int>(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_stack(t_0_i, t_0_j));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_stack_Front : public Backtrace_Score<std::pair<Rope, std::pair<mfecovar, double> >  , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_stack_Back<probs_h_microstate, Value, pos_int> > back;

Backtrace_nt_stack_Front(intrusive_ptr<Backtrace_nt_stack_Back<probs_h_microstate, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfecovar, double> > , probs_h_microstate, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_hairpin_Back : public Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfecovar, double> > , Klass, Value, pos_int>
{
pos_int t_0_i;
pos_int t_0_j;
Backtrace_nt_hairpin_Back(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_)
  : Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfecovar, double> > , Klass, Value, pos_int>(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_hairpin(t_0_i, t_0_j));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_hairpin_Front : public Backtrace_Score<std::pair<Rope, std::pair<mfecovar, double> >  , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_hairpin_Back<probs_h_microstate, Value, pos_int> > back;

Backtrace_nt_hairpin_Front(intrusive_ptr<Backtrace_nt_hairpin_Back<probs_h_microstate, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfecovar, double> > , probs_h_microstate, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_leftB_Back : public Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfecovar, double> > , Klass, Value, pos_int>
{
pos_int t_0_i;
pos_int t_0_j;
Backtrace_nt_leftB_Back(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_)
  : Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfecovar, double> > , Klass, Value, pos_int>(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_leftB(t_0_i, t_0_j));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_leftB_Front : public Backtrace_Score<std::pair<Rope, std::pair<mfecovar, double> >  , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_leftB_Back<probs_h_microstate, Value, pos_int> > back;

Backtrace_nt_leftB_Front(intrusive_ptr<Backtrace_nt_leftB_Back<probs_h_microstate, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfecovar, double> > , probs_h_microstate, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_rightB_Back : public Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfecovar, double> > , Klass, Value, pos_int>
{
pos_int t_0_i;
pos_int t_0_j;
Backtrace_nt_rightB_Back(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_)
  : Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfecovar, double> > , Klass, Value, pos_int>(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_rightB(t_0_i, t_0_j));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_rightB_Front : public Backtrace_Score<std::pair<Rope, std::pair<mfecovar, double> >  , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_rightB_Back<probs_h_microstate, Value, pos_int> > back;

Backtrace_nt_rightB_Front(intrusive_ptr<Backtrace_nt_rightB_Back<probs_h_microstate, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfecovar, double> > , probs_h_microstate, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_iloop_Back : public Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfecovar, double> > , Klass, Value, pos_int>
{
pos_int t_0_i;
pos_int t_0_j;
Backtrace_nt_iloop_Back(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_)
  : Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfecovar, double> > , Klass, Value, pos_int>(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_iloop(t_0_i, t_0_j));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_iloop_Front : public Backtrace_Score<std::pair<Rope, std::pair<mfecovar, double> >  , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_iloop_Back<probs_h_microstate, Value, pos_int> > back;

Backtrace_nt_iloop_Front(intrusive_ptr<Backtrace_nt_iloop_Back<probs_h_microstate, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfecovar, double> > , probs_h_microstate, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_multiloop_Back : public Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfecovar, double> > , Klass, Value, pos_int>
{
pos_int t_0_i;
pos_int t_0_j;
Backtrace_nt_multiloop_Back(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_)
  : Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfecovar, double> > , Klass, Value, pos_int>(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_multiloop(t_0_i, t_0_j));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_multiloop_Front : public Backtrace_Score<std::pair<Rope, std::pair<mfecovar, double> >  , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_multiloop_Back<probs_h_microstate, Value, pos_int> > back;

Backtrace_nt_multiloop_Front(intrusive_ptr<Backtrace_nt_multiloop_Back<probs_h_microstate, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfecovar, double> > , probs_h_microstate, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_ml_comps_Back : public Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfecovar, double> > , Klass, Value, pos_int>
{
pos_int t_0_i;
pos_int t_0_j;
Backtrace_nt_ml_comps_Back(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_)
  : Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfecovar, double> > , Klass, Value, pos_int>(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_ml_comps(t_0_i, t_0_j));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_ml_comps_Front : public Backtrace_Score<std::pair<Rope, std::pair<mfecovar, double> >  , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_ml_comps_Back<probs_h_microstate, Value, pos_int> > back;

Backtrace_nt_ml_comps_Front(intrusive_ptr<Backtrace_nt_ml_comps_Back<probs_h_microstate, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfecovar, double> > , probs_h_microstate, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_ml_comps1_Back : public Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfecovar, double> > , Klass, Value, pos_int>
{
pos_int t_0_i;
pos_int t_0_j;
Backtrace_nt_ml_comps1_Back(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_)
  : Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfecovar, double> > , Klass, Value, pos_int>(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_ml_comps1(t_0_i, t_0_j));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_ml_comps1_Front : public Backtrace_Score<std::pair<Rope, std::pair<mfecovar, double> >  , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_ml_comps1_Back<probs_h_microstate, Value, pos_int> > back;

Backtrace_nt_ml_comps1_Front(intrusive_ptr<Backtrace_nt_ml_comps1_Back<probs_h_microstate, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<std::pair<Rope, std::pair<mfecovar, double> > , probs_h_microstate, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

    List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > bt_proxy_nt_struct(unsigned int t_0_i);
    List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > bt_proxy_nt_dangle(unsigned int t_0_i, unsigned int t_0_j);
    List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > bt_proxy_nt_strong(unsigned int t_0_i, unsigned int t_0_j);
    List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > bt_proxy_nt_weak(unsigned int t_0_i, unsigned int t_0_j);
    List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > bt_proxy_nt_stack(unsigned int t_0_i, unsigned int t_0_j);
    std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  bt_proxy_nt_hairpin(unsigned int t_0_i, unsigned int t_0_j);
    List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > bt_proxy_nt_leftB(unsigned int t_0_i, unsigned int t_0_j);
    List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > bt_proxy_nt_rightB(unsigned int t_0_i, unsigned int t_0_j);
    List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > bt_proxy_nt_iloop(unsigned int t_0_i, unsigned int t_0_j);
    List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > bt_proxy_nt_multiloop(unsigned int t_0_i, unsigned int t_0_j);
    List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > bt_proxy_nt_ml_comps(unsigned int t_0_i, unsigned int t_0_j);
    List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > bt_proxy_nt_ml_comps1(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  bt_nt_dangle(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  bt_nt_hairpin(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  bt_nt_iloop(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  bt_nt_leftB(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  bt_nt_ml_comps(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  bt_nt_ml_comps1(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  bt_nt_multiloop(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  bt_nt_rightB(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  bt_nt_stack(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  bt_nt_strong(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  bt_nt_struct(unsigned int t_0_i);
    intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  bt_nt_weak(unsigned int t_0_i, unsigned int t_0_j);

    intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  addss_bt_r(intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  param_0, const TUSubsequence & param_1);
    intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  bl_bt_r(const TUSubsequence & param_0, const TUSubsequence & param_1, intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  param_2, const TUSubsequence & param_3);
    intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  br_bt_r(const TUSubsequence & param_0, intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  param_1, const TUSubsequence & param_2, const TUSubsequence & param_3);
    intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  cadd_bt_r(intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  param_0, intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  param_1);
    intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  drem_bt_r(const TUSubsequence & param_0, intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  param_1, const TUSubsequence & param_2);
    intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  edl_bt_r(const TUSubsequence & param_0, intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  param_1, const TUSubsequence & param_2);
    intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  edlr_bt_r(const TUSubsequence & param_0, intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  param_1, const TUSubsequence & param_2);
    intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  edr_bt_r(const TUSubsequence & param_0, intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  param_1, const TUSubsequence & param_2);
    List_Ref<intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > h_bt_r(List_Ref<intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > param_0);
    intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  hl_bt_r(const TUSubsequence & param_0, const TUSubsequence & param_1, const TUSubsequence & param_2);
    intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  il_bt_r(const TUSubsequence & param_0, const TUSubsequence & param_1, intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  param_2, const TUSubsequence & param_3, const TUSubsequence & param_4);
    intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  incl_bt_r(intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  param_0);
    intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  ml_bt_r(const TUSubsequence & param_0, intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  param_1, const TUSubsequence & param_2);
    intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  mldl_bt_r(const TUSubsequence & param_0, const TUSubsequence & param_1, intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  param_2, const TUSubsequence & param_3);
    intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  mldlr_bt_r(const TUSubsequence & param_0, const TUSubsequence & param_1, intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  param_2, const TUSubsequence & param_3, const TUSubsequence & param_4);
    intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  mldr_bt_r(const TUSubsequence & param_0, intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  param_1, const TUSubsequence & param_2, const TUSubsequence & param_3);
    intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  nil_bt_r(const TUSubsequence & param_0);
    intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  sadd_bt_r(const TUSubsequence & param_0, intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  param_1);
    intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  sr_bt_r(const TUSubsequence & param_0, intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  param_1, const TUSubsequence & param_2);


    std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  addss_bt(const std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > & p_p_e, const TUSubsequence & p_p_rb);
    std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  bl_bt(const TUSubsequence & p_p_lb, const TUSubsequence & p_p_lregion, const std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > & p_p_e, const TUSubsequence & p_p_rb);
    std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  br_bt(const TUSubsequence & p_p_lb, const std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > & p_p_e, const TUSubsequence & p_p_rregion, const TUSubsequence & p_p_rb);
    std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  cadd_bt(const std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > & p_p_le, const std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > & p_p_re);
    std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  drem_bt(const TUSubsequence & p_p_lloc, const std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > & p_p_e, const TUSubsequence & p_p_rloc);
    std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  edl_bt(const TUSubsequence & p_p_lb, const std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > & p_p_e, const TUSubsequence & p_p_rloc);
    std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  edlr_bt(const TUSubsequence & p_p_lb, const std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > & p_p_e, const TUSubsequence & p_p_rb);
    std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  edr_bt(const TUSubsequence & p_p_lloc, const std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > & p_p_e, const TUSubsequence & p_p_rb);
    List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > h_bt(List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > i, probs_h_microstate_hash_h &  left_answers);
template <typename Iterator>
    List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > h_bt(std::pair<Iterator, Iterator> i, probs_h_microstate_hash_h &  left_answers)
;
    List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > h_bt(List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > i);
template <typename Iterator>
    List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > h_bt(std::pair<Iterator, Iterator> i)
;
    std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  hl_bt(const TUSubsequence & p_p_lb, const TUSubsequence & p_p_region, const TUSubsequence & p_p_rb);
    std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  il_bt(const TUSubsequence & p_p_lb, const TUSubsequence & p_p_lregion, const std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > & p_p_e, const TUSubsequence & p_p_rregion, const TUSubsequence & p_p_rb);
    std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  incl_bt(const std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > & p_p_e);
    std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  ml_bt(const TUSubsequence & p_p_lb, const std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > & p_p_e, const TUSubsequence & p_p_rb);
    std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  mldl_bt(const TUSubsequence & p_p_lb, const TUSubsequence & p_p_dl, const std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > & p_p_e, const TUSubsequence & p_p_rb);
    std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  mldlr_bt(const TUSubsequence & p_p_lb, const TUSubsequence & p_p_dl, const std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > & p_p_e, const TUSubsequence & p_p_dr, const TUSubsequence & p_p_rb);
    std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  mldr_bt(const TUSubsequence & p_p_lb, const std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > & p_p_e, const TUSubsequence & p_p_dr, const TUSubsequence & p_p_rb);
    std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  nil_bt(const TUSubsequence & p_p_loc);
    std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  sadd_bt(const TUSubsequence & p_p_b, const std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > & p_p_e);
    std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  sr_bt(const TUSubsequence & p_p_lb, const std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > & p_p_e, const TUSubsequence & p_p_rb);

template <typename Value>   void  print_result(std::ostream &out, Value& res)

{
}
   intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  backtrack(unsigned int t_0_i)
{
List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > bt  = bt_proxy_nt_struct(t_0_i);
return execute_backtrack_k(bt);
}
template <typename Value>   void  print_backtrack(std::ostream &out, Value& value)

{
intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  bt    = backtrack(t_0_left_most);
intrusive_ptr<Backtrace_List<std::pair<String, double> , unsigned int> > l =
  boost::dynamic_pointer_cast<Backtrace_List<std::pair<String, double> , unsigned int> > (bt);
assert(!bt || (bt && l));
if (l) {
for (Backtrace_List<std::pair<String, double> , unsigned int>::iterator i = l->begin();
     i != l->end(); ++i)
  (*i)->print(out);
}
}
   void  print_subopt(std::ostream &out, int  delta = 0) {}

};

#ifndef NO_GAPC_TYPEDEFS
namespace gapc {
  typedef probs_h_microstate hishapeh_pfx_cls;
  typedef probs_h_microstate_hash_h &  hishapeh_pfx_ret;
}
#endif

#endif

