
// A dynamic programming evaluator generated by GAP-C.
// 
//   GAP-C version:
//     bellmansgapc-2013.05.02
// 
//   GAP-C call:
//     /home/jhuang/local/gapc/bin/gapc -I ../../../ -p ((alg_ali_hishape_a * (alg_ali_mfe % alg_ali_pfunc)) suchthat filterLowProbShapes) * (alg_ali_dotBracket * alg_ali_pfunc) ../../../ali_microstate.gap --kbacktrace --no-coopt-class --kbest -o probs_a_microstate.cc 
// 
// 


#define GAPC_MOD_TRANSLATION_UNIT
#include "probs_a_microstate.hh"

uint32_t probs_a_microstate_insp_hash_h::k_ = 3;
#include <rtlib/subopt.hh>
#include "rna.hh"
#include "Extensions/alifold.hh"
#include "Extensions/mfesubopt.hh"
#include "Extensions/probabilities.hh"
#include "Extensions/typesRNAfolding.hh"
#include "Extensions/shapes.hh"

#include "Extensions/rnaoptions.hh"
//#include "filter_add.hh"

probs_a_microstate_hash_h &  probs_a_microstate::nt_dangle(unsigned int t_0_i, unsigned int t_0_j)
{
  if (dangle_table.is_tabulated(t_0_i, t_0_j))
    {
      return dangle_table.get(t_0_i, t_0_j);
    }

  probs_a_microstate_hash_h answers;
  empty(answers);
  empty( answers);

  if (((t_0_j - t_0_i) >= 6))
  {
    TUSubsequence ret_3 = LOC(t_0_seq, t_0_j, t_0_j);
    TUSubsequence a_2 = ret_3;
    if (is_not_empty(a_2))
    {
      TUSubsequence ret_1;
      if (unpaired(t_0_seq, t_0_i, (t_0_i + 1)))
        {
          ret_1 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
        }

      else
        {
          empty( ret_1);
        }

      TUSubsequence a_0 = ret_1;
      if (is_not_empty(a_0))
      {
        probs_a_microstate_hash_h ret_2 = nt_strong((t_0_i + 1), t_0_j);
        probs_a_microstate_hash_h a_1 = ret_2;
        if (is_not_empty(a_1))
          {
            for (probs_a_microstate_hash_h::iterator x_1_itr = a_1.ref().begin(); x_1_itr!=a_1.ref().end(); ++x_1_itr){
              std::pair<Rope, std::pair<mfecovar, double> >  x_1 = *x_1_itr;
              std::pair<Rope, std::pair<mfecovar, double> >  ans = edl(a_0, x_1, a_2);
              if ((ans.second.first.mfe + ans.second.first.covar) <= _thresh)  // rule1
              {
                push_back( answers, ans);
              }
            }
          }

        erase( a_1);
      }

      erase( a_0);
    }

    erase( a_2);
  }


  if (((t_0_j - t_0_i) >= 6))
  {
    TUSubsequence ret_7;
    if (unpaired(t_0_seq, (t_0_j - 1), t_0_j))
      {
        ret_7 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
      }

    else
      {
        empty( ret_7);
      }

    TUSubsequence a_5 = ret_7;
    if (is_not_empty(a_5))
    {
      TUSubsequence ret_5 = LOC(t_0_seq, t_0_i, t_0_i);
      TUSubsequence a_3 = ret_5;
      if (is_not_empty(a_3))
      {
        probs_a_microstate_hash_h ret_6 = nt_strong(t_0_i, (t_0_j - 1));
        probs_a_microstate_hash_h a_4 = ret_6;
        if (is_not_empty(a_4))
          {
            for (probs_a_microstate_hash_h::iterator x_4_itr = a_4.ref().begin(); x_4_itr!=a_4.ref().end(); ++x_4_itr){
              std::pair<Rope, std::pair<mfecovar, double> >  x_4 = *x_4_itr;
              std::pair<Rope, std::pair<mfecovar, double> >  ans = edr(a_3, x_4, a_5);
              if ((ans.second.first.mfe + ans.second.first.covar) <= _thresh)  // rule1
              {
                push_back( answers, ans);
              }
            }
          }

        erase( a_4);
      }

      erase( a_3);
    }

    erase( a_5);
  }


  if (((t_0_j - t_0_i) >= 7))
  {
    TUSubsequence ret_11;
    if (unpaired(t_0_seq, (t_0_j - 1), t_0_j))
      {
        ret_11 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
      }

    else
      {
        empty( ret_11);
      }

    TUSubsequence a_8 = ret_11;
    if (is_not_empty(a_8))
    {
      TUSubsequence ret_9;
      if (unpaired(t_0_seq, t_0_i, (t_0_i + 1)))
        {
          ret_9 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
        }

      else
        {
          empty( ret_9);
        }

      TUSubsequence a_6 = ret_9;
      if (is_not_empty(a_6))
      {
        probs_a_microstate_hash_h ret_10 = nt_strong((t_0_i + 1), (t_0_j - 1));
        probs_a_microstate_hash_h a_7 = ret_10;
        if (is_not_empty(a_7))
          {
            for (probs_a_microstate_hash_h::iterator x_7_itr = a_7.ref().begin(); x_7_itr!=a_7.ref().end(); ++x_7_itr){
              std::pair<Rope, std::pair<mfecovar, double> >  x_7 = *x_7_itr;
              std::pair<Rope, std::pair<mfecovar, double> >  ans = edlr(a_6, x_7, a_8);
              if ((ans.second.first.mfe + ans.second.first.covar) <= _thresh)  // rule1
              {
                push_back( answers, ans);
              }
            }
          }

        erase( a_7);
      }

      erase( a_6);
    }

    erase( a_8);
  }


  if (((t_0_j - t_0_i) >= 5))
  {
    TUSubsequence ret_15 = LOC(t_0_seq, t_0_j, t_0_j);
    TUSubsequence a_11 = ret_15;
    if (is_not_empty(a_11))
    {
      TUSubsequence ret_13 = LOC(t_0_seq, t_0_i, t_0_i);
      TUSubsequence a_9 = ret_13;
      if (is_not_empty(a_9))
      {
        probs_a_microstate_hash_h ret_14 = nt_strong(t_0_i, t_0_j);
        probs_a_microstate_hash_h a_10 = ret_14;
        if (is_not_empty(a_10))
          {
            for (probs_a_microstate_hash_h::iterator x_10_itr = a_10.ref().begin(); x_10_itr!=a_10.ref().end(); ++x_10_itr){
              std::pair<Rope, std::pair<mfecovar, double> >  x_10 = *x_10_itr;
              std::pair<Rope, std::pair<mfecovar, double> >  ans = drem(a_9, x_10, a_11);
              if ((ans.second.first.mfe + ans.second.first.covar) <= _thresh)  // rule1
              {
                push_back( answers, ans);
              }
            }
          }

        erase( a_10);
      }

      erase( a_9);
    }

    erase( a_11);
  }

  hash_filter( answers);
  finalize( answers);
  dangle_table.set( t_0_i, t_0_j, answers);
  return dangle_table.get(t_0_i, t_0_j);
}

probs_a_microstate_hash_h probs_a_microstate::nt_hairpin(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 5))
    {
      return LBRope_firstG_Bmfecovar_firstG_float_secondG_E_secondG_EMhdecl0x2777aa0_zero;
    }

  probs_a_microstate_hash_h answers;
  empty(answers);
  empty( answers);
  std::pair<Rope, std::pair<mfecovar, double> >  ret_0;
  if (((t_0_j - t_0_i) >= 5))
    {
      if ( (_matchStr.empty() && basepair(t_0_seq, t_0_i, t_0_j)) || \
           ((!_matchStr.empty() && !_exact) && fuzzy_pairing_center_at(t_0_seq, t_0_i, t_0_j, _match_tokens_h)) || \
           ((!_matchStr.empty() && _exact) && exact_pairing_center_at(t_0_seq, t_0_i, t_0_j, _match_tokens_h)) )  // added
      {                                                                                                           // added
        TUSubsequence ret_3 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
        TUSubsequence a_2 = ret_3;
        if (is_not_empty(a_2))
        {
          TUSubsequence ret_2;
          if ((minsize(t_0_seq, (t_0_i + 1), (t_0_j - 1), 3) && unpaired(t_0_seq, (t_0_i + 1), (t_0_j - 1))))
            {
              ret_2 = REGION(t_0_seq, (t_0_i + 1), (t_0_j - 1));
            }

          else
            {
              empty( ret_2);
            }

          TUSubsequence a_1 = ret_2;
          if (is_not_empty(a_1))
          {
            TUSubsequence ret_1 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
            TUSubsequence a_0 = ret_1;
            if (is_not_empty(a_0))
              {
                ret_0 = hl(a_0, a_1, a_2);
              }

            else
              {
                empty( ret_0);
              }

            erase( a_0);
          }

          else
            {
              empty( ret_0);
            }

          erase( a_1);
        }

        else
          {
            empty( ret_0);
          }

        erase( a_2);
      }

      else
      {
        empty( ret_0);
        empty( ret_0);
      }

    }

  else
    {
      empty( ret_0);
    }

  if (is_not_empty(ret_0))
    {
      push_back( answers, ret_0);
    }

  hash_filter( answers);
  finalize( answers);
  return answers;
}

probs_a_microstate_hash_h &  probs_a_microstate::nt_iloop(unsigned int t_0_i, unsigned int t_0_j)
{
  if (iloop_table.is_tabulated(t_0_i, t_0_j))
    {
      return iloop_table.get(t_0_i, t_0_j);
    }

  probs_a_microstate_hash_h answers;
  empty(answers);
  empty( answers);

  if (((t_0_j - t_0_i) >= 9))
    {
      if /*(*/(/*(!_exact) && */basepair(t_0_seq, t_0_i, t_0_j)) /*|| ((_exact) && exact_pairing_center_at(t_0_seq, t_0_i, t_0_j, _match_tokens_i)))*/  // added_
      {                                                                                                                                     // added_
          for(          unsigned int t_0_k_0 = (t_0_i + 2); ((t_0_k_0 <= (t_0_j - 7)) && (t_0_k_0 <= (t_0_i + 31))); ++t_0_k_0)
          {
            for(            unsigned int t_0_k_1 = (((t_0_j - (t_0_k_0 + 5)) >= 31)) ? ((t_0_j - 31)) : ((t_0_k_0 + 5)); (t_0_k_1 <= (t_0_j - 2)); ++t_0_k_1)
            {
              TUSubsequence ret_5 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
              TUSubsequence a_4 = ret_5;
              if (is_not_empty(a_4))
              {
                TUSubsequence ret_4;
                if ((maxsize(t_0_seq, t_0_k_1, (t_0_j - 1), 30) && unpaired(t_0_seq, t_0_k_1, (t_0_j - 1))))
                  {
                    ret_4 = REGION(t_0_seq, t_0_k_1, (t_0_j - 1));
                  }

                else
                  {
                    empty( ret_4);
                  }

                TUSubsequence a_3 = ret_4;
                if (is_not_empty(a_3))
                {
                  TUSubsequence ret_2;
                  if ((maxsize(t_0_seq, (t_0_i + 1), t_0_k_0, 30) && unpaired(t_0_seq, (t_0_i + 1), t_0_k_0)))
                    {
                      ret_2 = REGION(t_0_seq, (t_0_i + 1), t_0_k_0);
                    }

                  else
                    {
                      empty( ret_2);
                    }

                  TUSubsequence a_1 = ret_2;
                  if (is_not_empty(a_1))
                  {
                    TUSubsequence ret_1 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
                    TUSubsequence a_0 = ret_1;
                    if (is_not_empty(a_0))
                    {
                      probs_a_microstate_hash_h ret_3 = nt_strong(t_0_k_0, t_0_k_1);
                      probs_a_microstate_hash_h a_2 = ret_3;
                      if (is_not_empty(a_2))
                        {
                          for (probs_a_microstate_hash_h::iterator x_2_itr = a_2.ref().begin(); x_2_itr!=a_2.ref().end(); ++x_2_itr){
                            std::pair<Rope, std::pair<mfecovar, double> >  x_2 = *x_2_itr;
                            std::pair<Rope, std::pair<mfecovar, double> >  ans = il(a_0, a_1, x_2, a_3, a_4);
                            push_back( answers, ans);
                          }
                        }

                      erase( a_2);
                    }

                    erase( a_0);
                  }

                  erase( a_1);
                }

                erase( a_3);
              }

              erase( a_4);
            }

          }

        }

      else
        {
          empty( answers);
        }

    }

  hash_filter( answers);
  finalize( answers);
  iloop_table.set( t_0_i, t_0_j, answers);
  return iloop_table.get(t_0_i, t_0_j);
}

probs_a_microstate_hash_h probs_a_microstate::nt_leftB(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 8))
    {
      return LBRope_firstG_Bmfecovar_firstG_float_secondG_E_secondG_EMhdecl0x2777aa0_zero;
    }

  probs_a_microstate_hash_h answers;
  empty(answers);
  empty( answers);

  if (((t_0_j - t_0_i) >= 8))
    {
      if /*(*/(/*(!_exact) && */basepair(t_0_seq, t_0_i, t_0_j)) /*|| ((_exact) && exact_pairing_center_at(t_0_seq, t_0_i, t_0_j, _match_tokens_b)))*/  // added_
      {                                                                                                                                     // added_
          for(          unsigned int t_0_k_0 = (t_0_i + 2); ((t_0_k_0 <= (t_0_j - 6)) && (t_0_k_0 <= (t_0_i + 31))); ++t_0_k_0)
          {
            TUSubsequence ret_4 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
            TUSubsequence a_3 = ret_4;
            if (is_not_empty(a_3))
            {
              TUSubsequence ret_2;
              if ((maxsize(t_0_seq, (t_0_i + 1), t_0_k_0, 30) && unpaired(t_0_seq, (t_0_i + 1), t_0_k_0)))
                {
                  ret_2 = REGION(t_0_seq, (t_0_i + 1), t_0_k_0);
                }

              else
                {
                  empty( ret_2);
                }

              TUSubsequence a_1 = ret_2;
              if (is_not_empty(a_1))
              {
                TUSubsequence ret_1 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
                TUSubsequence a_0 = ret_1;
                if (is_not_empty(a_0))
                {
                  probs_a_microstate_hash_h ret_3 = nt_strong(t_0_k_0, (t_0_j - 1));
                  probs_a_microstate_hash_h a_2 = ret_3;
                  if (is_not_empty(a_2))
                    {
                      for (probs_a_microstate_hash_h::iterator x_2_itr = a_2.ref().begin(); x_2_itr!=a_2.ref().end(); ++x_2_itr){
                        std::pair<Rope, std::pair<mfecovar, double> >  x_2 = *x_2_itr;
                        std::pair<Rope, std::pair<mfecovar, double> >  ans = bl(a_0, a_1, x_2, a_3);
                        push_back( answers, ans);
                      }
                    }

                  erase( a_2);
                }

                erase( a_0);
              }

              erase( a_1);
            }

            erase( a_3);
          }

        }

      else
        {
          empty( answers);
        }

    }

  hash_filter( answers);
  finalize( answers);
  return answers;
}

probs_a_microstate_hash_h &  probs_a_microstate::nt_ml_comps(unsigned int t_0_i, unsigned int t_0_j)
{
  if (ml_comps_table.is_tabulated(t_0_i, t_0_j))
    {
      return ml_comps_table.get(t_0_i, t_0_j);
    }

  probs_a_microstate_hash_h answers;
  empty(answers);
  empty( answers);

  if (((t_0_j - t_0_i) >= 11))
  {
    TUSubsequence ret_1;
    if (unpaired(t_0_seq, t_0_i, (t_0_i + 1)))
      {
        ret_1 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
      }

    else
      {
        empty( ret_1);
      }

    TUSubsequence a_0 = ret_1;
    if (is_not_empty(a_0))
    {
      probs_a_microstate_hash_h ret_2 = nt_ml_comps((t_0_i + 1), t_0_j);
      probs_a_microstate_hash_h a_1 = ret_2;
      if (is_not_empty(a_1))
        {
          for (probs_a_microstate_hash_h::iterator x_1_itr = a_1.ref().begin(); x_1_itr!=a_1.ref().end(); ++x_1_itr){
            std::pair<Rope, std::pair<mfecovar, double> >  x_1 = *x_1_itr;
            std::pair<Rope, std::pair<mfecovar, double> >  ans = sadd(a_0, x_1);
            push_back( answers, ans);
          }
        }

      erase( a_1);
    }

    erase( a_0);
  }


  if (((t_0_j - t_0_i) >= 10))
    {
      for(      unsigned int t_0_k_0 = (t_0_i + 5); (t_0_k_0 <= (t_0_j - 5)); ++t_0_k_0)
      {
        probs_a_microstate_hash_h ret_6 = nt_ml_comps1(t_0_k_0, t_0_j);
        probs_a_microstate_hash_h a_4 = ret_6;
        if (is_not_empty(a_4))
        {
          probs_a_microstate_hash_h ret_4;
          empty(ret_4);
          if (((t_0_k_0 - t_0_i) >= 5))
          {
            probs_a_microstate_hash_h ret_5 = nt_dangle(t_0_i, t_0_k_0);
            probs_a_microstate_hash_h a_3 = ret_5;
            if (is_not_empty(a_3))
              {
                for (probs_a_microstate_hash_h::iterator x_3_itr = a_3.ref().begin(); x_3_itr!=a_3.ref().end(); ++x_3_itr){
                  std::pair<Rope, std::pair<mfecovar, double> >  x_3 = *x_3_itr;
                  std::pair<Rope, std::pair<mfecovar, double> >  ans = incl(x_3);
                  push_back( ret_4, ans);
                }
              }

            erase( a_3);
          }

          finalize( ret_4);
          probs_a_microstate_hash_h a_2 = ret_4;
          if (is_not_empty(a_2))
            {
              for (probs_a_microstate_hash_h::iterator x_2_itr = a_2.ref().begin(); x_2_itr!=a_2.ref().end(); ++x_2_itr){
                std::pair<Rope, std::pair<mfecovar, double> >  x_2 = *x_2_itr;
                for (probs_a_microstate_hash_h::iterator x_4_itr = a_4.ref().begin(); x_4_itr!=a_4.ref().end(); ++x_4_itr){
                  std::pair<Rope, std::pair<mfecovar, double> >  x_4 = *x_4_itr;
                  std::pair<Rope, std::pair<mfecovar, double> >  ans = cadd(x_2, x_4);
                  push_back( answers, ans);
                }
              }
            }

          erase( a_2);
        }

        erase( a_4);
      }

    }

  hash_filter( answers);
  finalize( answers);
  ml_comps_table.set( t_0_i, t_0_j, answers);
  return ml_comps_table.get(t_0_i, t_0_j);
}

probs_a_microstate_hash_h &  probs_a_microstate::nt_ml_comps1(unsigned int t_0_i, unsigned int t_0_j)
{
  if (ml_comps1_table.is_tabulated(t_0_i, t_0_j))
    {
      return ml_comps1_table.get(t_0_i, t_0_j);
    }

  probs_a_microstate_hash_h answers;
  empty(answers);
  empty( answers);

  if (((t_0_j - t_0_i) >= 6))
  {
    TUSubsequence ret_1;
    if (unpaired(t_0_seq, t_0_i, (t_0_i + 1)))
      {
        ret_1 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
      }

    else
      {
        empty( ret_1);
      }

    TUSubsequence a_0 = ret_1;
    if (is_not_empty(a_0))
    {
      probs_a_microstate_hash_h ret_2 = nt_ml_comps1((t_0_i + 1), t_0_j);
      probs_a_microstate_hash_h a_1 = ret_2;
      if (is_not_empty(a_1))
        {
          for (probs_a_microstate_hash_h::iterator x_1_itr = a_1.ref().begin(); x_1_itr!=a_1.ref().end(); ++x_1_itr){
            std::pair<Rope, std::pair<mfecovar, double> >  x_1 = *x_1_itr;
            std::pair<Rope, std::pair<mfecovar, double> >  ans = sadd(a_0, x_1);
            push_back( answers, ans);
          }
        }

      erase( a_1);
    }

    erase( a_0);
  }


  if (((t_0_j - t_0_i) >= 10))
    {
      for(      unsigned int t_0_k_0 = (t_0_i + 5); (t_0_k_0 <= (t_0_j - 5)); ++t_0_k_0)
      {
        probs_a_microstate_hash_h ret_6 = nt_ml_comps1(t_0_k_0, t_0_j);
        probs_a_microstate_hash_h a_4 = ret_6;
        if (is_not_empty(a_4))
        {
          probs_a_microstate_hash_h ret_4;
          empty(ret_4);
          if (((t_0_k_0 - t_0_i) >= 5))
          {
            probs_a_microstate_hash_h ret_5 = nt_dangle(t_0_i, t_0_k_0);
            probs_a_microstate_hash_h a_3 = ret_5;
            if (is_not_empty(a_3))
              {
                for (probs_a_microstate_hash_h::iterator x_3_itr = a_3.ref().begin(); x_3_itr!=a_3.ref().end(); ++x_3_itr){
                  std::pair<Rope, std::pair<mfecovar, double> >  x_3 = *x_3_itr;
                  std::pair<Rope, std::pair<mfecovar, double> >  ans = incl(x_3);
                  push_back( ret_4, ans);
                }
              }

            erase( a_3);
          }

          finalize( ret_4);
          probs_a_microstate_hash_h a_2 = ret_4;
          if (is_not_empty(a_2))
            {
              for (probs_a_microstate_hash_h::iterator x_2_itr = a_2.ref().begin(); x_2_itr!=a_2.ref().end(); ++x_2_itr){
                std::pair<Rope, std::pair<mfecovar, double> >  x_2 = *x_2_itr;
                for (probs_a_microstate_hash_h::iterator x_4_itr = a_4.ref().begin(); x_4_itr!=a_4.ref().end(); ++x_4_itr){
                  std::pair<Rope, std::pair<mfecovar, double> >  x_4 = *x_4_itr;
                  std::pair<Rope, std::pair<mfecovar, double> >  ans = cadd(x_2, x_4);
                  push_back( answers, ans);
                }
              }
            }

          erase( a_2);
        }

        erase( a_4);
      }

    }


  if (((t_0_j - t_0_i) >= 5))
  {
    probs_a_microstate_hash_h ret_8 = nt_dangle(t_0_i, t_0_j);
    probs_a_microstate_hash_h a_5 = ret_8;
    if (is_not_empty(a_5))
      {
        for (probs_a_microstate_hash_h::iterator x_5_itr = a_5.ref().begin(); x_5_itr!=a_5.ref().end(); ++x_5_itr){
          std::pair<Rope, std::pair<mfecovar, double> >  x_5 = *x_5_itr;
          std::pair<Rope, std::pair<mfecovar, double> >  ans = incl(x_5);
          push_back( answers, ans);
        }
      }

    erase( a_5);
  }


  if (((t_0_j - t_0_i) >= 6))
    {
      for(      unsigned int t_0_k_1 = (t_0_i + 5); (t_0_k_1 <= (t_0_j - 1)); ++t_0_k_1)
      {
        TUSubsequence ret_12;
        if (unpaired(t_0_seq, t_0_k_1, t_0_j))
          {
            ret_12 = REGION(t_0_seq, t_0_k_1, t_0_j);
          }

        else
          {
            empty( ret_12);
          }

        TUSubsequence a_8 = ret_12;
        if (is_not_empty(a_8))
        {
          probs_a_microstate_hash_h ret_10;
          empty(ret_10);
          if (((t_0_k_1 - t_0_i) >= 5))
          {
            probs_a_microstate_hash_h ret_11 = nt_dangle(t_0_i, t_0_k_1);
            probs_a_microstate_hash_h a_7 = ret_11;
            if (is_not_empty(a_7))
              {
                for (probs_a_microstate_hash_h::iterator x_7_itr = a_7.ref().begin(); x_7_itr!=a_7.ref().end(); ++x_7_itr){
                  std::pair<Rope, std::pair<mfecovar, double> >  x_7 = *x_7_itr;
                  std::pair<Rope, std::pair<mfecovar, double> >  ans = incl(x_7);
                  push_back( ret_10, ans);
                }
              }

            erase( a_7);
          }

          finalize( ret_10);
          probs_a_microstate_hash_h a_6 = ret_10;
          if (is_not_empty(a_6))
            {
              for (probs_a_microstate_hash_h::iterator x_6_itr = a_6.ref().begin(); x_6_itr!=a_6.ref().end(); ++x_6_itr){
                std::pair<Rope, std::pair<mfecovar, double> >  x_6 = *x_6_itr;
                std::pair<Rope, std::pair<mfecovar, double> >  ans = addss(x_6, a_8);
                push_back( answers, ans);
              }
            }

          erase( a_6);
        }

        erase( a_8);
      }

    }

  hash_filter( answers);
  finalize( answers);
  ml_comps1_table.set( t_0_i, t_0_j, answers);
  return ml_comps1_table.get(t_0_i, t_0_j);
}

probs_a_microstate_hash_h probs_a_microstate::nt_multiloop(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 12))
    {
      return LBRope_firstG_Bmfecovar_firstG_float_secondG_E_secondG_EMhdecl0x2777aa0_zero;
    }

  probs_a_microstate_hash_h answers;
  empty(answers);
  empty( answers);

  if (((t_0_j - t_0_i) >= 12))
    {
      if /*(*/(/*(!_exact) && */basepair(t_0_seq, t_0_i, t_0_j)) /*|| ((_exact) && exact_pairing_center_at(t_0_seq, t_0_i, t_0_j, _match_tokens_m)))*/  // added_
      {                                                                                                                                     // added_
        TUSubsequence ret_3 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
        TUSubsequence a_2 = ret_3;
        if (is_not_empty(a_2))
        {
          TUSubsequence ret_1 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
          TUSubsequence a_0 = ret_1;
          if (is_not_empty(a_0))
          {
            probs_a_microstate_hash_h ret_2 = nt_ml_comps((t_0_i + 1), (t_0_j - 1));
            probs_a_microstate_hash_h a_1 = ret_2;
            if (is_not_empty(a_1))
              {
                for (probs_a_microstate_hash_h::iterator x_1_itr = a_1.ref().begin(); x_1_itr!=a_1.ref().end(); ++x_1_itr){
                  std::pair<Rope, std::pair<mfecovar, double> >  x_1 = *x_1_itr;
                  std::pair<Rope, std::pair<mfecovar, double> >  ans = ml(a_0, x_1, a_2);
                  push_back( answers, ans);
                }
              }

            erase( a_1);
          }

          erase( a_0);
        }

        erase( a_2);
      }

      else
        {
          empty( answers);
        }

    }


  if (((t_0_j - t_0_i) >= 13))
    {
      if /*(*/(/*(!_exact) && */basepair(t_0_seq, t_0_i, t_0_j)) /*|| ((_exact) && exact_pairing_center_at(t_0_seq, t_0_i, t_0_j, _match_tokens_m)))*/  // added_
      {                                                                                                                                     // added_
        TUSubsequence ret_8 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
        TUSubsequence a_6 = ret_8;
        if (is_not_empty(a_6))
        {
          TUSubsequence ret_6;
          if (unpaired(t_0_seq, (t_0_i + 1), ((t_0_i + 1) + 1)))
            {
              ret_6 = BASE(t_0_seq, (t_0_i + 1), ((t_0_i + 1) + 1));
            }

          else
            {
              empty( ret_6);
            }

          TUSubsequence a_4 = ret_6;
          if (is_not_empty(a_4))
          {
            TUSubsequence ret_5 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
            TUSubsequence a_3 = ret_5;
            if (is_not_empty(a_3))
            {
              probs_a_microstate_hash_h ret_7 = nt_ml_comps((t_0_i + 2), (t_0_j - 1));
              probs_a_microstate_hash_h a_5 = ret_7;
              if (is_not_empty(a_5))
                {
                  for (probs_a_microstate_hash_h::iterator x_5_itr = a_5.ref().begin(); x_5_itr!=a_5.ref().end(); ++x_5_itr){
                    std::pair<Rope, std::pair<mfecovar, double> >  x_5 = *x_5_itr;
                    std::pair<Rope, std::pair<mfecovar, double> >  ans = mldl(a_3, a_4, x_5, a_6);
                    push_back( answers, ans);
                  }
                }

              erase( a_5);
            }

            erase( a_3);
          }

          erase( a_4);
        }

        erase( a_6);
      }

      else
        {
          empty( answers);
        }

    }


  if (((t_0_j - t_0_i) >= 13))
    {
      if /*(*/(/*(!_exact) && */basepair(t_0_seq, t_0_i, t_0_j)) /*|| ((_exact) && exact_pairing_center_at(t_0_seq, t_0_i, t_0_j, _match_tokens_m)))*/  // added_
      {                                                                                                                                     // added_
        TUSubsequence ret_13 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
        TUSubsequence a_10 = ret_13;
        if (is_not_empty(a_10))
        {
          TUSubsequence ret_12;
          if (unpaired(t_0_seq, (t_0_j - 2), (t_0_j - 1)))
            {
              ret_12 = BASE(t_0_seq, (t_0_j - 2), (t_0_j - 1));
            }

          else
            {
              empty( ret_12);
            }

          TUSubsequence a_9 = ret_12;
          if (is_not_empty(a_9))
          {
            TUSubsequence ret_10 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
            TUSubsequence a_7 = ret_10;
            if (is_not_empty(a_7))
            {
              probs_a_microstate_hash_h ret_11 = nt_ml_comps((t_0_i + 1), (t_0_j - 2));
              probs_a_microstate_hash_h a_8 = ret_11;
              if (is_not_empty(a_8))
                {
                  for (probs_a_microstate_hash_h::iterator x_8_itr = a_8.ref().begin(); x_8_itr!=a_8.ref().end(); ++x_8_itr){
                    std::pair<Rope, std::pair<mfecovar, double> >  x_8 = *x_8_itr;
                    std::pair<Rope, std::pair<mfecovar, double> >  ans = mldr(a_7, x_8, a_9, a_10);
                    push_back( answers, ans);
                  }
                }

              erase( a_8);
            }

            erase( a_7);
          }

          erase( a_9);
        }

        erase( a_10);
      }

      else
        {
          empty( answers);
        }

    }


  if (((t_0_j - t_0_i) >= 14))
    {
      if /*(*/(/*(!_exact) && */basepair(t_0_seq, t_0_i, t_0_j)) /*|| ((_exact) && exact_pairing_center_at(t_0_seq, t_0_i, t_0_j, _match_tokens_m)))*/  // added_
      {                                                                                                                                     // added_
        TUSubsequence ret_19 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
        TUSubsequence a_15 = ret_19;
        if (is_not_empty(a_15))
        {
          TUSubsequence ret_18;
          if (unpaired(t_0_seq, (t_0_j - 2), (t_0_j - 1)))
            {
              ret_18 = BASE(t_0_seq, (t_0_j - 2), (t_0_j - 1));
            }

          else
            {
              empty( ret_18);
            }

          TUSubsequence a_14 = ret_18;
          if (is_not_empty(a_14))
          {
            TUSubsequence ret_16;
            if (unpaired(t_0_seq, (t_0_i + 1), ((t_0_i + 1) + 1)))
              {
                ret_16 = BASE(t_0_seq, (t_0_i + 1), ((t_0_i + 1) + 1));
              }

            else
              {
                empty( ret_16);
              }

            TUSubsequence a_12 = ret_16;
            if (is_not_empty(a_12))
            {
              TUSubsequence ret_15 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
              TUSubsequence a_11 = ret_15;
              if (is_not_empty(a_11))
              {
                probs_a_microstate_hash_h ret_17 = nt_ml_comps((t_0_i + 2), (t_0_j - 2));
                probs_a_microstate_hash_h a_13 = ret_17;
                if (is_not_empty(a_13))
                  {
                    for (probs_a_microstate_hash_h::iterator x_13_itr = a_13.ref().begin(); x_13_itr!=a_13.ref().end(); ++x_13_itr){
                      std::pair<Rope, std::pair<mfecovar, double> >  x_13 = *x_13_itr;
                      std::pair<Rope, std::pair<mfecovar, double> >  ans = mldlr(a_11, a_12, x_13, a_14, a_15);
                      push_back( answers, ans);
                    }
                  }

                erase( a_13);
              }

              erase( a_11);
            }

            erase( a_12);
          }

          erase( a_14);
        }

        erase( a_15);
      }

      else
        {
          empty( answers);
        }

    }

  hash_filter( answers);
  finalize( answers);
  return answers;
}

probs_a_microstate_hash_h probs_a_microstate::nt_rightB(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 8))
    {
      return LBRope_firstG_Bmfecovar_firstG_float_secondG_E_secondG_EMhdecl0x2777aa0_zero;
    }

  probs_a_microstate_hash_h answers;
  empty(answers);
  empty( answers);

  if (((t_0_j - t_0_i) >= 8))
    {
      if /*(*/(/*(!_exact) && */basepair(t_0_seq, t_0_i, t_0_j)) /*|| ((_exact) && exact_pairing_center_at(t_0_seq, t_0_i, t_0_j, _match_tokens_b)))*/  // added_
      {                                                                                                                                     // added_
          for(          unsigned int t_0_k_0 = (((t_0_j - (t_0_i + 6)) >= 31)) ? ((t_0_j - 31)) : ((t_0_i + 6)); (t_0_k_0 <= (t_0_j - 2)); ++t_0_k_0)
          {
            TUSubsequence ret_4 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
            TUSubsequence a_3 = ret_4;
            if (is_not_empty(a_3))
            {
              TUSubsequence ret_3;
              if ((maxsize(t_0_seq, t_0_k_0, (t_0_j - 1), 30) && unpaired(t_0_seq, t_0_k_0, (t_0_j - 1))))
                {
                  ret_3 = REGION(t_0_seq, t_0_k_0, (t_0_j - 1));
                }

              else
                {
                  empty( ret_3);
                }

              TUSubsequence a_2 = ret_3;
              if (is_not_empty(a_2))
              {
                TUSubsequence ret_1 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
                TUSubsequence a_0 = ret_1;
                if (is_not_empty(a_0))
                {
                  probs_a_microstate_hash_h ret_2 = nt_strong((t_0_i + 1), t_0_k_0);
                  probs_a_microstate_hash_h a_1 = ret_2;
                  if (is_not_empty(a_1))
                    {
                      for (probs_a_microstate_hash_h::iterator x_1_itr = a_1.ref().begin(); x_1_itr!=a_1.ref().end(); ++x_1_itr){
                        std::pair<Rope, std::pair<mfecovar, double> >  x_1 = *x_1_itr;
                        std::pair<Rope, std::pair<mfecovar, double> >  ans = br(a_0, x_1, a_2, a_3);
                        push_back( answers, ans);
                      }
                    }

                  erase( a_1);
                }

                erase( a_0);
              }

              erase( a_2);
            }

            erase( a_3);
          }

        }

      else
        {
          empty( answers);
        }

    }

  hash_filter( answers);
  finalize( answers);
  return answers;
}

probs_a_microstate_hash_h probs_a_microstate::nt_stack(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 7))
    {
      return LBRope_firstG_Bmfecovar_firstG_float_secondG_E_secondG_EMhdecl0x2777aa0_zero;
    }

  probs_a_microstate_hash_h answers;
  empty(answers);
  empty( answers);

  if (((t_0_j - t_0_i) >= 7))
    {
      if (basepair(t_0_seq, t_0_i, t_0_j))
      {
        TUSubsequence ret_3 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
        TUSubsequence a_2 = ret_3;
        if (is_not_empty(a_2))
        {
          TUSubsequence ret_1 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
          TUSubsequence a_0 = ret_1;
          if (is_not_empty(a_0))
          {
            probs_a_microstate_hash_h ret_2 = nt_weak((t_0_i + 1), (t_0_j - 1));
            probs_a_microstate_hash_h a_1 = ret_2;
            if (is_not_empty(a_1))
              {
                for (probs_a_microstate_hash_h::iterator x_1_itr = a_1.ref().begin(); x_1_itr!=a_1.ref().end(); ++x_1_itr){
                  std::pair<Rope, std::pair<mfecovar, double> >  x_1 = *x_1_itr;
                  std::pair<Rope, std::pair<mfecovar, double> >  ans = sr(a_0, x_1, a_2);
                  push_back( answers, ans);
                }
              }

            erase( a_1);
          }

          erase( a_0);
        }

        erase( a_2);
      }

      else
        {
          empty( answers);
        }

    }

  hash_filter( answers);
  finalize( answers);
  return answers;
}

probs_a_microstate_hash_h &  probs_a_microstate::nt_strong(unsigned int t_0_i, unsigned int t_0_j)
{
  if (strong_table.is_tabulated(t_0_i, t_0_j))
    {
      return strong_table.get(t_0_i, t_0_j);
    }

  probs_a_microstate_hash_h answers;
  empty(answers);
  empty( answers);


  if (allowLonelyBasepairs(t_0_seq, t_0_i, t_0_j, false))
  {
    probs_a_microstate_hash_h ret_1;
    empty(ret_1);
    if (((t_0_j - t_0_i) >= 7))
      {
        if (basepair(t_0_seq, t_0_i, t_0_j))
        {
          TUSubsequence ret_4 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
          TUSubsequence a_2 = ret_4;
          if (is_not_empty(a_2))
          {
            TUSubsequence ret_2 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
            TUSubsequence a_0 = ret_2;
            if (is_not_empty(a_0))
            {
              probs_a_microstate_hash_h ret_3 = nt_weak((t_0_i + 1), (t_0_j - 1));
              probs_a_microstate_hash_h a_1 = ret_3;
              if (is_not_empty(a_1))
                {
                  for (probs_a_microstate_hash_h::iterator x_1_itr = a_1.ref().begin(); x_1_itr!=a_1.ref().end(); ++x_1_itr){
                    std::pair<Rope, std::pair<mfecovar, double> >  x_1 = *x_1_itr;
                    std::pair<Rope, std::pair<mfecovar, double> >  ans = sr(a_0, x_1, a_2);
                    push_back( ret_1, ans);
                  }
                }

              erase( a_1);
            }

            erase( a_0);
          }

          erase( a_2);
        }

        else
          {
            empty( ret_1);
          }

      }

    finalize( ret_1);
    append( answers, ret_1);
  }



  if (allowLonelyBasepairs(t_0_seq, t_0_i, t_0_j, true))
  {
    probs_a_microstate_hash_h ret_6 = nt_weak(t_0_i, t_0_j);
    append( answers, ret_6);
  }

  hash_filter( answers);
  finalize( answers);
  strong_table.set( t_0_i, t_0_j, answers);
  return strong_table.get(t_0_i, t_0_j);
}

probs_a_microstate_hash_h &  probs_a_microstate::nt_struct(unsigned int t_0_i)
{
  if (struct_table.is_tabulated(t_0_i))
    {
      return struct_table.get(t_0_i);
    }

  probs_a_microstate_hash_h answers;
  empty(answers);
  empty( answers);

  if (((t_0_right_most - t_0_i) >= 1))
  {
    TUSubsequence ret_1;
    if (unpaired(t_0_seq, t_0_i, (t_0_i + 1)))
      {
        ret_1 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
      }

    else
      {
        empty( ret_1);
      }

    TUSubsequence a_0 = ret_1;
    if (is_not_empty(a_0))
    {
      probs_a_microstate_hash_h ret_2 = nt_struct((t_0_i + 1));
      probs_a_microstate_hash_h a_1 = ret_2;
      if (is_not_empty(a_1))
        {
          for (probs_a_microstate_hash_h::iterator x_1_itr = a_1.ref().begin(); x_1_itr!=a_1.ref().end(); ++x_1_itr){
            std::pair<Rope, std::pair<mfecovar, double> >  x_1 = *x_1_itr;
            std::pair<Rope, std::pair<mfecovar, double> >  ans = sadd(a_0, x_1);
            push_back( answers, ans);
          }
        }

      erase( a_1);
    }

    erase( a_0);
  }


  if (((t_0_right_most - t_0_i) >= 5))
    {
      for(      unsigned int t_0_k_0 = (t_0_i + 5); (t_0_k_0 <= t_0_right_most); ++t_0_k_0)
      {
        probs_a_microstate_hash_h ret_5 = nt_struct(t_0_k_0);
        probs_a_microstate_hash_h a_3 = ret_5;
        if (is_not_empty(a_3))
        {
          probs_a_microstate_hash_h ret_4 = nt_dangle(t_0_i, t_0_k_0);
          probs_a_microstate_hash_h a_2 = ret_4;
          if (is_not_empty(a_2))
            {
              for (probs_a_microstate_hash_h::iterator x_2_itr = a_2.ref().begin(); x_2_itr!=a_2.ref().end(); ++x_2_itr){
                std::pair<Rope, std::pair<mfecovar, double> >  x_2 = *x_2_itr;
                for (probs_a_microstate_hash_h::iterator x_3_itr = a_3.ref().begin(); x_3_itr!=a_3.ref().end(); ++x_3_itr){
                  std::pair<Rope, std::pair<mfecovar, double> >  x_3 = *x_3_itr;
                  std::pair<Rope, std::pair<mfecovar, double> >  ans = cadd(x_2, x_3);
                  push_back( answers, ans);
                }
              }
            }

          erase( a_2);
        }

        erase( a_3);
      }

    }

  std::pair<Rope, std::pair<mfecovar, double> >  ret_6;
  if ((((t_0_right_most - t_0_i) >= 0) && ((t_0_right_most - t_0_i) <= 0)))
  {
    TUSubsequence ret_7 = LOC(t_0_seq, t_0_i, t_0_i);
    TUSubsequence a_4 = ret_7;
    if (is_not_empty(a_4))
      {
        ret_6 = nil(a_4);
      }

    else
      {
        empty( ret_6);
      }

    erase( a_4);
  }

  else
    {
      empty( ret_6);
    }

  if (is_not_empty(ret_6))
    {
      push_back( answers, ret_6);
    }

  hash_filter( answers);
  finalize( answers);
  struct_table.set( t_0_i, answers);
  return struct_table.get(t_0_i);
}

probs_a_microstate_hash_h &  probs_a_microstate::nt_weak(unsigned int t_0_i, unsigned int t_0_j)
{
  if (weak_table.is_tabulated(t_0_i, t_0_j))
    {
      return weak_table.get(t_0_i, t_0_j);
    }

  probs_a_microstate_hash_h answers;
  empty(answers);
  empty( answers);


  probs_a_microstate_hash_h ret_1 = nt_stack(t_0_i, t_0_j);
  append( answers, ret_1);
  probs_a_microstate_hash_h ret_2 = nt_hairpin(t_0_i, t_0_j);
  append( answers, ret_2);
  probs_a_microstate_hash_h ret_3 = nt_leftB(t_0_i, t_0_j);
  append( answers, ret_3);
  probs_a_microstate_hash_h ret_4 = nt_rightB(t_0_i, t_0_j);
  append( answers, ret_4);
  probs_a_microstate_hash_h ret_5 = nt_iloop(t_0_i, t_0_j);
  append( answers, ret_5);
  probs_a_microstate_hash_h ret_6 = nt_multiloop(t_0_i, t_0_j);
  append( answers, ret_6);
  hash_filter( answers);
  finalize( answers);
  weak_table.set( t_0_i, t_0_j, answers);
  return weak_table.get(t_0_i, t_0_j);
}


std::pair<Rope, std::pair<mfecovar, double> >  probs_a_microstate::addss(const std::pair<Rope, std::pair<mfecovar, double> > & p_e, const TUSubsequence & p_rb)
{
  Rope l_0 = p_e.first;
  TUSubsequence l_1 = p_rb;
  std::pair<mfecovar, double>  r_0 = p_e.second;
  TUSubsequence r_1 = p_rb;
  Rope ret_left = addss_l(l_0, l_1);
  std::pair<mfecovar, double>  ret_right = addss_r(r_0, r_1);
  std::pair<Rope, std::pair<mfecovar, double> >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<Rope, std::pair<mfecovar, double> >  probs_a_microstate::bl(const TUSubsequence & p_lb, const TUSubsequence & p_lregion, const std::pair<Rope, std::pair<mfecovar, double> > & p_e, const TUSubsequence & p_rb)
{
  TUSubsequence l_0 = p_lb;
  TUSubsequence l_1 = p_lregion;
  Rope l_2 = p_e.first;
  TUSubsequence l_3 = p_rb;
  TUSubsequence r_0 = p_lb;
  TUSubsequence r_1 = p_lregion;
  std::pair<mfecovar, double>  r_2 = p_e.second;
  TUSubsequence r_3 = p_rb;
  Rope ret_left = bl_l(l_0, l_1, l_2, l_3);
  std::pair<mfecovar, double>  ret_right = bl_r(r_0, r_1, r_2, r_3);
  std::pair<Rope, std::pair<mfecovar, double> >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<Rope, std::pair<mfecovar, double> >  probs_a_microstate::br(const TUSubsequence & p_lb, const std::pair<Rope, std::pair<mfecovar, double> > & p_e, const TUSubsequence & p_rregion, const TUSubsequence & p_rb)
{
  TUSubsequence l_0 = p_lb;
  Rope l_1 = p_e.first;
  TUSubsequence l_2 = p_rregion;
  TUSubsequence l_3 = p_rb;
  TUSubsequence r_0 = p_lb;
  std::pair<mfecovar, double>  r_1 = p_e.second;
  TUSubsequence r_2 = p_rregion;
  TUSubsequence r_3 = p_rb;
  Rope ret_left = br_l(l_0, l_1, l_2, l_3);
  std::pair<mfecovar, double>  ret_right = br_r(r_0, r_1, r_2, r_3);
  std::pair<Rope, std::pair<mfecovar, double> >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<Rope, std::pair<mfecovar, double> >  probs_a_microstate::cadd(const std::pair<Rope, std::pair<mfecovar, double> > & p_le, const std::pair<Rope, std::pair<mfecovar, double> > & p_re)
{
  Rope l_0 = p_le.first;
  Rope l_1 = p_re.first;
  std::pair<mfecovar, double>  r_0 = p_le.second;
  std::pair<mfecovar, double>  r_1 = p_re.second;
  Rope ret_left = cadd_l(l_0, l_1);
  std::pair<mfecovar, double>  ret_right = cadd_r(r_0, r_1);
  std::pair<Rope, std::pair<mfecovar, double> >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<Rope, std::pair<mfecovar, double> >  probs_a_microstate::drem(const TUSubsequence & p_lloc, const std::pair<Rope, std::pair<mfecovar, double> > & p_e, const TUSubsequence & p_rloc)
{
  TUSubsequence l_0 = p_lloc;
  Rope l_1 = p_e.first;
  TUSubsequence l_2 = p_rloc;
  TUSubsequence r_0 = p_lloc;
  std::pair<mfecovar, double>  r_1 = p_e.second;
  TUSubsequence r_2 = p_rloc;
  Rope ret_left = drem_l(l_0, l_1, l_2);
  std::pair<mfecovar, double>  ret_right = drem_r(r_0, r_1, r_2);
  std::pair<Rope, std::pair<mfecovar, double> >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<Rope, std::pair<mfecovar, double> >  probs_a_microstate::edl(const TUSubsequence & p_lb, const std::pair<Rope, std::pair<mfecovar, double> > & p_e, const TUSubsequence & p_rloc)
{
  TUSubsequence l_0 = p_lb;
  Rope l_1 = p_e.first;
  TUSubsequence l_2 = p_rloc;
  TUSubsequence r_0 = p_lb;
  std::pair<mfecovar, double>  r_1 = p_e.second;
  TUSubsequence r_2 = p_rloc;
  Rope ret_left = edl_l(l_0, l_1, l_2);
  std::pair<mfecovar, double>  ret_right = edl_r(r_0, r_1, r_2);
  std::pair<Rope, std::pair<mfecovar, double> >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<Rope, std::pair<mfecovar, double> >  probs_a_microstate::edlr(const TUSubsequence & p_lb, const std::pair<Rope, std::pair<mfecovar, double> > & p_e, const TUSubsequence & p_rb)
{
  TUSubsequence l_0 = p_lb;
  Rope l_1 = p_e.first;
  TUSubsequence l_2 = p_rb;
  TUSubsequence r_0 = p_lb;
  std::pair<mfecovar, double>  r_1 = p_e.second;
  TUSubsequence r_2 = p_rb;
  Rope ret_left = edlr_l(l_0, l_1, l_2);
  std::pair<mfecovar, double>  ret_right = edlr_r(r_0, r_1, r_2);
  std::pair<Rope, std::pair<mfecovar, double> >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<Rope, std::pair<mfecovar, double> >  probs_a_microstate::edr(const TUSubsequence & p_lloc, const std::pair<Rope, std::pair<mfecovar, double> > & p_e, const TUSubsequence & p_rb)
{
  TUSubsequence l_0 = p_lloc;
  Rope l_1 = p_e.first;
  TUSubsequence l_2 = p_rb;
  TUSubsequence r_0 = p_lloc;
  std::pair<mfecovar, double>  r_1 = p_e.second;
  TUSubsequence r_2 = p_rb;
  Rope ret_left = edr_l(l_0, l_1, l_2);
  std::pair<mfecovar, double>  ret_right = edr_r(r_0, r_1, r_2);
  std::pair<Rope, std::pair<mfecovar, double> >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

template <typename Iterator>
probs_a_microstate_hash_h probs_a_microstate::h(std::pair<Iterator, Iterator> i)

{
  probs_a_microstate_hash_h answers;
  empty(answers);
  append_filter( answers, i);
  finalize( answers);
  return answers;
}

std::pair<Rope, std::pair<mfecovar, double> >  probs_a_microstate::hl(const TUSubsequence & p_lb, const TUSubsequence & p_region, const TUSubsequence & p_rb)
{
  TUSubsequence l_0 = p_lb;
  TUSubsequence l_1 = p_region;
  TUSubsequence l_2 = p_rb;
  TUSubsequence r_0 = p_lb;
  TUSubsequence r_1 = p_region;
  TUSubsequence r_2 = p_rb;
  Rope ret_left = hl_l(l_0, l_1, l_2);
  std::pair<mfecovar, double>  ret_right = hl_r(r_0, r_1, r_2);
  std::pair<Rope, std::pair<mfecovar, double> >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<Rope, std::pair<mfecovar, double> >  probs_a_microstate::il(const TUSubsequence & p_lb, const TUSubsequence & p_lregion, const std::pair<Rope, std::pair<mfecovar, double> > & p_e, const TUSubsequence & p_rregion, const TUSubsequence & p_rb)
{
  TUSubsequence l_0 = p_lb;
  TUSubsequence l_1 = p_lregion;
  Rope l_2 = p_e.first;
  TUSubsequence l_3 = p_rregion;
  TUSubsequence l_4 = p_rb;
  TUSubsequence r_0 = p_lb;
  TUSubsequence r_1 = p_lregion;
  std::pair<mfecovar, double>  r_2 = p_e.second;
  TUSubsequence r_3 = p_rregion;
  TUSubsequence r_4 = p_rb;
  Rope ret_left = il_l(l_0, l_1, l_2, l_3, l_4);
  std::pair<mfecovar, double>  ret_right = il_r(r_0, r_1, r_2, r_3, r_4);
  std::pair<Rope, std::pair<mfecovar, double> >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<Rope, std::pair<mfecovar, double> >  probs_a_microstate::incl(const std::pair<Rope, std::pair<mfecovar, double> > & p_e)
{
  Rope l_0 = p_e.first;
  std::pair<mfecovar, double>  r_0 = p_e.second;
  Rope ret_left = incl_l(l_0);
  std::pair<mfecovar, double>  ret_right = incl_r(r_0);
  std::pair<Rope, std::pair<mfecovar, double> >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<Rope, std::pair<mfecovar, double> >  probs_a_microstate::ml(const TUSubsequence & p_lb, const std::pair<Rope, std::pair<mfecovar, double> > & p_e, const TUSubsequence & p_rb)
{
  TUSubsequence l_0 = p_lb;
  Rope l_1 = p_e.first;
  TUSubsequence l_2 = p_rb;
  TUSubsequence r_0 = p_lb;
  std::pair<mfecovar, double>  r_1 = p_e.second;
  TUSubsequence r_2 = p_rb;
  Rope ret_left = ml_l(l_0, l_1, l_2);
  std::pair<mfecovar, double>  ret_right = ml_r(r_0, r_1, r_2);
  std::pair<Rope, std::pair<mfecovar, double> >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<Rope, std::pair<mfecovar, double> >  probs_a_microstate::mldl(const TUSubsequence & p_lb, const TUSubsequence & p_dl, const std::pair<Rope, std::pair<mfecovar, double> > & p_e, const TUSubsequence & p_rb)
{
  TUSubsequence l_0 = p_lb;
  TUSubsequence l_1 = p_dl;
  Rope l_2 = p_e.first;
  TUSubsequence l_3 = p_rb;
  TUSubsequence r_0 = p_lb;
  TUSubsequence r_1 = p_dl;
  std::pair<mfecovar, double>  r_2 = p_e.second;
  TUSubsequence r_3 = p_rb;
  Rope ret_left = mldl_l(l_0, l_1, l_2, l_3);
  std::pair<mfecovar, double>  ret_right = mldl_r(r_0, r_1, r_2, r_3);
  std::pair<Rope, std::pair<mfecovar, double> >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<Rope, std::pair<mfecovar, double> >  probs_a_microstate::mldlr(const TUSubsequence & p_lb, const TUSubsequence & p_dl, const std::pair<Rope, std::pair<mfecovar, double> > & p_e, const TUSubsequence & p_dr, const TUSubsequence & p_rb)
{
  TUSubsequence l_0 = p_lb;
  TUSubsequence l_1 = p_dl;
  Rope l_2 = p_e.first;
  TUSubsequence l_3 = p_dr;
  TUSubsequence l_4 = p_rb;
  TUSubsequence r_0 = p_lb;
  TUSubsequence r_1 = p_dl;
  std::pair<mfecovar, double>  r_2 = p_e.second;
  TUSubsequence r_3 = p_dr;
  TUSubsequence r_4 = p_rb;
  Rope ret_left = mldlr_l(l_0, l_1, l_2, l_3, l_4);
  std::pair<mfecovar, double>  ret_right = mldlr_r(r_0, r_1, r_2, r_3, r_4);
  std::pair<Rope, std::pair<mfecovar, double> >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<Rope, std::pair<mfecovar, double> >  probs_a_microstate::mldr(const TUSubsequence & p_lb, const std::pair<Rope, std::pair<mfecovar, double> > & p_e, const TUSubsequence & p_dr, const TUSubsequence & p_rb)
{
  TUSubsequence l_0 = p_lb;
  Rope l_1 = p_e.first;
  TUSubsequence l_2 = p_dr;
  TUSubsequence l_3 = p_rb;
  TUSubsequence r_0 = p_lb;
  std::pair<mfecovar, double>  r_1 = p_e.second;
  TUSubsequence r_2 = p_dr;
  TUSubsequence r_3 = p_rb;
  Rope ret_left = mldr_l(l_0, l_1, l_2, l_3);
  std::pair<mfecovar, double>  ret_right = mldr_r(r_0, r_1, r_2, r_3);
  std::pair<Rope, std::pair<mfecovar, double> >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<Rope, std::pair<mfecovar, double> >  probs_a_microstate::nil(const TUSubsequence & p_loc)
{
  TUSubsequence l_0 = p_loc;
  TUSubsequence r_0 = p_loc;
  Rope ret_left = nil_l(l_0);
  std::pair<mfecovar, double>  ret_right = nil_r(r_0);
  std::pair<Rope, std::pair<mfecovar, double> >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<Rope, std::pair<mfecovar, double> >  probs_a_microstate::sadd(const TUSubsequence & p_b, const std::pair<Rope, std::pair<mfecovar, double> > & p_e)
{
  TUSubsequence l_0 = p_b;
  Rope l_1 = p_e.first;
  TUSubsequence r_0 = p_b;
  std::pair<mfecovar, double>  r_1 = p_e.second;
  Rope ret_left = sadd_l(l_0, l_1);
  std::pair<mfecovar, double>  ret_right = sadd_r(r_0, r_1);
  std::pair<Rope, std::pair<mfecovar, double> >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<Rope, std::pair<mfecovar, double> >  probs_a_microstate::sr(const TUSubsequence & p_lb, const std::pair<Rope, std::pair<mfecovar, double> > & p_e, const TUSubsequence & p_rb)
{
  TUSubsequence l_0 = p_lb;
  Rope l_1 = p_e.first;
  TUSubsequence l_2 = p_rb;
  TUSubsequence r_0 = p_lb;
  std::pair<mfecovar, double>  r_1 = p_e.second;
  TUSubsequence r_2 = p_rb;
  Rope ret_left = sr_l(l_0, l_1, l_2);
  std::pair<mfecovar, double>  ret_right = sr_r(r_0, r_1, r_2);
  std::pair<Rope, std::pair<mfecovar, double> >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}



Rope probs_a_microstate::addss_l(const Rope & e, const TUSubsequence & rb)
{
#line 1050 "../../../ali_microstate.gap"
  return e;
#line 1634 "probs_a_microstate.cc"
}

Rope probs_a_microstate::bl_l(const TUSubsequence & lb, const TUSubsequence & lregion, const Rope & e, const TUSubsequence & rb)
{
#line 1437 "../../../ali_microstate.gap"
  Rope res;
  int pos;
  pos = ( ( ((lb.i + rb.j) + 1) )  / 2);
  if (((pos * 2) > ((lb.i + rb.j) + 1)))
    {
      pos = (pos - 1);
    }

  append( res, pos);
  if (((pos * 2) != ((lb.i + rb.j) + 1)))
    {
      append( res, ".5", 2);
    }

  append( res, 'b');
  append( res, ',');
  append( res, e);
  return res;
#line 1658 "probs_a_microstate.cc"
}

Rope probs_a_microstate::br_l(const TUSubsequence & lb, const Rope & e, const TUSubsequence & rregion, const TUSubsequence & rb)
{
#line 1450 "../../../ali_microstate.gap"
  Rope res;
  int pos;
  pos = ( ( ((lb.i + rb.j) + 1) )  / 2);
  if (((pos * 2) > ((lb.i + rb.j) + 1)))
    {
      pos = (pos - 1);
    }

  append( res, pos);
  if (((pos * 2) != ((lb.i + rb.j) + 1)))
    {
      append( res, ".5", 2);
    }

  append( res, 'b');
  append( res, ',');
  append( res, e);
  return res;
#line 1682 "probs_a_microstate.cc"
}

Rope probs_a_microstate::cadd_l(const Rope & le, const Rope & re)
{
#line 922 "../../../ali_microstate.gap"
  if ((re == "_"))
    {
      return le;
    }

  else
    {
      return (le + re);
    }

#line 1698 "probs_a_microstate.cc"
}

Rope probs_a_microstate::drem_l(const TUSubsequence & lloc, const Rope & e, const TUSubsequence & rloc)
{
#line 983 "../../../ali_microstate.gap"
  return e;
#line 1705 "probs_a_microstate.cc"
}

Rope probs_a_microstate::edl_l(const TUSubsequence & lb, const Rope & e, const TUSubsequence & rloc)
{
#line 971 "../../../ali_microstate.gap"
  return e;
#line 1712 "probs_a_microstate.cc"
}

Rope probs_a_microstate::edlr_l(const TUSubsequence & lb, const Rope & e, const TUSubsequence & rb)
{
#line 979 "../../../ali_microstate.gap"
  return e;
#line 1719 "probs_a_microstate.cc"
}

Rope probs_a_microstate::edr_l(const TUSubsequence & lloc, const Rope & e, const TUSubsequence & rb)
{
#line 975 "../../../ali_microstate.gap"
  return e;
#line 1726 "probs_a_microstate.cc"
}

Rope probs_a_microstate::hl_l(const TUSubsequence & lb, const TUSubsequence & region, const TUSubsequence & rb)
{
  Rope res;
  int pos;
  pos = ( ( ((lb.i + rb.j) + 1) )  / 2);
  if (((pos * 2) > ((lb.i + rb.j) + 1)))
    {
      pos = (pos - 1);
    }

  append( res, pos);
  if (((pos * 2) != ((lb.i + rb.j) + 1)))
    {
      append( res, ".5", 2);
    }

  append( res, ',');
  return res;
}

Rope probs_a_microstate::il_l(const TUSubsequence & lb, const TUSubsequence & lregion, const Rope & e, const TUSubsequence & rregion, const TUSubsequence & rb)
{
#line 1463 "../../../ali_microstate.gap"
  Rope res;
  int pos;
  pos = ( ( ((lb.i + rb.j) + 1) )  / 2);
  if (((pos * 2) > ((lb.i + rb.j) + 1)))
    {
      pos = (pos - 1);
    }

  append( res, pos);
  if (((pos * 2) != ((lb.i + rb.j) + 1)))
    {
      append( res, ".5", 2);
    }

  append( res, 'i');
  append( res, ',');
  append( res, e);
  return res;
#line 1770 "probs_a_microstate.cc"
}

Rope probs_a_microstate::incl_l(const Rope & e)
{
#line 1062 "../../../ali_microstate.gap"
  return e;
#line 1777 "probs_a_microstate.cc"
}

Rope probs_a_microstate::ml_l(const TUSubsequence & lb, const Rope & e, const TUSubsequence & rb)
{
  Rope res;
  int pos;
  pos = ( ( ((lb.i + rb.j) + 1) )  / 2);
  if (((pos * 2) > ((lb.i + rb.j) + 1)))
    {
      pos = (pos - 1);
    }

  append( res, pos);
  if (((pos * 2) != ((lb.i + rb.j) + 1)))
    {
      append( res, ".5", 2);
    }

  append( res, "m,(,", 4);
  append( res, e);
  append( res, "),", 2);
  return res;
}

Rope probs_a_microstate::mldl_l(const TUSubsequence & lb, const TUSubsequence & dl, const Rope & e, const TUSubsequence & rb)
{
  Rope res;
  int pos;
  pos = ( ( ((lb.i + rb.j) + 1) )  / 2);
  if (((pos * 2) > ((lb.i + rb.j) + 1)))
    {
      pos = (pos - 1);
    }

  append( res, pos);
  if (((pos * 2) != ((lb.i + rb.j) + 1)))
    {
      append( res, ".5", 2);
    }

  append( res, "m,(,", 4);
  append( res, e);
  append( res, "),", 2);
  return res;
}

Rope probs_a_microstate::mldlr_l(const TUSubsequence & lb, const TUSubsequence & dl, const Rope & e, const TUSubsequence & dr, const TUSubsequence & rb)
{
  Rope res;
  int pos;
  pos = ( ( ((lb.i + rb.j) + 1) )  / 2);
  if (((pos * 2) > ((lb.i + rb.j) + 1)))
    {
      pos = (pos - 1);
    }

  append( res, pos);
  if (((pos * 2) != ((lb.i + rb.j) + 1)))
    {
      append( res, ".5", 2);
    }

  append( res, "m,(,", 4);
  append( res, e);
  append( res, "),", 2);
  return res;
}

Rope probs_a_microstate::mldr_l(const TUSubsequence & lb, const Rope & e, const TUSubsequence & dr, const TUSubsequence & rb)
{
  Rope res;
  int pos;
  pos = ( ( ((lb.i + rb.j) + 1) )  / 2);
  if (((pos * 2) > ((lb.i + rb.j) + 1)))
    {
      pos = (pos - 1);
    }

  append( res, pos);
  if (((pos * 2) != ((lb.i + rb.j) + 1)))
    {
      append( res, ".5", 2);
    }

  append( res, "m,(,", 4);
  append( res, e);
  append( res, "),", 2);
  return res;
}

Rope probs_a_microstate::nil_l(const TUSubsequence & loc)
{
  Rope r;
  return r;
}

Rope probs_a_microstate::sadd_l(const TUSubsequence & b, const Rope & e)
{
  Rope emptyShape;
  Rope res;
  if ((e == emptyShape))
  {
    append( res, '_');
    append( res, e);
    return res;
  }

  else
    {
      return e;
    }

}

Rope probs_a_microstate::sr_l(const TUSubsequence & lb, const Rope & e, const TUSubsequence & rb)
{
#line 987 "../../../ali_microstate.gap"
  return e;
#line 1896 "probs_a_microstate.cc"
}



std::pair<mfecovar, double>  probs_a_microstate::addss_r(const std::pair<mfecovar, double> & p_x, const TUSubsequence & p_r)
{
  mfecovar l_0 = p_x.first;
  TUSubsequence l_1 = p_r;
  double r_0 = p_x.second;
  TUSubsequence r_1 = p_r;
  mfecovar ret_left = addss_r_l(l_0, l_1);
  double ret_right = addss_r_r(r_0, r_1);
  std::pair<mfecovar, double>  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<mfecovar, double>  probs_a_microstate::bl_r(const TUSubsequence & p_lb, const TUSubsequence & p_lr, const std::pair<mfecovar, double> & p_x, const TUSubsequence & p_rb)
{
  TUSubsequence l_0 = p_lb;
  TUSubsequence l_1 = p_lr;
  mfecovar l_2 = p_x.first;
  TUSubsequence l_3 = p_rb;
  TUSubsequence r_0 = p_lb;
  TUSubsequence r_1 = p_lr;
  double r_2 = p_x.second;
  TUSubsequence r_3 = p_rb;
  mfecovar ret_left = bl_r_l(l_0, l_1, l_2, l_3);
  double ret_right = bl_r_r(r_0, r_1, r_2, r_3);
  std::pair<mfecovar, double>  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<mfecovar, double>  probs_a_microstate::br_r(const TUSubsequence & p_lb, const std::pair<mfecovar, double> & p_x, const TUSubsequence & p_rr, const TUSubsequence & p_rb)
{
  TUSubsequence l_0 = p_lb;
  mfecovar l_1 = p_x.first;
  TUSubsequence l_2 = p_rr;
  TUSubsequence l_3 = p_rb;
  TUSubsequence r_0 = p_lb;
  double r_1 = p_x.second;
  TUSubsequence r_2 = p_rr;
  TUSubsequence r_3 = p_rb;
  mfecovar ret_left = br_r_l(l_0, l_1, l_2, l_3);
  double ret_right = br_r_r(r_0, r_1, r_2, r_3);
  std::pair<mfecovar, double>  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<mfecovar, double>  probs_a_microstate::cadd_r(const std::pair<mfecovar, double> & p_x, const std::pair<mfecovar, double> & p_y)
{
  mfecovar l_0 = p_x.first;
  mfecovar l_1 = p_y.first;
  double r_0 = p_x.second;
  double r_1 = p_y.second;
  mfecovar ret_left = cadd_r_l(l_0, l_1);
  double ret_right = cadd_r_r(r_0, r_1);
  std::pair<mfecovar, double>  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<mfecovar, double>  probs_a_microstate::drem_r(const TUSubsequence & p_lb, const std::pair<mfecovar, double> & p_x, const TUSubsequence & p_rb)
{
  TUSubsequence l_0 = p_lb;
  mfecovar l_1 = p_x.first;
  TUSubsequence l_2 = p_rb;
  TUSubsequence r_0 = p_lb;
  double r_1 = p_x.second;
  TUSubsequence r_2 = p_rb;
  mfecovar ret_left = drem_r_l(l_0, l_1, l_2);
  double ret_right = drem_r_r(r_0, r_1, r_2);
  std::pair<mfecovar, double>  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<mfecovar, double>  probs_a_microstate::edl_r(const TUSubsequence & p_ldangle, const std::pair<mfecovar, double> & p_x, const TUSubsequence & p_rb)
{
  TUSubsequence l_0 = p_ldangle;
  mfecovar l_1 = p_x.first;
  TUSubsequence l_2 = p_rb;
  TUSubsequence r_0 = p_ldangle;
  double r_1 = p_x.second;
  TUSubsequence r_2 = p_rb;
  mfecovar ret_left = edl_r_l(l_0, l_1, l_2);
  double ret_right = edl_r_r(r_0, r_1, r_2);
  std::pair<mfecovar, double>  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<mfecovar, double>  probs_a_microstate::edlr_r(const TUSubsequence & p_ldangle, const std::pair<mfecovar, double> & p_x, const TUSubsequence & p_rdangle)
{
  TUSubsequence l_0 = p_ldangle;
  mfecovar l_1 = p_x.first;
  TUSubsequence l_2 = p_rdangle;
  TUSubsequence r_0 = p_ldangle;
  double r_1 = p_x.second;
  TUSubsequence r_2 = p_rdangle;
  mfecovar ret_left = edlr_r_l(l_0, l_1, l_2);
  double ret_right = edlr_r_r(r_0, r_1, r_2);
  std::pair<mfecovar, double>  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<mfecovar, double>  probs_a_microstate::edr_r(const TUSubsequence & p_lb, const std::pair<mfecovar, double> & p_x, const TUSubsequence & p_rdangle)
{
  TUSubsequence l_0 = p_lb;
  mfecovar l_1 = p_x.first;
  TUSubsequence l_2 = p_rdangle;
  TUSubsequence r_0 = p_lb;
  double r_1 = p_x.second;
  TUSubsequence r_2 = p_rdangle;
  mfecovar ret_left = edr_r_l(l_0, l_1, l_2);
  double ret_right = edr_r_r(r_0, r_1, r_2);
  std::pair<mfecovar, double>  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<mfecovar, double>  probs_a_microstate::hl_r(const TUSubsequence & p_lb, const TUSubsequence & p_r, const TUSubsequence & p_rb)
{
  TUSubsequence l_0 = p_lb;
  TUSubsequence l_1 = p_r;
  TUSubsequence l_2 = p_rb;
  TUSubsequence r_0 = p_lb;
  TUSubsequence r_1 = p_r;
  TUSubsequence r_2 = p_rb;
  mfecovar ret_left = hl_r_l(l_0, l_1, l_2);
  double ret_right = hl_r_r(r_0, r_1, r_2);
  std::pair<mfecovar, double>  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<mfecovar, double>  probs_a_microstate::il_r(const TUSubsequence & p_lb, const TUSubsequence & p_lr, const std::pair<mfecovar, double> & p_x, const TUSubsequence & p_rr, const TUSubsequence & p_rb)
{
  TUSubsequence l_0 = p_lb;
  TUSubsequence l_1 = p_lr;
  mfecovar l_2 = p_x.first;
  TUSubsequence l_3 = p_rr;
  TUSubsequence l_4 = p_rb;
  TUSubsequence r_0 = p_lb;
  TUSubsequence r_1 = p_lr;
  double r_2 = p_x.second;
  TUSubsequence r_3 = p_rr;
  TUSubsequence r_4 = p_rb;
  mfecovar ret_left = il_r_l(l_0, l_1, l_2, l_3, l_4);
  double ret_right = il_r_r(r_0, r_1, r_2, r_3, r_4);
  std::pair<mfecovar, double>  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<mfecovar, double>  probs_a_microstate::incl_r(const std::pair<mfecovar, double> & p_x)
{
  mfecovar l_0 = p_x.first;
  double r_0 = p_x.second;
  mfecovar ret_left = incl_r_l(l_0);
  double ret_right = incl_r_r(r_0);
  std::pair<mfecovar, double>  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<mfecovar, double>  probs_a_microstate::ml_r(const TUSubsequence & p_lb, const std::pair<mfecovar, double> & p_x, const TUSubsequence & p_rb)
{
  TUSubsequence l_0 = p_lb;
  mfecovar l_1 = p_x.first;
  TUSubsequence l_2 = p_rb;
  TUSubsequence r_0 = p_lb;
  double r_1 = p_x.second;
  TUSubsequence r_2 = p_rb;
  mfecovar ret_left = ml_r_l(l_0, l_1, l_2);
  double ret_right = ml_r_r(r_0, r_1, r_2);
  std::pair<mfecovar, double>  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<mfecovar, double>  probs_a_microstate::mldl_r(const TUSubsequence & p_lb, const TUSubsequence & p_dl, const std::pair<mfecovar, double> & p_x, const TUSubsequence & p_rb)
{
  TUSubsequence l_0 = p_lb;
  TUSubsequence l_1 = p_dl;
  mfecovar l_2 = p_x.first;
  TUSubsequence l_3 = p_rb;
  TUSubsequence r_0 = p_lb;
  TUSubsequence r_1 = p_dl;
  double r_2 = p_x.second;
  TUSubsequence r_3 = p_rb;
  mfecovar ret_left = mldl_r_l(l_0, l_1, l_2, l_3);
  double ret_right = mldl_r_r(r_0, r_1, r_2, r_3);
  std::pair<mfecovar, double>  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<mfecovar, double>  probs_a_microstate::mldlr_r(const TUSubsequence & p_lb, const TUSubsequence & p_dl, const std::pair<mfecovar, double> & p_x, const TUSubsequence & p_dr, const TUSubsequence & p_rb)
{
  TUSubsequence l_0 = p_lb;
  TUSubsequence l_1 = p_dl;
  mfecovar l_2 = p_x.first;
  TUSubsequence l_3 = p_dr;
  TUSubsequence l_4 = p_rb;
  TUSubsequence r_0 = p_lb;
  TUSubsequence r_1 = p_dl;
  double r_2 = p_x.second;
  TUSubsequence r_3 = p_dr;
  TUSubsequence r_4 = p_rb;
  mfecovar ret_left = mldlr_r_l(l_0, l_1, l_2, l_3, l_4);
  double ret_right = mldlr_r_r(r_0, r_1, r_2, r_3, r_4);
  std::pair<mfecovar, double>  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<mfecovar, double>  probs_a_microstate::mldr_r(const TUSubsequence & p_lb, const std::pair<mfecovar, double> & p_x, const TUSubsequence & p_dr, const TUSubsequence & p_rb)
{
  TUSubsequence l_0 = p_lb;
  mfecovar l_1 = p_x.first;
  TUSubsequence l_2 = p_dr;
  TUSubsequence l_3 = p_rb;
  TUSubsequence r_0 = p_lb;
  double r_1 = p_x.second;
  TUSubsequence r_2 = p_dr;
  TUSubsequence r_3 = p_rb;
  mfecovar ret_left = mldr_r_l(l_0, l_1, l_2, l_3);
  double ret_right = mldr_r_r(r_0, r_1, r_2, r_3);
  std::pair<mfecovar, double>  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<mfecovar, double>  probs_a_microstate::nil_r(const TUSubsequence & p_n)
{
  TUSubsequence l_0 = p_n;
  TUSubsequence r_0 = p_n;
  mfecovar ret_left = nil_r_l(l_0);
  double ret_right = nil_r_r(r_0);
  std::pair<mfecovar, double>  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<mfecovar, double>  probs_a_microstate::sadd_r(const TUSubsequence & p_lb, const std::pair<mfecovar, double> & p_x)
{
  TUSubsequence l_0 = p_lb;
  mfecovar l_1 = p_x.first;
  TUSubsequence r_0 = p_lb;
  double r_1 = p_x.second;
  mfecovar ret_left = sadd_r_l(l_0, l_1);
  double ret_right = sadd_r_r(r_0, r_1);
  std::pair<mfecovar, double>  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<mfecovar, double>  probs_a_microstate::sr_r(const TUSubsequence & p_lb, const std::pair<mfecovar, double> & p_x, const TUSubsequence & p_rb)
{
  TUSubsequence l_0 = p_lb;
  mfecovar l_1 = p_x.first;
  TUSubsequence l_2 = p_rb;
  TUSubsequence r_0 = p_lb;
  double r_1 = p_x.second;
  TUSubsequence r_2 = p_rb;
  mfecovar ret_left = sr_r_l(l_0, l_1, l_2);
  double ret_right = sr_r_r(r_0, r_1, r_2);
  std::pair<mfecovar, double>  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}



mfecovar probs_a_microstate::addss_r_l(const mfecovar & x, const TUSubsequence & r)
{
#line 2229 "../../../ali_microstate.gap"
  mfecovar res = x;
  res.mfe = (res.mfe +  ( (ss_energy(r) / float(rows(r))) ) );
  return res;
#line 2199 "probs_a_microstate.cc"
}

mfecovar probs_a_microstate::bl_r_l(const TUSubsequence & lb, const TUSubsequence & lr, const mfecovar & x, const TUSubsequence & rb)
{
#line 2165 "../../../ali_microstate.gap"
  mfecovar res = x;
  res.mfe = (res.mfe +  ( (bl_energy(lr, rb) / float(rows(lb))) ) );
  res.covar = (res.covar + covscore(lb, lb.i, rb.i));
  return res;
#line 2209 "probs_a_microstate.cc"
}

mfecovar probs_a_microstate::br_r_l(const TUSubsequence & lb, const mfecovar & x, const TUSubsequence & rr, const TUSubsequence & rb)
{
#line 2173 "../../../ali_microstate.gap"
  mfecovar res = x;
  res.mfe = (res.mfe +  ( (br_energy(lb, rr) / float(rows(lb))) ) );
  res.covar = (res.covar + covscore(lb, lb.i, rb.i));
  return res;
#line 2219 "probs_a_microstate.cc"
}

mfecovar probs_a_microstate::cadd_r_l(const mfecovar & x, const mfecovar & y)
{
#line 2110 "../../../ali_microstate.gap"
  return  ( (x + y) ) ;
#line 2226 "probs_a_microstate.cc"
}

mfecovar probs_a_microstate::drem_r_l(const TUSubsequence & lb, const mfecovar & x, const TUSubsequence & rb)
{
#line 2142 "../../../ali_microstate.gap"
  mfecovar res = x;
  res.mfe = (res.mfe +  ( (termau_energy(lb, rb) / float(rows(lb))) ) );
  return res;
#line 2235 "probs_a_microstate.cc"
}

mfecovar probs_a_microstate::edl_r_l(const TUSubsequence & ldangle, const mfecovar & x, const TUSubsequence & rb)
{
#line 2113 "../../../ali_microstate.gap"
  mfecovar res = x;
  TUSubsequence lb = ldangle;
  lb.i = (ldangle.i + 1);
  res.mfe = (res.mfe +  ( ( ( (termau_energy(lb, rb) + dl_energy(lb, rb)) )  / float(rows(ldangle))) ) );
  return res;
#line 2246 "probs_a_microstate.cc"
}

mfecovar probs_a_microstate::edlr_r_l(const TUSubsequence & ldangle, const mfecovar & x, const TUSubsequence & rdangle)
{
#line 2131 "../../../ali_microstate.gap"
  mfecovar res = x;
  TUSubsequence lb = ldangle;
  lb.i = (ldangle.i + 1);
  TUSubsequence rb = rdangle;
  rb.j = (rdangle.j - 1);
  res.mfe = (res.mfe +  ( ( ( (termau_energy(lb, rb) + ext_mismatch_energy(lb, rb)) )  / float(rows(ldangle))) ) );
  return res;
#line 2259 "probs_a_microstate.cc"
}

mfecovar probs_a_microstate::edr_r_l(const TUSubsequence & lb, const mfecovar & x, const TUSubsequence & rdangle)
{
#line 2122 "../../../ali_microstate.gap"
  mfecovar res = x;
  TUSubsequence rb = rdangle;
  rb.j = (rdangle.j - 1);
  res.mfe = (res.mfe +  ( ( ( (termau_energy(lb, rb) + dr_energy(lb, rb)) )  / float(rows(lb))) ) );
  return res;
#line 2270 "probs_a_microstate.cc"
}

mfecovar probs_a_microstate::hl_r_l(const TUSubsequence & lb, const TUSubsequence & r, const TUSubsequence & rb)
{
#line 2157 "../../../ali_microstate.gap"
  mfecovar res;
  res.mfe =  ( (hl_energy(r) / float(rows(r))) ) ;
  res.covar = covscore(lb, lb.i, rb.i);
  return res;
#line 2280 "probs_a_microstate.cc"
}

mfecovar probs_a_microstate::il_r_l(const TUSubsequence & lb, const TUSubsequence & lr, const mfecovar & x, const TUSubsequence & rr, const TUSubsequence & rb)
{
#line 2181 "../../../ali_microstate.gap"
  mfecovar res = x;
  res.mfe = (res.mfe +  ( (il_energy(lr, rr) / float(rows(lr))) ) );
  res.covar = (res.covar + covscore(lb, lb.i, rb.i));
  return res;
#line 2290 "probs_a_microstate.cc"
}

mfecovar probs_a_microstate::incl_r_l(const mfecovar & x)
{
#line 2222 "../../../ali_microstate.gap"
  mfecovar res = x;
  res.mfe = (res.mfe + ul_energy());
  return res;
#line 2299 "probs_a_microstate.cc"
}

mfecovar probs_a_microstate::ml_r_l(const TUSubsequence & lb, const mfecovar & x, const TUSubsequence & rb)
{
#line 2214 "../../../ali_microstate.gap"
  mfecovar res = x;
  res.mfe = (((res.mfe + ml_energy()) + ul_energy()) +  ( (termau_energy(lb, rb) / float(rows(lb))) ) );
  res.covar = (res.covar + covscore(lb, lb.i, rb.i));
  return res;
#line 2309 "probs_a_microstate.cc"
}

mfecovar probs_a_microstate::mldl_r_l(const TUSubsequence & lb, const TUSubsequence & dl, const mfecovar & x, const TUSubsequence & rb)
{
#line 2190 "../../../ali_microstate.gap"
  mfecovar res = x;
  res.mfe = (((res.mfe + ml_energy()) + ul_energy()) +  ( ( ( (termau_energy(lb, rb) + dli_energy(lb, rb)) )  / float(rows(lb))) ) );
  res.covar = (res.covar + covscore(lb, lb.i, rb.i));
  return res;
#line 2319 "probs_a_microstate.cc"
}

mfecovar probs_a_microstate::mldlr_r_l(const TUSubsequence & lb, const TUSubsequence & dl, const mfecovar & x, const TUSubsequence & dr, const TUSubsequence & rb)
{
#line 2206 "../../../ali_microstate.gap"
  mfecovar res = x;
  res.mfe = (((res.mfe + ml_energy()) + ul_energy()) +  ( ( ( (termau_energy(lb, rb) + ml_mismatch_energy(lb, rb)) )  / float(rows(lb))) ) );
  res.covar = (res.covar + covscore(lb, lb.i, rb.i));
  return res;
#line 2329 "probs_a_microstate.cc"
}

mfecovar probs_a_microstate::mldr_r_l(const TUSubsequence & lb, const mfecovar & x, const TUSubsequence & dr, const TUSubsequence & rb)
{
#line 2198 "../../../ali_microstate.gap"
  mfecovar res = x;
  res.mfe = (((res.mfe + ml_energy()) + ul_energy()) +  ( ( ( (termau_energy(lb, rb) + dri_energy(lb, rb)) )  / float(rows(lb))) ) );
  res.covar = (res.covar + covscore(lb, lb.i, rb.i));
  return res;
#line 2339 "probs_a_microstate.cc"
}

mfecovar probs_a_microstate::nil_r_l(const TUSubsequence & n)
{
#line 2236 "../../../ali_microstate.gap"
  mfecovar res;
  res.mfe = 0;
  res.covar = 0;
  return res;
#line 2349 "probs_a_microstate.cc"
}

mfecovar probs_a_microstate::sadd_r_l(const TUSubsequence & lb, const mfecovar & x)
{
#line 2097 "../../../ali_microstate.gap"
  mfecovar res = x;
  int sbase_sum = 0;
  for(  int k = 0; (k < int(rows(lb)));   k = (k + 1))
  {
    if ((column(seq_char(lb, lb.i), k) != GAP_BASE))
      {
        sbase_sum = (sbase_sum + sbase_energy());
      }

  }

  res.mfe = (res.mfe +  ( (sbase_sum / float(rows(lb))) ) );
  return res;
#line 2368 "probs_a_microstate.cc"
}

mfecovar probs_a_microstate::sr_r_l(const TUSubsequence & lb, const mfecovar & x, const TUSubsequence & rb)
{
#line 2149 "../../../ali_microstate.gap"
  mfecovar res = x;
  res.mfe = (res.mfe +  ( (sr_energy(lb, rb) / float(rows(lb))) ) );
  res.covar = (res.covar + covscore(lb, lb.i, rb.i));
  return res;
#line 2378 "probs_a_microstate.cc"
}



double probs_a_microstate::addss_r_r(double x, const TUSubsequence & r)
{
#line 1800 "../../../ali_microstate.gap"
  return ((x * scale((r.j - r.i))) * mk_pf((ss_energy(r) / float(rows(r)))));
#line 2387 "probs_a_microstate.cc"
}

double probs_a_microstate::bl_r_r(const TUSubsequence & lb, const TUSubsequence & lr, double x, const TUSubsequence & rb)
{
#line 1775 "../../../ali_microstate.gap"
  return ((x * scale(((2 + lr.j) - lr.i))) * mk_pf(((bl_energy(lr, rb) / float(rows(lb))) + covscore(lb, lb.i, rb.i))));
#line 2394 "probs_a_microstate.cc"
}

double probs_a_microstate::br_r_r(const TUSubsequence & lb, double x, const TUSubsequence & rr, const TUSubsequence & rb)
{
#line 1778 "../../../ali_microstate.gap"
  return ((x * scale(((2 + rr.j) - rr.i))) * mk_pf(((br_energy(lb, rr) / float(rows(lb))) + covscore(lb, lb.i, rb.i))));
#line 2401 "probs_a_microstate.cc"
}

double probs_a_microstate::cadd_r_r(double x, double y)
{
#line 1743 "../../../ali_microstate.gap"
  return (x * y);
#line 2408 "probs_a_microstate.cc"
}

double probs_a_microstate::drem_r_r(const TUSubsequence & lb, double x, const TUSubsequence & rb)
{
#line 1766 "../../../ali_microstate.gap"
  return (x * mk_pf((termau_energy(lb, rb) / float(rows(lb)))));
#line 2415 "probs_a_microstate.cc"
}

double probs_a_microstate::edl_r_r(const TUSubsequence & ldangle, double x, const TUSubsequence & rb)
{
#line 1746 "../../../ali_microstate.gap"
  TUSubsequence lb = ldangle;
  lb.i = (ldangle.i + 1);
  return ((x * scale(1)) * mk_pf(( ( (termau_energy(lb, rb) + dl_energy(lb, rb)) )  / float(rows(ldangle)))));
#line 2424 "probs_a_microstate.cc"
}

double probs_a_microstate::edlr_r_r(const TUSubsequence & ldangle, double x, const TUSubsequence & rdangle)
{
#line 1758 "../../../ali_microstate.gap"
  TUSubsequence lb = ldangle;
  lb.i = (ldangle.i + 1);
  TUSubsequence rb = rdangle;
  rb.j = (rdangle.j - 1);
  return ((x * scale(2)) * mk_pf(( ( (termau_energy(lb, rb) + ext_mismatch_energy(lb, rb)) )  / float(rows(ldangle)))));
#line 2435 "probs_a_microstate.cc"
}

double probs_a_microstate::edr_r_r(const TUSubsequence & lb, double x, const TUSubsequence & rdangle)
{
#line 1752 "../../../ali_microstate.gap"
  TUSubsequence rb = rdangle;
  rb.j = (rdangle.j - 1);
  return ((x * scale(1)) * mk_pf(( ( (termau_energy(lb, rb) + dr_energy(lb, rb)) )  / float(rows(lb)))));
#line 2444 "probs_a_microstate.cc"
}

double probs_a_microstate::hl_r_r(const TUSubsequence & lb, const TUSubsequence & r, const TUSubsequence & rb)
{
#line 1772 "../../../ali_microstate.gap"
  return (scale(((2 + r.j) - r.i)) * mk_pf((int((hl_energy(r) / float(rows(r)))) + covscore(lb, lb.i, rb.i))));
#line 2451 "probs_a_microstate.cc"
}

double probs_a_microstate::il_r_r(const TUSubsequence & lb, const TUSubsequence & lr, double x, const TUSubsequence & rr, const TUSubsequence & rb)
{
#line 1781 "../../../ali_microstate.gap"
  return ((x * scale(((((2 + lr.j) - lr.i) + rr.j) - rr.i))) * mk_pf(((il_energy(lr, rr) / float(rows(lr))) + covscore(lb, lb.i, rb.i))));
#line 2458 "probs_a_microstate.cc"
}

double probs_a_microstate::incl_r_r(double x)
{
#line 1797 "../../../ali_microstate.gap"
  return (x * mk_pf(ul_energy()));
#line 2465 "probs_a_microstate.cc"
}

double probs_a_microstate::ml_r_r(const TUSubsequence & lb, double x, const TUSubsequence & rb)
{
#line 1794 "../../../ali_microstate.gap"
  return ((x * scale(2)) * mk_pf((((ml_energy() + ul_energy()) +  ( (termau_energy(lb, rb) / float(rows(lb))) ) ) + covscore(lb, lb.i, rb.i))));
#line 2472 "probs_a_microstate.cc"
}

double probs_a_microstate::mldl_r_r(const TUSubsequence & lb, const TUSubsequence & dl, double x, const TUSubsequence & rb)
{
#line 1785 "../../../ali_microstate.gap"
  return ((x * scale(3)) * mk_pf((((ml_energy() + ul_energy()) +  ( ( ( (termau_energy(lb, rb) + dli_energy(lb, rb)) )  / float(rows(lb))) ) ) + covscore(lb, lb.i, rb.i))));
#line 2479 "probs_a_microstate.cc"
}

double probs_a_microstate::mldlr_r_r(const TUSubsequence & lb, const TUSubsequence & dl, double x, const TUSubsequence & dr, const TUSubsequence & rb)
{
#line 1791 "../../../ali_microstate.gap"
  return ((x * scale(4)) * mk_pf((((ml_energy() + ul_energy()) +  ( ( ( (termau_energy(lb, rb) + ml_mismatch_energy(lb, rb)) )  / float(rows(lb))) ) ) + covscore(lb, lb.i, rb.i))));
#line 2486 "probs_a_microstate.cc"
}

double probs_a_microstate::mldr_r_r(const TUSubsequence & lb, double x, const TUSubsequence & dr, const TUSubsequence & rb)
{
#line 1788 "../../../ali_microstate.gap"
  return ((x * scale(3)) * mk_pf((((ml_energy() + ul_energy()) +  ( ( ( (termau_energy(lb, rb) + dri_energy(lb, rb)) )  / float(rows(lb))) ) ) + covscore(lb, lb.i, rb.i))));
#line 2493 "probs_a_microstate.cc"
}

double probs_a_microstate::nil_r_r(const TUSubsequence & n)
{
#line 1803 "../../../ali_microstate.gap"
  return 1.000000e+00;
#line 2500 "probs_a_microstate.cc"
}

double probs_a_microstate::sadd_r_r(const TUSubsequence & lb, double x)
{
#line 1734 "../../../ali_microstate.gap"
  double sbase_sum = 0;
  for(  int k = 0; (k < int(rows(lb)));   k = (k + 1))
  {
    if ((column(seq_char(lb, lb.i), k) != GAP_BASE))
      {
        sbase_sum = (sbase_sum + sbase_energy());
      }

  }

  return ((x * scale(1)) * mk_pf((sbase_sum / float(rows(lb)))));
#line 2517 "probs_a_microstate.cc"
}

double probs_a_microstate::sr_r_r(const TUSubsequence & lb, double x, const TUSubsequence & rb)
{
#line 1769 "../../../ali_microstate.gap"
  return ((x * scale(2)) * mk_pf((int((sr_energy(lb, rb) / float(rows(lb)))) + covscore(lb, lb.i, rb.i))));
#line 2524 "probs_a_microstate.cc"
}


    void probs_a_microstate::cyk()
{

}



#ident "$Id: Compiled with gapc bellmansgapc-2013.05.02 $"

List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > probs_a_microstate::bt_proxy_nt_struct(unsigned int t_0_i)
{
  List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > l;
  empty(l);
  probs_a_microstate_hash_h ret = nt_struct(t_0_i);
  if (isEmpty(ret))
    {
      return l;
    }

  intrusive_ptr<Backtrace_nt_struct_Back<probs_a_microstate, std::pair<String, double> , unsigned int>  >  bt = new Backtrace_nt_struct_Back<probs_a_microstate, std::pair<String, double> , unsigned int> (this, t_0_i);
  for (probs_a_microstate_hash_h::iterator elem_itr = ret.ref().begin(); elem_itr!=ret.ref().end(); ++elem_itr){
    std::pair<Rope, std::pair<mfecovar, double> >  elem = *elem_itr;
    std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  tupel;
    tupel.first = elem;
    tupel.second = new Backtrace_nt_struct_Front<std::pair<String, double> , unsigned int> (bt);
    set_value( tupel);
    push_back( l, tupel);
  }
  return l;
}

List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > probs_a_microstate::bt_proxy_nt_dangle(unsigned int t_0_i, unsigned int t_0_j)
{
  List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > l;
  empty(l);
  probs_a_microstate_hash_h ret = nt_dangle(t_0_i, t_0_j);
  if (isEmpty(ret))
    {
      return l;
    }

  intrusive_ptr<Backtrace_nt_dangle_Back<probs_a_microstate, std::pair<String, double> , unsigned int>  >  bt = new Backtrace_nt_dangle_Back<probs_a_microstate, std::pair<String, double> , unsigned int> (this, t_0_i, t_0_j);
  for (probs_a_microstate_hash_h::iterator elem_itr = ret.ref().begin(); elem_itr!=ret.ref().end(); ++elem_itr){
    std::pair<Rope, std::pair<mfecovar, double> >  elem = *elem_itr;
    std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  tupel;
    tupel.first = elem;
    tupel.second = new Backtrace_nt_dangle_Front<std::pair<String, double> , unsigned int> (bt);
    set_value( tupel);
    push_back( l, tupel);
  }
  return l;
}

List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > probs_a_microstate::bt_proxy_nt_strong(unsigned int t_0_i, unsigned int t_0_j)
{
  List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > l;
  empty(l);
  probs_a_microstate_hash_h ret = nt_strong(t_0_i, t_0_j);
  if (isEmpty(ret))
    {
      return l;
    }

  intrusive_ptr<Backtrace_nt_strong_Back<probs_a_microstate, std::pair<String, double> , unsigned int>  >  bt = new Backtrace_nt_strong_Back<probs_a_microstate, std::pair<String, double> , unsigned int> (this, t_0_i, t_0_j);
  for (probs_a_microstate_hash_h::iterator elem_itr = ret.ref().begin(); elem_itr!=ret.ref().end(); ++elem_itr){
    std::pair<Rope, std::pair<mfecovar, double> >  elem = *elem_itr;
    std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  tupel;
    tupel.first = elem;
    tupel.second = new Backtrace_nt_strong_Front<std::pair<String, double> , unsigned int> (bt);
    set_value( tupel);
    push_back( l, tupel);
  }
  return l;
}

List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > probs_a_microstate::bt_proxy_nt_weak(unsigned int t_0_i, unsigned int t_0_j)
{
  List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > l;
  empty(l);
  probs_a_microstate_hash_h ret = nt_weak(t_0_i, t_0_j);
  if (isEmpty(ret))
    {
      return l;
    }

  intrusive_ptr<Backtrace_nt_weak_Back<probs_a_microstate, std::pair<String, double> , unsigned int>  >  bt = new Backtrace_nt_weak_Back<probs_a_microstate, std::pair<String, double> , unsigned int> (this, t_0_i, t_0_j);
  for (probs_a_microstate_hash_h::iterator elem_itr = ret.ref().begin(); elem_itr!=ret.ref().end(); ++elem_itr){
    std::pair<Rope, std::pair<mfecovar, double> >  elem = *elem_itr;
    std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  tupel;
    tupel.first = elem;
    tupel.second = new Backtrace_nt_weak_Front<std::pair<String, double> , unsigned int> (bt);
    set_value( tupel);
    push_back( l, tupel);
  }
  return l;
}

List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > probs_a_microstate::bt_proxy_nt_stack(unsigned int t_0_i, unsigned int t_0_j)
{
  List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > l;
  empty(l);
  probs_a_microstate_hash_h ret = nt_stack(t_0_i, t_0_j);
  if (isEmpty(ret))
    {
      return l;
    }

  intrusive_ptr<Backtrace_nt_stack_Back<probs_a_microstate, std::pair<String, double> , unsigned int>  >  bt = new Backtrace_nt_stack_Back<probs_a_microstate, std::pair<String, double> , unsigned int> (this, t_0_i, t_0_j);
  for (probs_a_microstate_hash_h::iterator elem_itr = ret.ref().begin(); elem_itr!=ret.ref().end(); ++elem_itr){
    std::pair<Rope, std::pair<mfecovar, double> >  elem = *elem_itr;
    std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  tupel;
    tupel.first = elem;
    tupel.second = new Backtrace_nt_stack_Front<std::pair<String, double> , unsigned int> (bt);
    set_value( tupel);
    push_back( l, tupel);
  }
  return l;
}

std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  probs_a_microstate::bt_proxy_nt_hairpin(unsigned int t_0_i, unsigned int t_0_j)
{
  std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  l;
  probs_a_microstate_hash_h ret = nt_hairpin(t_0_i, t_0_j);
  if (isEmpty(ret))
  {
    empty( l);
    return l;
  }

  intrusive_ptr<Backtrace_nt_hairpin_Back<probs_a_microstate, std::pair<String, double> , unsigned int>  >  bt = new Backtrace_nt_hairpin_Back<probs_a_microstate, std::pair<String, double> , unsigned int> (this, t_0_i, t_0_j);
  for (probs_a_microstate_hash_h::iterator elem_itr = ret.ref().begin(); elem_itr!=ret.ref().end(); ++elem_itr){
    std::pair<Rope, std::pair<mfecovar, double> >  elem = *elem_itr;
    l.first = elem;
    l.second = new Backtrace_nt_hairpin_Front<std::pair<String, double> , unsigned int> (bt);
    set_value( l);
  }
  return l;
}

List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > probs_a_microstate::bt_proxy_nt_leftB(unsigned int t_0_i, unsigned int t_0_j)
{
  List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > l;
  empty(l);
  probs_a_microstate_hash_h ret = nt_leftB(t_0_i, t_0_j);
  if (isEmpty(ret))
    {
      return l;
    }

  intrusive_ptr<Backtrace_nt_leftB_Back<probs_a_microstate, std::pair<String, double> , unsigned int>  >  bt = new Backtrace_nt_leftB_Back<probs_a_microstate, std::pair<String, double> , unsigned int> (this, t_0_i, t_0_j);
  for (probs_a_microstate_hash_h::iterator elem_itr = ret.ref().begin(); elem_itr!=ret.ref().end(); ++elem_itr){
    std::pair<Rope, std::pair<mfecovar, double> >  elem = *elem_itr;
    std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  tupel;
    tupel.first = elem;
    tupel.second = new Backtrace_nt_leftB_Front<std::pair<String, double> , unsigned int> (bt);
    set_value( tupel);
    push_back( l, tupel);
  }
  return l;
}

List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > probs_a_microstate::bt_proxy_nt_rightB(unsigned int t_0_i, unsigned int t_0_j)
{
  List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > l;
  empty(l);
  probs_a_microstate_hash_h ret = nt_rightB(t_0_i, t_0_j);
  if (isEmpty(ret))
    {
      return l;
    }

  intrusive_ptr<Backtrace_nt_rightB_Back<probs_a_microstate, std::pair<String, double> , unsigned int>  >  bt = new Backtrace_nt_rightB_Back<probs_a_microstate, std::pair<String, double> , unsigned int> (this, t_0_i, t_0_j);
  for (probs_a_microstate_hash_h::iterator elem_itr = ret.ref().begin(); elem_itr!=ret.ref().end(); ++elem_itr){
    std::pair<Rope, std::pair<mfecovar, double> >  elem = *elem_itr;
    std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  tupel;
    tupel.first = elem;
    tupel.second = new Backtrace_nt_rightB_Front<std::pair<String, double> , unsigned int> (bt);
    set_value( tupel);
    push_back( l, tupel);
  }
  return l;
}

List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > probs_a_microstate::bt_proxy_nt_iloop(unsigned int t_0_i, unsigned int t_0_j)
{
  List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > l;
  empty(l);
  probs_a_microstate_hash_h ret = nt_iloop(t_0_i, t_0_j);
  if (isEmpty(ret))
    {
      return l;
    }

  intrusive_ptr<Backtrace_nt_iloop_Back<probs_a_microstate, std::pair<String, double> , unsigned int>  >  bt = new Backtrace_nt_iloop_Back<probs_a_microstate, std::pair<String, double> , unsigned int> (this, t_0_i, t_0_j);
  for (probs_a_microstate_hash_h::iterator elem_itr = ret.ref().begin(); elem_itr!=ret.ref().end(); ++elem_itr){
    std::pair<Rope, std::pair<mfecovar, double> >  elem = *elem_itr;
    std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  tupel;
    tupel.first = elem;
    tupel.second = new Backtrace_nt_iloop_Front<std::pair<String, double> , unsigned int> (bt);
    set_value( tupel);
    push_back( l, tupel);
  }
  return l;
}

List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > probs_a_microstate::bt_proxy_nt_multiloop(unsigned int t_0_i, unsigned int t_0_j)
{
  List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > l;
  empty(l);
  probs_a_microstate_hash_h ret = nt_multiloop(t_0_i, t_0_j);
  if (isEmpty(ret))
    {
      return l;
    }

  intrusive_ptr<Backtrace_nt_multiloop_Back<probs_a_microstate, std::pair<String, double> , unsigned int>  >  bt = new Backtrace_nt_multiloop_Back<probs_a_microstate, std::pair<String, double> , unsigned int> (this, t_0_i, t_0_j);
  for (probs_a_microstate_hash_h::iterator elem_itr = ret.ref().begin(); elem_itr!=ret.ref().end(); ++elem_itr){
    std::pair<Rope, std::pair<mfecovar, double> >  elem = *elem_itr;
    std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  tupel;
    tupel.first = elem;
    tupel.second = new Backtrace_nt_multiloop_Front<std::pair<String, double> , unsigned int> (bt);
    set_value( tupel);
    push_back( l, tupel);
  }
  return l;
}

List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > probs_a_microstate::bt_proxy_nt_ml_comps(unsigned int t_0_i, unsigned int t_0_j)
{
  List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > l;
  empty(l);
  probs_a_microstate_hash_h ret = nt_ml_comps(t_0_i, t_0_j);
  if (isEmpty(ret))
    {
      return l;
    }

  intrusive_ptr<Backtrace_nt_ml_comps_Back<probs_a_microstate, std::pair<String, double> , unsigned int>  >  bt = new Backtrace_nt_ml_comps_Back<probs_a_microstate, std::pair<String, double> , unsigned int> (this, t_0_i, t_0_j);
  for (probs_a_microstate_hash_h::iterator elem_itr = ret.ref().begin(); elem_itr!=ret.ref().end(); ++elem_itr){
    std::pair<Rope, std::pair<mfecovar, double> >  elem = *elem_itr;
    std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  tupel;
    tupel.first = elem;
    tupel.second = new Backtrace_nt_ml_comps_Front<std::pair<String, double> , unsigned int> (bt);
    set_value( tupel);
    push_back( l, tupel);
  }
  return l;
}

List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > probs_a_microstate::bt_proxy_nt_ml_comps1(unsigned int t_0_i, unsigned int t_0_j)
{
  List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > l;
  empty(l);
  probs_a_microstate_hash_h ret = nt_ml_comps1(t_0_i, t_0_j);
  if (isEmpty(ret))
    {
      return l;
    }

  intrusive_ptr<Backtrace_nt_ml_comps1_Back<probs_a_microstate, std::pair<String, double> , unsigned int>  >  bt = new Backtrace_nt_ml_comps1_Back<probs_a_microstate, std::pair<String, double> , unsigned int> (this, t_0_i, t_0_j);
  for (probs_a_microstate_hash_h::iterator elem_itr = ret.ref().begin(); elem_itr!=ret.ref().end(); ++elem_itr){
    std::pair<Rope, std::pair<mfecovar, double> >  elem = *elem_itr;
    std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  tupel;
    tupel.first = elem;
    tupel.second = new Backtrace_nt_ml_comps1_Front<std::pair<String, double> , unsigned int> (bt);
    set_value( tupel);
    push_back( l, tupel);
  }
  return l;
}

intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  probs_a_microstate::bt_nt_dangle(unsigned int t_0_i, unsigned int t_0_j)
{
  if (!dangle_table.is_tabulated(t_0_i, t_0_j))
    {
      return 0;
    }

  List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > answers;
  empty(answers);
  empty( answers);

  if (((t_0_j - t_0_i) >= 6))
  {
    TUSubsequence ret_3 = LOC(t_0_seq, t_0_j, t_0_j);
    TUSubsequence a_2 = ret_3;
    if (is_not_empty(a_2))
    {
      TUSubsequence ret_1;
      if (unpaired(t_0_seq, t_0_i, (t_0_i + 1)))
        {
          ret_1 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
        }

      else
        {
          empty( ret_1);
        }

      TUSubsequence a_0 = ret_1;
      if (is_not_empty(a_0))
      {
        List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > ret_2 = bt_proxy_nt_strong((t_0_i + 1), t_0_j);
        List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > a_1 = ret_2;
        if (is_not_empty(a_1))
          {
            for (List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > >::iterator x_1_itr = a_1.ref().begin(); x_1_itr!=a_1.ref().end(); ++x_1_itr){
              std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  x_1 = *x_1_itr;
              std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  ans = edl_bt(a_0, x_1, a_2);
              if ((ans.first.second.first.mfe + ans.first.second.first.covar) <= _thresh)  // rule1
              {
                push_back( answers, ans);
              }
            }
          }

        erase( a_1);
      }

      erase( a_0);
    }

    erase( a_2);
  }


  if (((t_0_j - t_0_i) >= 6))
  {
    TUSubsequence ret_7;
    if (unpaired(t_0_seq, (t_0_j - 1), t_0_j))
      {
        ret_7 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
      }

    else
      {
        empty( ret_7);
      }

    TUSubsequence a_5 = ret_7;
    if (is_not_empty(a_5))
    {
      TUSubsequence ret_5 = LOC(t_0_seq, t_0_i, t_0_i);
      TUSubsequence a_3 = ret_5;
      if (is_not_empty(a_3))
      {
        List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > ret_6 = bt_proxy_nt_strong(t_0_i, (t_0_j - 1));
        List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > a_4 = ret_6;
        if (is_not_empty(a_4))
          {
            for (List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > >::iterator x_4_itr = a_4.ref().begin(); x_4_itr!=a_4.ref().end(); ++x_4_itr){
              std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  x_4 = *x_4_itr;
              std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  ans = edr_bt(a_3, x_4, a_5);
              if ((ans.first.second.first.mfe + ans.first.second.first.covar) <= _thresh)  // rule1
              {
                push_back( answers, ans);
              }
            }
          }

        erase( a_4);
      }

      erase( a_3);
    }

    erase( a_5);
  }


  if (((t_0_j - t_0_i) >= 7))
  {
    TUSubsequence ret_11;
    if (unpaired(t_0_seq, (t_0_j - 1), t_0_j))
      {
        ret_11 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
      }

    else
      {
        empty( ret_11);
      }

    TUSubsequence a_8 = ret_11;
    if (is_not_empty(a_8))
    {
      TUSubsequence ret_9;
      if (unpaired(t_0_seq, t_0_i, (t_0_i + 1)))
        {
          ret_9 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
        }

      else
        {
          empty( ret_9);
        }

      TUSubsequence a_6 = ret_9;
      if (is_not_empty(a_6))
      {
        List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > ret_10 = bt_proxy_nt_strong((t_0_i + 1), (t_0_j - 1));
        List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > a_7 = ret_10;
        if (is_not_empty(a_7))
          {
            for (List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > >::iterator x_7_itr = a_7.ref().begin(); x_7_itr!=a_7.ref().end(); ++x_7_itr){
              std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  x_7 = *x_7_itr;
              std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  ans = edlr_bt(a_6, x_7, a_8);
              if ((ans.first.second.first.mfe + ans.first.second.first.covar) <= _thresh)  // rule1
              {
                push_back( answers, ans);
              }
            }
          }

        erase( a_7);
      }

      erase( a_6);
    }

    erase( a_8);
  }


  if (((t_0_j - t_0_i) >= 5))
  {
    TUSubsequence ret_15 = LOC(t_0_seq, t_0_j, t_0_j);
    TUSubsequence a_11 = ret_15;
    if (is_not_empty(a_11))
    {
      TUSubsequence ret_13 = LOC(t_0_seq, t_0_i, t_0_i);
      TUSubsequence a_9 = ret_13;
      if (is_not_empty(a_9))
      {
        List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > ret_14 = bt_proxy_nt_strong(t_0_i, t_0_j);
        List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > a_10 = ret_14;
        if (is_not_empty(a_10))
          {
            for (List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > >::iterator x_10_itr = a_10.ref().begin(); x_10_itr!=a_10.ref().end(); ++x_10_itr){
              std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  x_10 = *x_10_itr;
              std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  ans = drem_bt(a_9, x_10, a_11);
              if ((ans.first.second.first.mfe + ans.first.second.first.covar) <= _thresh)  // rule1
              {
                push_back( answers, ans);
              }
            }
          }

        erase( a_10);
      }

      erase( a_9);
    }

    erase( a_11);
  }

  List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > eval = h_bt(answers, dangle_table.get(t_0_i, t_0_j));
  erase( answers);
  intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  bt_list = execute_backtrack_k(eval);
  erase( eval);
  return bt_list;
}

intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  probs_a_microstate::bt_nt_hairpin(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 5))
    {
      return 0;
    }

  std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  answers;
  empty( answers);
  std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  ret_0;
  if (((t_0_j - t_0_i) >= 5))
    {
      if ( (_matchStr.empty() && basepair(t_0_seq, t_0_i, t_0_j)) || \
           ((!_matchStr.empty() && !_exact) && fuzzy_pairing_center_at(t_0_seq, t_0_i, t_0_j, _match_tokens_h)) || \
           ((!_matchStr.empty() && _exact) && exact_pairing_center_at(t_0_seq, t_0_i, t_0_j, _match_tokens_h)) )  // added
      {                                                                                                           // added
        TUSubsequence ret_3 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
        TUSubsequence a_2 = ret_3;
        if (is_not_empty(a_2))
        {
          TUSubsequence ret_2;
          if ((minsize(t_0_seq, (t_0_i + 1), (t_0_j - 1), 3) && unpaired(t_0_seq, (t_0_i + 1), (t_0_j - 1))))
            {
              ret_2 = REGION(t_0_seq, (t_0_i + 1), (t_0_j - 1));
            }

          else
            {
              empty( ret_2);
            }

          TUSubsequence a_1 = ret_2;
          if (is_not_empty(a_1))
          {
            TUSubsequence ret_1 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
            TUSubsequence a_0 = ret_1;
            if (is_not_empty(a_0))
              {
                ret_0 = hl_bt(a_0, a_1, a_2);
              }

            else
              {
                empty( ret_0);
              }

            erase( a_0);
          }

          else
            {
              empty( ret_0);
            }

          erase( a_1);
        }

        else
          {
            empty( ret_0);
          }

        erase( a_2);
      }

      else
      {
        empty( ret_0);
        empty( ret_0);
      }

    }

  else
    {
      empty( ret_0);
    }

  answers = ret_0;
  intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  bt_list = execute_backtrack_k(answers);
  return bt_list;
}

intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  probs_a_microstate::bt_nt_iloop(unsigned int t_0_i, unsigned int t_0_j)
{
  if (!iloop_table.is_tabulated(t_0_i, t_0_j))
    {
      return 0;
    }

  List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > answers;
  empty(answers);
  empty( answers);

  if (((t_0_j - t_0_i) >= 9))
    {
      if /*(*/(/*(!_exact) && */basepair(t_0_seq, t_0_i, t_0_j)) /*|| ((_exact) && exact_pairing_center_at(t_0_seq, t_0_i, t_0_j, _match_tokens_i)))*/  // added_
      {                                                                                                                                     // added_
          for(          unsigned int t_0_k_0 = (t_0_i + 2); ((t_0_k_0 <= (t_0_j - 7)) && (t_0_k_0 <= (t_0_i + 31))); ++t_0_k_0)
          {
            for(            unsigned int t_0_k_1 = (((t_0_j - (t_0_k_0 + 5)) >= 31)) ? ((t_0_j - 31)) : ((t_0_k_0 + 5)); (t_0_k_1 <= (t_0_j - 2)); ++t_0_k_1)
            {
              TUSubsequence ret_5 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
              TUSubsequence a_4 = ret_5;
              if (is_not_empty(a_4))
              {
                TUSubsequence ret_4;
                if ((maxsize(t_0_seq, t_0_k_1, (t_0_j - 1), 30) && unpaired(t_0_seq, t_0_k_1, (t_0_j - 1))))
                  {
                    ret_4 = REGION(t_0_seq, t_0_k_1, (t_0_j - 1));
                  }

                else
                  {
                    empty( ret_4);
                  }

                TUSubsequence a_3 = ret_4;
                if (is_not_empty(a_3))
                {
                  TUSubsequence ret_2;
                  if ((maxsize(t_0_seq, (t_0_i + 1), t_0_k_0, 30) && unpaired(t_0_seq, (t_0_i + 1), t_0_k_0)))
                    {
                      ret_2 = REGION(t_0_seq, (t_0_i + 1), t_0_k_0);
                    }

                  else
                    {
                      empty( ret_2);
                    }

                  TUSubsequence a_1 = ret_2;
                  if (is_not_empty(a_1))
                  {
                    TUSubsequence ret_1 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
                    TUSubsequence a_0 = ret_1;
                    if (is_not_empty(a_0))
                    {
                      List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > ret_3 = bt_proxy_nt_strong(t_0_k_0, t_0_k_1);
                      List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > a_2 = ret_3;
                      if (is_not_empty(a_2))
                        {
                          for (List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > >::iterator x_2_itr = a_2.ref().begin(); x_2_itr!=a_2.ref().end(); ++x_2_itr){
                            std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  x_2 = *x_2_itr;
                            std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  ans = il_bt(a_0, a_1, x_2, a_3, a_4);
                            push_back( answers, ans);
                          }
                        }

                      erase( a_2);
                    }

                    erase( a_0);
                  }

                  erase( a_1);
                }

                erase( a_3);
              }

              erase( a_4);
            }

          }

        }

      else
        {
          empty( answers);
        }

    }

  List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > eval = h_bt(answers, iloop_table.get(t_0_i, t_0_j));
  erase( answers);
  intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  bt_list = execute_backtrack_k(eval);
  erase( eval);
  return bt_list;
}

intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  probs_a_microstate::bt_nt_leftB(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 8))
    {
      return 0;
    }

  List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > answers;
  empty(answers);
  empty( answers);

  if (((t_0_j - t_0_i) >= 8))
    {
      if /*(*/(/*(!_exact) && */basepair(t_0_seq, t_0_i, t_0_j)) /*|| ((_exact) && exact_pairing_center_at(t_0_seq, t_0_i, t_0_j, _match_tokens_b)))*/  // added_
      {                                                                                                                                     // added_
          for(          unsigned int t_0_k_0 = (t_0_i + 2); ((t_0_k_0 <= (t_0_j - 6)) && (t_0_k_0 <= (t_0_i + 31))); ++t_0_k_0)
          {
            TUSubsequence ret_4 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
            TUSubsequence a_3 = ret_4;
            if (is_not_empty(a_3))
            {
              TUSubsequence ret_2;
              if ((maxsize(t_0_seq, (t_0_i + 1), t_0_k_0, 30) && unpaired(t_0_seq, (t_0_i + 1), t_0_k_0)))
                {
                  ret_2 = REGION(t_0_seq, (t_0_i + 1), t_0_k_0);
                }

              else
                {
                  empty( ret_2);
                }

              TUSubsequence a_1 = ret_2;
              if (is_not_empty(a_1))
              {
                TUSubsequence ret_1 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
                TUSubsequence a_0 = ret_1;
                if (is_not_empty(a_0))
                {
                  List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > ret_3 = bt_proxy_nt_strong(t_0_k_0, (t_0_j - 1));
                  List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > a_2 = ret_3;
                  if (is_not_empty(a_2))
                    {
                      for (List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > >::iterator x_2_itr = a_2.ref().begin(); x_2_itr!=a_2.ref().end(); ++x_2_itr){
                        std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  x_2 = *x_2_itr;
                        std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  ans = bl_bt(a_0, a_1, x_2, a_3);
                        push_back( answers, ans);
                      }
                    }

                  erase( a_2);
                }

                erase( a_0);
              }

              erase( a_1);
            }

            erase( a_3);
          }

        }

      else
        {
          empty( answers);
        }

    }

  List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > eval = h_bt(answers);
  erase( answers);
  intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  bt_list = execute_backtrack_k(eval);
  erase( eval);
  return bt_list;
}

intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  probs_a_microstate::bt_nt_ml_comps(unsigned int t_0_i, unsigned int t_0_j)
{
  if (!ml_comps_table.is_tabulated(t_0_i, t_0_j))
    {
      return 0;
    }

  List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > answers;
  empty(answers);
  empty( answers);

  if (((t_0_j - t_0_i) >= 11))
  {
    TUSubsequence ret_1;
    if (unpaired(t_0_seq, t_0_i, (t_0_i + 1)))
      {
        ret_1 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
      }

    else
      {
        empty( ret_1);
      }

    TUSubsequence a_0 = ret_1;
    if (is_not_empty(a_0))
    {
      List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > ret_2 = bt_proxy_nt_ml_comps((t_0_i + 1), t_0_j);
      List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > a_1 = ret_2;
      if (is_not_empty(a_1))
        {
          for (List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > >::iterator x_1_itr = a_1.ref().begin(); x_1_itr!=a_1.ref().end(); ++x_1_itr){
            std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  x_1 = *x_1_itr;
            std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  ans = sadd_bt(a_0, x_1);
            push_back( answers, ans);
          }
        }

      erase( a_1);
    }

    erase( a_0);
  }


  if (((t_0_j - t_0_i) >= 10))
    {
      for(      unsigned int t_0_k_0 = (t_0_i + 5); (t_0_k_0 <= (t_0_j - 5)); ++t_0_k_0)
      {
        List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > ret_6 = bt_proxy_nt_ml_comps1(t_0_k_0, t_0_j);
        List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > a_4 = ret_6;
        if (is_not_empty(a_4))
        {
          List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > ret_4;
          empty(ret_4);
          if (((t_0_k_0 - t_0_i) >= 5))
          {
            List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > ret_5 = bt_proxy_nt_dangle(t_0_i, t_0_k_0);
            List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > a_3 = ret_5;
            if (is_not_empty(a_3))
              {
                for (List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > >::iterator x_3_itr = a_3.ref().begin(); x_3_itr!=a_3.ref().end(); ++x_3_itr){
                  std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  x_3 = *x_3_itr;
                  std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  ans = incl_bt(x_3);
                  push_back( ret_4, ans);
                }
              }

            erase( a_3);
          }

          finalize( ret_4);
          List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > a_2 = ret_4;
          if (is_not_empty(a_2))
            {
              for (List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > >::iterator x_2_itr = a_2.ref().begin(); x_2_itr!=a_2.ref().end(); ++x_2_itr){
                std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  x_2 = *x_2_itr;
                for (List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > >::iterator x_4_itr = a_4.ref().begin(); x_4_itr!=a_4.ref().end(); ++x_4_itr){
                  std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  x_4 = *x_4_itr;
                  std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  ans = cadd_bt(x_2, x_4);
                  push_back( answers, ans);
                }
              }
            }

          erase( a_2);
        }

        else
          {
            for (List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > >::iterator elem_itr = a_4.ref().begin(); elem_itr!=a_4.ref().end(); ++elem_itr){
              std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  elem = *elem_itr;
              erase( elem.second);
            }
          }

        erase( a_4);
      }

    }

  List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > eval = h_bt(answers, ml_comps_table.get(t_0_i, t_0_j));
  erase( answers);
  intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  bt_list = execute_backtrack_k(eval);
  erase( eval);
  return bt_list;
}

intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  probs_a_microstate::bt_nt_ml_comps1(unsigned int t_0_i, unsigned int t_0_j)
{
  if (!ml_comps1_table.is_tabulated(t_0_i, t_0_j))
    {
      return 0;
    }

  List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > answers;
  empty(answers);
  empty( answers);

  if (((t_0_j - t_0_i) >= 6))
  {
    TUSubsequence ret_1;
    if (unpaired(t_0_seq, t_0_i, (t_0_i + 1)))
      {
        ret_1 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
      }

    else
      {
        empty( ret_1);
      }

    TUSubsequence a_0 = ret_1;
    if (is_not_empty(a_0))
    {
      List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > ret_2 = bt_proxy_nt_ml_comps1((t_0_i + 1), t_0_j);
      List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > a_1 = ret_2;
      if (is_not_empty(a_1))
        {
          for (List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > >::iterator x_1_itr = a_1.ref().begin(); x_1_itr!=a_1.ref().end(); ++x_1_itr){
            std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  x_1 = *x_1_itr;
            std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  ans = sadd_bt(a_0, x_1);
            push_back( answers, ans);
          }
        }

      erase( a_1);
    }

    erase( a_0);
  }


  if (((t_0_j - t_0_i) >= 10))
    {
      for(      unsigned int t_0_k_0 = (t_0_i + 5); (t_0_k_0 <= (t_0_j - 5)); ++t_0_k_0)
      {
        List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > ret_6 = bt_proxy_nt_ml_comps1(t_0_k_0, t_0_j);
        List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > a_4 = ret_6;
        if (is_not_empty(a_4))
        {
          List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > ret_4;
          empty(ret_4);
          if (((t_0_k_0 - t_0_i) >= 5))
          {
            List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > ret_5 = bt_proxy_nt_dangle(t_0_i, t_0_k_0);
            List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > a_3 = ret_5;
            if (is_not_empty(a_3))
              {
                for (List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > >::iterator x_3_itr = a_3.ref().begin(); x_3_itr!=a_3.ref().end(); ++x_3_itr){
                  std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  x_3 = *x_3_itr;
                  std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  ans = incl_bt(x_3);
                  push_back( ret_4, ans);
                }
              }

            erase( a_3);
          }

          finalize( ret_4);
          List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > a_2 = ret_4;
          if (is_not_empty(a_2))
            {
              for (List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > >::iterator x_2_itr = a_2.ref().begin(); x_2_itr!=a_2.ref().end(); ++x_2_itr){
                std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  x_2 = *x_2_itr;
                for (List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > >::iterator x_4_itr = a_4.ref().begin(); x_4_itr!=a_4.ref().end(); ++x_4_itr){
                  std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  x_4 = *x_4_itr;
                  std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  ans = cadd_bt(x_2, x_4);
                  push_back( answers, ans);
                }
              }
            }

          erase( a_2);
        }

        else
          {
            for (List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > >::iterator elem_itr = a_4.ref().begin(); elem_itr!=a_4.ref().end(); ++elem_itr){
              std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  elem = *elem_itr;
              erase( elem.second);
            }
          }

        erase( a_4);
      }

    }


  if (((t_0_j - t_0_i) >= 5))
  {
    List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > ret_8 = bt_proxy_nt_dangle(t_0_i, t_0_j);
    List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > a_5 = ret_8;
    if (is_not_empty(a_5))
      {
        for (List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > >::iterator x_5_itr = a_5.ref().begin(); x_5_itr!=a_5.ref().end(); ++x_5_itr){
          std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  x_5 = *x_5_itr;
          std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  ans = incl_bt(x_5);
          push_back( answers, ans);
        }
      }

    erase( a_5);
  }


  if (((t_0_j - t_0_i) >= 6))
    {
      for(      unsigned int t_0_k_1 = (t_0_i + 5); (t_0_k_1 <= (t_0_j - 1)); ++t_0_k_1)
      {
        TUSubsequence ret_12;
        if (unpaired(t_0_seq, t_0_k_1, t_0_j))
          {
            ret_12 = REGION(t_0_seq, t_0_k_1, t_0_j);
          }

        else
          {
            empty( ret_12);
          }

        TUSubsequence a_8 = ret_12;
        if (is_not_empty(a_8))
        {
          List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > ret_10;
          empty(ret_10);
          if (((t_0_k_1 - t_0_i) >= 5))
          {
            List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > ret_11 = bt_proxy_nt_dangle(t_0_i, t_0_k_1);
            List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > a_7 = ret_11;
            if (is_not_empty(a_7))
              {
                for (List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > >::iterator x_7_itr = a_7.ref().begin(); x_7_itr!=a_7.ref().end(); ++x_7_itr){
                  std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  x_7 = *x_7_itr;
                  std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  ans = incl_bt(x_7);
                  push_back( ret_10, ans);
                }
              }

            erase( a_7);
          }

          finalize( ret_10);
          List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > a_6 = ret_10;
          if (is_not_empty(a_6))
            {
              for (List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > >::iterator x_6_itr = a_6.ref().begin(); x_6_itr!=a_6.ref().end(); ++x_6_itr){
                std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  x_6 = *x_6_itr;
                std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  ans = addss_bt(x_6, a_8);
                push_back( answers, ans);
              }
            }

          erase( a_6);
        }

        erase( a_8);
      }

    }

  List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > eval = h_bt(answers, ml_comps1_table.get(t_0_i, t_0_j));
  erase( answers);
  intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  bt_list = execute_backtrack_k(eval);
  erase( eval);
  return bt_list;
}

intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  probs_a_microstate::bt_nt_multiloop(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 12))
    {
      return 0;
    }

  List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > answers;
  empty(answers);
  empty( answers);

  if (((t_0_j - t_0_i) >= 12))
    {
      if /*(*/(/*(!_exact) && */basepair(t_0_seq, t_0_i, t_0_j)) /*|| ((_exact) && exact_pairing_center_at(t_0_seq, t_0_i, t_0_j, _match_tokens_m)))*/  // added_
      {                                                                                                                                     // added_
        TUSubsequence ret_3 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
        TUSubsequence a_2 = ret_3;
        if (is_not_empty(a_2))
        {
          TUSubsequence ret_1 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
          TUSubsequence a_0 = ret_1;
          if (is_not_empty(a_0))
          {
            List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > ret_2 = bt_proxy_nt_ml_comps((t_0_i + 1), (t_0_j - 1));
            List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > a_1 = ret_2;
            if (is_not_empty(a_1))
              {
                for (List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > >::iterator x_1_itr = a_1.ref().begin(); x_1_itr!=a_1.ref().end(); ++x_1_itr){
                  std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  x_1 = *x_1_itr;
                  std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  ans = ml_bt(a_0, x_1, a_2);
                  push_back( answers, ans);
                }
              }

            erase( a_1);
          }

          erase( a_0);
        }

        erase( a_2);
      }

      else
        {
          empty( answers);
        }

    }


  if (((t_0_j - t_0_i) >= 13))
    {
      if /*(*/(/*(!_exact) && */basepair(t_0_seq, t_0_i, t_0_j)) /*|| ((_exact) && exact_pairing_center_at(t_0_seq, t_0_i, t_0_j, _match_tokens_m)))*/  // added_
      {                                                                                                                                     // added_
        TUSubsequence ret_8 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
        TUSubsequence a_6 = ret_8;
        if (is_not_empty(a_6))
        {
          TUSubsequence ret_6;
          if (unpaired(t_0_seq, (t_0_i + 1), ((t_0_i + 1) + 1)))
            {
              ret_6 = BASE(t_0_seq, (t_0_i + 1), ((t_0_i + 1) + 1));
            }

          else
            {
              empty( ret_6);
            }

          TUSubsequence a_4 = ret_6;
          if (is_not_empty(a_4))
          {
            TUSubsequence ret_5 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
            TUSubsequence a_3 = ret_5;
            if (is_not_empty(a_3))
            {
              List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > ret_7 = bt_proxy_nt_ml_comps((t_0_i + 2), (t_0_j - 1));
              List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > a_5 = ret_7;
              if (is_not_empty(a_5))
                {
                  for (List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > >::iterator x_5_itr = a_5.ref().begin(); x_5_itr!=a_5.ref().end(); ++x_5_itr){
                    std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  x_5 = *x_5_itr;
                    std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  ans = mldl_bt(a_3, a_4, x_5, a_6);
                    push_back( answers, ans);
                  }
                }

              erase( a_5);
            }

            erase( a_3);
          }

          erase( a_4);
        }

        erase( a_6);
      }

      else
        {
          empty( answers);
        }

    }


  if (((t_0_j - t_0_i) >= 13))
    {
      if /*(*/(/*(!_exact) && */basepair(t_0_seq, t_0_i, t_0_j)) /*|| ((_exact) && exact_pairing_center_at(t_0_seq, t_0_i, t_0_j, _match_tokens_m)))*/  // added_
      {                                                                                                                                     // added_
        TUSubsequence ret_13 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
        TUSubsequence a_10 = ret_13;
        if (is_not_empty(a_10))
        {
          TUSubsequence ret_12;
          if (unpaired(t_0_seq, (t_0_j - 2), (t_0_j - 1)))
            {
              ret_12 = BASE(t_0_seq, (t_0_j - 2), (t_0_j - 1));
            }

          else
            {
              empty( ret_12);
            }

          TUSubsequence a_9 = ret_12;
          if (is_not_empty(a_9))
          {
            TUSubsequence ret_10 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
            TUSubsequence a_7 = ret_10;
            if (is_not_empty(a_7))
            {
              List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > ret_11 = bt_proxy_nt_ml_comps((t_0_i + 1), (t_0_j - 2));
              List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > a_8 = ret_11;
              if (is_not_empty(a_8))
                {
                  for (List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > >::iterator x_8_itr = a_8.ref().begin(); x_8_itr!=a_8.ref().end(); ++x_8_itr){
                    std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  x_8 = *x_8_itr;
                    std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  ans = mldr_bt(a_7, x_8, a_9, a_10);
                    push_back( answers, ans);
                  }
                }

              erase( a_8);
            }

            erase( a_7);
          }

          erase( a_9);
        }

        erase( a_10);
      }

      else
        {
          empty( answers);
        }

    }


  if (((t_0_j - t_0_i) >= 14))
    {
      if /*(*/(/*(!_exact) && */basepair(t_0_seq, t_0_i, t_0_j)) /*|| ((_exact) && exact_pairing_center_at(t_0_seq, t_0_i, t_0_j, _match_tokens_m)))*/  // added_
      {                                                                                                                                     // added_
        TUSubsequence ret_19 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
        TUSubsequence a_15 = ret_19;
        if (is_not_empty(a_15))
        {
          TUSubsequence ret_18;
          if (unpaired(t_0_seq, (t_0_j - 2), (t_0_j - 1)))
            {
              ret_18 = BASE(t_0_seq, (t_0_j - 2), (t_0_j - 1));
            }

          else
            {
              empty( ret_18);
            }

          TUSubsequence a_14 = ret_18;
          if (is_not_empty(a_14))
          {
            TUSubsequence ret_16;
            if (unpaired(t_0_seq, (t_0_i + 1), ((t_0_i + 1) + 1)))
              {
                ret_16 = BASE(t_0_seq, (t_0_i + 1), ((t_0_i + 1) + 1));
              }

            else
              {
                empty( ret_16);
              }

            TUSubsequence a_12 = ret_16;
            if (is_not_empty(a_12))
            {
              TUSubsequence ret_15 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
              TUSubsequence a_11 = ret_15;
              if (is_not_empty(a_11))
              {
                List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > ret_17 = bt_proxy_nt_ml_comps((t_0_i + 2), (t_0_j - 2));
                List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > a_13 = ret_17;
                if (is_not_empty(a_13))
                  {
                    for (List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > >::iterator x_13_itr = a_13.ref().begin(); x_13_itr!=a_13.ref().end(); ++x_13_itr){
                      std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  x_13 = *x_13_itr;
                      std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  ans = mldlr_bt(a_11, a_12, x_13, a_14, a_15);
                      push_back( answers, ans);
                    }
                  }

                erase( a_13);
              }

              erase( a_11);
            }

            erase( a_12);
          }

          erase( a_14);
        }

        erase( a_15);
      }

      else
        {
          empty( answers);
        }

    }

  List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > eval = h_bt(answers);
  erase( answers);
  intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  bt_list = execute_backtrack_k(eval);
  erase( eval);
  return bt_list;
}

intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  probs_a_microstate::bt_nt_rightB(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 8))
    {
      return 0;
    }

  List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > answers;
  empty(answers);
  empty( answers);

  if (((t_0_j - t_0_i) >= 8))
    {
      if /*(*/(/*(!_exact) && */basepair(t_0_seq, t_0_i, t_0_j)) /*|| ((_exact) && exact_pairing_center_at(t_0_seq, t_0_i, t_0_j, _match_tokens_b)))*/  // added_
      {                                                                                                                                     // added_
          for(          unsigned int t_0_k_0 = (((t_0_j - (t_0_i + 6)) >= 31)) ? ((t_0_j - 31)) : ((t_0_i + 6)); (t_0_k_0 <= (t_0_j - 2)); ++t_0_k_0)
          {
            TUSubsequence ret_4 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
            TUSubsequence a_3 = ret_4;
            if (is_not_empty(a_3))
            {
              TUSubsequence ret_3;
              if ((maxsize(t_0_seq, t_0_k_0, (t_0_j - 1), 30) && unpaired(t_0_seq, t_0_k_0, (t_0_j - 1))))
                {
                  ret_3 = REGION(t_0_seq, t_0_k_0, (t_0_j - 1));
                }

              else
                {
                  empty( ret_3);
                }

              TUSubsequence a_2 = ret_3;
              if (is_not_empty(a_2))
              {
                TUSubsequence ret_1 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
                TUSubsequence a_0 = ret_1;
                if (is_not_empty(a_0))
                {
                  List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > ret_2 = bt_proxy_nt_strong((t_0_i + 1), t_0_k_0);
                  List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > a_1 = ret_2;
                  if (is_not_empty(a_1))
                    {
                      for (List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > >::iterator x_1_itr = a_1.ref().begin(); x_1_itr!=a_1.ref().end(); ++x_1_itr){
                        std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  x_1 = *x_1_itr;
                        std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  ans = br_bt(a_0, x_1, a_2, a_3);
                        push_back( answers, ans);
                      }
                    }

                  erase( a_1);
                }

                erase( a_0);
              }

              erase( a_2);
            }

            erase( a_3);
          }

        }

      else
        {
          empty( answers);
        }

    }

  List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > eval = h_bt(answers);
  erase( answers);
  intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  bt_list = execute_backtrack_k(eval);
  erase( eval);
  return bt_list;
}

intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  probs_a_microstate::bt_nt_stack(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 7))
    {
      return 0;
    }

  List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > answers;
  empty(answers);
  empty( answers);

  if (((t_0_j - t_0_i) >= 7))
    {
      if (basepair(t_0_seq, t_0_i, t_0_j))
      {
        TUSubsequence ret_3 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
        TUSubsequence a_2 = ret_3;
        if (is_not_empty(a_2))
        {
          TUSubsequence ret_1 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
          TUSubsequence a_0 = ret_1;
          if (is_not_empty(a_0))
          {
            List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > ret_2 = bt_proxy_nt_weak((t_0_i + 1), (t_0_j - 1));
            List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > a_1 = ret_2;
            if (is_not_empty(a_1))
              {
                for (List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > >::iterator x_1_itr = a_1.ref().begin(); x_1_itr!=a_1.ref().end(); ++x_1_itr){
                  std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  x_1 = *x_1_itr;
                  std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  ans = sr_bt(a_0, x_1, a_2);
                  push_back( answers, ans);
                }
              }

            erase( a_1);
          }

          erase( a_0);
        }

        erase( a_2);
      }

      else
        {
          empty( answers);
        }

    }

  List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > eval = h_bt(answers);
  erase( answers);
  intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  bt_list = execute_backtrack_k(eval);
  erase( eval);
  return bt_list;
}

intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  probs_a_microstate::bt_nt_strong(unsigned int t_0_i, unsigned int t_0_j)
{
  if (!strong_table.is_tabulated(t_0_i, t_0_j))
    {
      return 0;
    }

  List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > answers;
  empty(answers);
  empty( answers);


  if (allowLonelyBasepairs(t_0_seq, t_0_i, t_0_j, false))
  {
    List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > ret_1;
    empty(ret_1);
    if (((t_0_j - t_0_i) >= 7))
      {
        if (basepair(t_0_seq, t_0_i, t_0_j))
        {
          TUSubsequence ret_4 = BASE(t_0_seq, (t_0_j - 1), t_0_j);
          TUSubsequence a_2 = ret_4;
          if (is_not_empty(a_2))
          {
            TUSubsequence ret_2 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
            TUSubsequence a_0 = ret_2;
            if (is_not_empty(a_0))
            {
              List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > ret_3 = bt_proxy_nt_weak((t_0_i + 1), (t_0_j - 1));
              List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > a_1 = ret_3;
              if (is_not_empty(a_1))
                {
                  for (List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > >::iterator x_1_itr = a_1.ref().begin(); x_1_itr!=a_1.ref().end(); ++x_1_itr){
                    std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  x_1 = *x_1_itr;
                    std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  ans = sr_bt(a_0, x_1, a_2);
                    push_back( ret_1, ans);
                  }
                }

              erase( a_1);
            }

            erase( a_0);
          }

          erase( a_2);
        }

        else
          {
            empty( ret_1);
          }

      }

    finalize( ret_1);
    append( answers, ret_1);
  }



  if (allowLonelyBasepairs(t_0_seq, t_0_i, t_0_j, true))
  {
    List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > ret_6 = bt_proxy_nt_weak(t_0_i, t_0_j);
    append( answers, ret_6);
  }

  List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > eval = h_bt(answers, strong_table.get(t_0_i, t_0_j));
  erase( answers);
  intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  bt_list = execute_backtrack_k(eval);
  erase( eval);
  return bt_list;
}

intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  probs_a_microstate::bt_nt_struct(unsigned int t_0_i)
{
  if (!struct_table.is_tabulated(t_0_i))
    {
      return 0;
    }

  List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > answers;
  empty(answers);
  empty( answers);

  if (((t_0_right_most - t_0_i) >= 1))
  {
    TUSubsequence ret_1;
    if (unpaired(t_0_seq, t_0_i, (t_0_i + 1)))
      {
        ret_1 = BASE(t_0_seq, t_0_i, (t_0_i + 1));
      }

    else
      {
        empty( ret_1);
      }

    TUSubsequence a_0 = ret_1;
    if (is_not_empty(a_0))
    {
      List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > ret_2 = bt_proxy_nt_struct((t_0_i + 1));
      List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > a_1 = ret_2;
      if (is_not_empty(a_1))
        {
          for (List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > >::iterator x_1_itr = a_1.ref().begin(); x_1_itr!=a_1.ref().end(); ++x_1_itr){
            std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  x_1 = *x_1_itr;
            std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  ans = sadd_bt(a_0, x_1);
            push_back( answers, ans);
          }
        }

      erase( a_1);
    }

    erase( a_0);
  }


  if (((t_0_right_most - t_0_i) >= 5))
    {
      for(      unsigned int t_0_k_0 = (t_0_i + 5); (t_0_k_0 <= t_0_right_most); ++t_0_k_0)
      {
        List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > ret_5 = bt_proxy_nt_struct(t_0_k_0);
        List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > a_3 = ret_5;
        if (is_not_empty(a_3))
        {
          List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > ret_4 = bt_proxy_nt_dangle(t_0_i, t_0_k_0);
          List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > a_2 = ret_4;
          if (is_not_empty(a_2))
            {
              for (List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > >::iterator x_2_itr = a_2.ref().begin(); x_2_itr!=a_2.ref().end(); ++x_2_itr){
                std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  x_2 = *x_2_itr;
                for (List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > >::iterator x_3_itr = a_3.ref().begin(); x_3_itr!=a_3.ref().end(); ++x_3_itr){
                  std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  x_3 = *x_3_itr;
                  std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  ans = cadd_bt(x_2, x_3);
                  push_back( answers, ans);
                }
              }
            }

          erase( a_2);
        }

        else
          {
            for (List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > >::iterator elem_itr = a_3.ref().begin(); elem_itr!=a_3.ref().end(); ++elem_itr){
              std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  elem = *elem_itr;
              erase( elem.second);
            }
          }

        erase( a_3);
      }

    }

  std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  ret_6;
  if ((((t_0_right_most - t_0_i) >= 0) && ((t_0_right_most - t_0_i) <= 0)))
  {
    TUSubsequence ret_7 = LOC(t_0_seq, t_0_i, t_0_i);
    TUSubsequence a_4 = ret_7;
    if (is_not_empty(a_4))
      {
        ret_6 = nil_bt(a_4);
      }

    else
      {
        empty( ret_6);
      }

    erase( a_4);
  }

  else
    {
      empty( ret_6);
    }

  if (is_not_empty(ret_6))
    {
      push_back( answers, ret_6);
    }

  List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > eval = h_bt(answers, struct_table.get(t_0_i));
  erase( answers);
  intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  bt_list = execute_backtrack_k(eval);
  erase( eval);
  return bt_list;
}

intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  probs_a_microstate::bt_nt_weak(unsigned int t_0_i, unsigned int t_0_j)
{
  if (!weak_table.is_tabulated(t_0_i, t_0_j))
    {
      return 0;
    }

  List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > answers;
  empty(answers);
  empty( answers);


  List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > ret_1 = bt_proxy_nt_stack(t_0_i, t_0_j);
  append( answers, ret_1);
  std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  ret_2 = bt_proxy_nt_hairpin(t_0_i, t_0_j);
  if (is_not_empty(ret_2))
    {
      push_back( answers, ret_2);
    }

  List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > ret_3 = bt_proxy_nt_leftB(t_0_i, t_0_j);
  append( answers, ret_3);
  List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > ret_4 = bt_proxy_nt_rightB(t_0_i, t_0_j);
  append( answers, ret_4);
  List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > ret_5 = bt_proxy_nt_iloop(t_0_i, t_0_j);
  append( answers, ret_5);
  List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > ret_6 = bt_proxy_nt_multiloop(t_0_i, t_0_j);
  append( answers, ret_6);
  List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > eval = h_bt(answers, weak_table.get(t_0_i, t_0_j));
  erase( answers);
  intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  bt_list = execute_backtrack_k(eval);
  erase( eval);
  return bt_list;
}


intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  probs_a_microstate::addss_bt_r(intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  param_0, const TUSubsequence & param_1)
{
  return new Backtrace_addss<std::pair<String, double> , unsigned int> (param_0, param_1);
}

intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  probs_a_microstate::bl_bt_r(const TUSubsequence & param_0, const TUSubsequence & param_1, intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  param_2, const TUSubsequence & param_3)
{
  return new Backtrace_bl<std::pair<String, double> , unsigned int> (param_0, param_1, param_2, param_3);
}

intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  probs_a_microstate::br_bt_r(const TUSubsequence & param_0, intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  param_1, const TUSubsequence & param_2, const TUSubsequence & param_3)
{
  return new Backtrace_br<std::pair<String, double> , unsigned int> (param_0, param_1, param_2, param_3);
}

intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  probs_a_microstate::cadd_bt_r(intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  param_0, intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  param_1)
{
  return new Backtrace_cadd<std::pair<String, double> , unsigned int> (param_0, param_1);
}

intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  probs_a_microstate::drem_bt_r(const TUSubsequence & param_0, intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  param_1, const TUSubsequence & param_2)
{
  return new Backtrace_drem<std::pair<String, double> , unsigned int> (param_0, param_1, param_2);
}

intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  probs_a_microstate::edl_bt_r(const TUSubsequence & param_0, intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  param_1, const TUSubsequence & param_2)
{
  return new Backtrace_edl<std::pair<String, double> , unsigned int> (param_0, param_1, param_2);
}

intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  probs_a_microstate::edlr_bt_r(const TUSubsequence & param_0, intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  param_1, const TUSubsequence & param_2)
{
  return new Backtrace_edlr<std::pair<String, double> , unsigned int> (param_0, param_1, param_2);
}

intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  probs_a_microstate::edr_bt_r(const TUSubsequence & param_0, intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  param_1, const TUSubsequence & param_2)
{
  return new Backtrace_edr<std::pair<String, double> , unsigned int> (param_0, param_1, param_2);
}

List_Ref<intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > probs_a_microstate::h_bt_r(List_Ref<intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > param_0)
{
  return param_0;
}

intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  probs_a_microstate::hl_bt_r(const TUSubsequence & param_0, const TUSubsequence & param_1, const TUSubsequence & param_2)
{
  return new Backtrace_hl<std::pair<String, double> , unsigned int> (param_0, param_1, param_2);
}

intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  probs_a_microstate::il_bt_r(const TUSubsequence & param_0, const TUSubsequence & param_1, intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  param_2, const TUSubsequence & param_3, const TUSubsequence & param_4)
{
  return new Backtrace_il<std::pair<String, double> , unsigned int> (param_0, param_1, param_2, param_3, param_4);
}

intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  probs_a_microstate::incl_bt_r(intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  param_0)
{
  return new Backtrace_incl<std::pair<String, double> , unsigned int> (param_0);
}

intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  probs_a_microstate::ml_bt_r(const TUSubsequence & param_0, intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  param_1, const TUSubsequence & param_2)
{
  return new Backtrace_ml<std::pair<String, double> , unsigned int> (param_0, param_1, param_2);
}

intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  probs_a_microstate::mldl_bt_r(const TUSubsequence & param_0, const TUSubsequence & param_1, intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  param_2, const TUSubsequence & param_3)
{
  return new Backtrace_mldl<std::pair<String, double> , unsigned int> (param_0, param_1, param_2, param_3);
}

intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  probs_a_microstate::mldlr_bt_r(const TUSubsequence & param_0, const TUSubsequence & param_1, intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  param_2, const TUSubsequence & param_3, const TUSubsequence & param_4)
{
  return new Backtrace_mldlr<std::pair<String, double> , unsigned int> (param_0, param_1, param_2, param_3, param_4);
}

intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  probs_a_microstate::mldr_bt_r(const TUSubsequence & param_0, intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  param_1, const TUSubsequence & param_2, const TUSubsequence & param_3)
{
  return new Backtrace_mldr<std::pair<String, double> , unsigned int> (param_0, param_1, param_2, param_3);
}

intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  probs_a_microstate::nil_bt_r(const TUSubsequence & param_0)
{
  return new Backtrace_nil<std::pair<String, double> , unsigned int> (param_0);
}

intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  probs_a_microstate::sadd_bt_r(const TUSubsequence & param_0, intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  param_1)
{
  return new Backtrace_sadd<std::pair<String, double> , unsigned int> (param_0, param_1);
}

intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  probs_a_microstate::sr_bt_r(const TUSubsequence & param_0, intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  param_1, const TUSubsequence & param_2)
{
  return new Backtrace_sr<std::pair<String, double> , unsigned int> (param_0, param_1, param_2);
}



std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  probs_a_microstate::addss_bt(const std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > & p_p_e, const TUSubsequence & p_p_rb)
{
  std::pair<Rope, std::pair<mfecovar, double> >  l_0 = p_p_e.first;
  TUSubsequence l_1 = p_p_rb;
  intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  r_0 = p_p_e.second;
  TUSubsequence r_1 = p_p_rb;
  std::pair<Rope, std::pair<mfecovar, double> >  ret_left = addss(l_0, l_1);
  intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  ret_right = addss_bt_r(r_0, r_1);
  std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  probs_a_microstate::bl_bt(const TUSubsequence & p_p_lb, const TUSubsequence & p_p_lregion, const std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > & p_p_e, const TUSubsequence & p_p_rb)
{
  TUSubsequence l_0 = p_p_lb;
  TUSubsequence l_1 = p_p_lregion;
  std::pair<Rope, std::pair<mfecovar, double> >  l_2 = p_p_e.first;
  TUSubsequence l_3 = p_p_rb;
  TUSubsequence r_0 = p_p_lb;
  TUSubsequence r_1 = p_p_lregion;
  intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  r_2 = p_p_e.second;
  TUSubsequence r_3 = p_p_rb;
  std::pair<Rope, std::pair<mfecovar, double> >  ret_left = bl(l_0, l_1, l_2, l_3);
  intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  ret_right = bl_bt_r(r_0, r_1, r_2, r_3);
  std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  probs_a_microstate::br_bt(const TUSubsequence & p_p_lb, const std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > & p_p_e, const TUSubsequence & p_p_rregion, const TUSubsequence & p_p_rb)
{
  TUSubsequence l_0 = p_p_lb;
  std::pair<Rope, std::pair<mfecovar, double> >  l_1 = p_p_e.first;
  TUSubsequence l_2 = p_p_rregion;
  TUSubsequence l_3 = p_p_rb;
  TUSubsequence r_0 = p_p_lb;
  intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  r_1 = p_p_e.second;
  TUSubsequence r_2 = p_p_rregion;
  TUSubsequence r_3 = p_p_rb;
  std::pair<Rope, std::pair<mfecovar, double> >  ret_left = br(l_0, l_1, l_2, l_3);
  intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  ret_right = br_bt_r(r_0, r_1, r_2, r_3);
  std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  probs_a_microstate::cadd_bt(const std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > & p_p_le, const std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > & p_p_re)
{
  std::pair<Rope, std::pair<mfecovar, double> >  l_0 = p_p_le.first;
  std::pair<Rope, std::pair<mfecovar, double> >  l_1 = p_p_re.first;
  intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  r_0 = p_p_le.second;
  intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  r_1 = p_p_re.second;
  std::pair<Rope, std::pair<mfecovar, double> >  ret_left = cadd(l_0, l_1);
  intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  ret_right = cadd_bt_r(r_0, r_1);
  std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  probs_a_microstate::drem_bt(const TUSubsequence & p_p_lloc, const std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > & p_p_e, const TUSubsequence & p_p_rloc)
{
  TUSubsequence l_0 = p_p_lloc;
  std::pair<Rope, std::pair<mfecovar, double> >  l_1 = p_p_e.first;
  TUSubsequence l_2 = p_p_rloc;
  TUSubsequence r_0 = p_p_lloc;
  intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  r_1 = p_p_e.second;
  TUSubsequence r_2 = p_p_rloc;
  std::pair<Rope, std::pair<mfecovar, double> >  ret_left = drem(l_0, l_1, l_2);
  intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  ret_right = drem_bt_r(r_0, r_1, r_2);
  std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  probs_a_microstate::edl_bt(const TUSubsequence & p_p_lb, const std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > & p_p_e, const TUSubsequence & p_p_rloc)
{
  TUSubsequence l_0 = p_p_lb;
  std::pair<Rope, std::pair<mfecovar, double> >  l_1 = p_p_e.first;
  TUSubsequence l_2 = p_p_rloc;
  TUSubsequence r_0 = p_p_lb;
  intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  r_1 = p_p_e.second;
  TUSubsequence r_2 = p_p_rloc;
  std::pair<Rope, std::pair<mfecovar, double> >  ret_left = edl(l_0, l_1, l_2);
  intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  ret_right = edl_bt_r(r_0, r_1, r_2);
  std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  probs_a_microstate::edlr_bt(const TUSubsequence & p_p_lb, const std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > & p_p_e, const TUSubsequence & p_p_rb)
{
  TUSubsequence l_0 = p_p_lb;
  std::pair<Rope, std::pair<mfecovar, double> >  l_1 = p_p_e.first;
  TUSubsequence l_2 = p_p_rb;
  TUSubsequence r_0 = p_p_lb;
  intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  r_1 = p_p_e.second;
  TUSubsequence r_2 = p_p_rb;
  std::pair<Rope, std::pair<mfecovar, double> >  ret_left = edlr(l_0, l_1, l_2);
  intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  ret_right = edlr_bt_r(r_0, r_1, r_2);
  std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  probs_a_microstate::edr_bt(const TUSubsequence & p_p_lloc, const std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > & p_p_e, const TUSubsequence & p_p_rb)
{
  TUSubsequence l_0 = p_p_lloc;
  std::pair<Rope, std::pair<mfecovar, double> >  l_1 = p_p_e.first;
  TUSubsequence l_2 = p_p_rb;
  TUSubsequence r_0 = p_p_lloc;
  intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  r_1 = p_p_e.second;
  TUSubsequence r_2 = p_p_rb;
  std::pair<Rope, std::pair<mfecovar, double> >  ret_left = edr(l_0, l_1, l_2);
  intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  ret_right = edr_bt_r(r_0, r_1, r_2);
  std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > probs_a_microstate::h_bt(List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > i, probs_a_microstate_hash_h &  left_answers)
{
  std::pair<List<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > >::iterator, List<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > >::iterator> range = get_range(i);
  return h_bt(range);
}

template <typename Iterator>
List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > probs_a_microstate::h_bt(std::pair<Iterator, Iterator> i, probs_a_microstate_hash_h &  left_answers)

{
  List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > answers;
  empty(answers);
  empty( answers);


  if (isEmpty(left_answers))
  {
    List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > temp;
    empty(temp);
    empty( temp);
    erase( left_answers);
    return temp;
  }

  for (probs_a_microstate_hash_h::iterator elem = left_answers.ref().begin(); elem!=left_answers.ref().end(); ++elem){
    for (Iterator tupel = i.first; tupel != i.second; ++tupel) {
      if (((*tupel).first == (*elem)))
      {
        push_back( answers, (*tupel));
        break;
      }

    }
  }
  return answers;
}

List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > probs_a_microstate::h_bt(List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > i)
{
  std::pair<List<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > >::iterator, List<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > >::iterator> range = get_range(i);
  return h_bt(range);
}

template <typename Iterator>
List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > probs_a_microstate::h_bt(std::pair<Iterator, Iterator> i)

{
  List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > answers;
  empty(answers);
  empty( answers);
  std::pair<Proxy::Iterator<Iterator, select1st<typename Iterator::value_type> >  ,Proxy::Iterator<Iterator, select1st<typename Iterator::value_type> > >  left = splice_left(i);
  probs_a_microstate_hash_h left_answers = h(left);
  if (isEmpty(left_answers))
  {
    List_Ref<std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > > temp;
    empty(temp);
    empty( temp);
    erase( left_answers);
    return temp;
  }

  for (probs_a_microstate_hash_h::iterator elem = left_answers.ref().begin(); elem!=left_answers.ref().end(); ++elem){
    for (Iterator tupel = i.first; tupel != i.second; ++tupel) {
      if (((*tupel).first == (*elem)))
      {
        push_back( answers, (*tupel));
        break;
      }

    }
  }
  return answers;
}

std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  probs_a_microstate::hl_bt(const TUSubsequence & p_p_lb, const TUSubsequence & p_p_region, const TUSubsequence & p_p_rb)
{
  TUSubsequence l_0 = p_p_lb;
  TUSubsequence l_1 = p_p_region;
  TUSubsequence l_2 = p_p_rb;
  TUSubsequence r_0 = p_p_lb;
  TUSubsequence r_1 = p_p_region;
  TUSubsequence r_2 = p_p_rb;
  std::pair<Rope, std::pair<mfecovar, double> >  ret_left = hl(l_0, l_1, l_2);
  intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  ret_right = hl_bt_r(r_0, r_1, r_2);
  std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  probs_a_microstate::il_bt(const TUSubsequence & p_p_lb, const TUSubsequence & p_p_lregion, const std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > & p_p_e, const TUSubsequence & p_p_rregion, const TUSubsequence & p_p_rb)
{
  TUSubsequence l_0 = p_p_lb;
  TUSubsequence l_1 = p_p_lregion;
  std::pair<Rope, std::pair<mfecovar, double> >  l_2 = p_p_e.first;
  TUSubsequence l_3 = p_p_rregion;
  TUSubsequence l_4 = p_p_rb;
  TUSubsequence r_0 = p_p_lb;
  TUSubsequence r_1 = p_p_lregion;
  intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  r_2 = p_p_e.second;
  TUSubsequence r_3 = p_p_rregion;
  TUSubsequence r_4 = p_p_rb;
  std::pair<Rope, std::pair<mfecovar, double> >  ret_left = il(l_0, l_1, l_2, l_3, l_4);
  intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  ret_right = il_bt_r(r_0, r_1, r_2, r_3, r_4);
  std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  probs_a_microstate::incl_bt(const std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > & p_p_e)
{
  std::pair<Rope, std::pair<mfecovar, double> >  l_0 = p_p_e.first;
  intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  r_0 = p_p_e.second;
  std::pair<Rope, std::pair<mfecovar, double> >  ret_left = incl(l_0);
  intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  ret_right = incl_bt_r(r_0);
  std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  probs_a_microstate::ml_bt(const TUSubsequence & p_p_lb, const std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > & p_p_e, const TUSubsequence & p_p_rb)
{
  TUSubsequence l_0 = p_p_lb;
  std::pair<Rope, std::pair<mfecovar, double> >  l_1 = p_p_e.first;
  TUSubsequence l_2 = p_p_rb;
  TUSubsequence r_0 = p_p_lb;
  intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  r_1 = p_p_e.second;
  TUSubsequence r_2 = p_p_rb;
  std::pair<Rope, std::pair<mfecovar, double> >  ret_left = ml(l_0, l_1, l_2);
  intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  ret_right = ml_bt_r(r_0, r_1, r_2);
  std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  probs_a_microstate::mldl_bt(const TUSubsequence & p_p_lb, const TUSubsequence & p_p_dl, const std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > & p_p_e, const TUSubsequence & p_p_rb)
{
  TUSubsequence l_0 = p_p_lb;
  TUSubsequence l_1 = p_p_dl;
  std::pair<Rope, std::pair<mfecovar, double> >  l_2 = p_p_e.first;
  TUSubsequence l_3 = p_p_rb;
  TUSubsequence r_0 = p_p_lb;
  TUSubsequence r_1 = p_p_dl;
  intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  r_2 = p_p_e.second;
  TUSubsequence r_3 = p_p_rb;
  std::pair<Rope, std::pair<mfecovar, double> >  ret_left = mldl(l_0, l_1, l_2, l_3);
  intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  ret_right = mldl_bt_r(r_0, r_1, r_2, r_3);
  std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  probs_a_microstate::mldlr_bt(const TUSubsequence & p_p_lb, const TUSubsequence & p_p_dl, const std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > & p_p_e, const TUSubsequence & p_p_dr, const TUSubsequence & p_p_rb)
{
  TUSubsequence l_0 = p_p_lb;
  TUSubsequence l_1 = p_p_dl;
  std::pair<Rope, std::pair<mfecovar, double> >  l_2 = p_p_e.first;
  TUSubsequence l_3 = p_p_dr;
  TUSubsequence l_4 = p_p_rb;
  TUSubsequence r_0 = p_p_lb;
  TUSubsequence r_1 = p_p_dl;
  intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  r_2 = p_p_e.second;
  TUSubsequence r_3 = p_p_dr;
  TUSubsequence r_4 = p_p_rb;
  std::pair<Rope, std::pair<mfecovar, double> >  ret_left = mldlr(l_0, l_1, l_2, l_3, l_4);
  intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  ret_right = mldlr_bt_r(r_0, r_1, r_2, r_3, r_4);
  std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  probs_a_microstate::mldr_bt(const TUSubsequence & p_p_lb, const std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > & p_p_e, const TUSubsequence & p_p_dr, const TUSubsequence & p_p_rb)
{
  TUSubsequence l_0 = p_p_lb;
  std::pair<Rope, std::pair<mfecovar, double> >  l_1 = p_p_e.first;
  TUSubsequence l_2 = p_p_dr;
  TUSubsequence l_3 = p_p_rb;
  TUSubsequence r_0 = p_p_lb;
  intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  r_1 = p_p_e.second;
  TUSubsequence r_2 = p_p_dr;
  TUSubsequence r_3 = p_p_rb;
  std::pair<Rope, std::pair<mfecovar, double> >  ret_left = mldr(l_0, l_1, l_2, l_3);
  intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  ret_right = mldr_bt_r(r_0, r_1, r_2, r_3);
  std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  probs_a_microstate::nil_bt(const TUSubsequence & p_p_loc)
{
  TUSubsequence l_0 = p_p_loc;
  TUSubsequence r_0 = p_p_loc;
  std::pair<Rope, std::pair<mfecovar, double> >  ret_left = nil(l_0);
  intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  ret_right = nil_bt_r(r_0);
  std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  probs_a_microstate::sadd_bt(const TUSubsequence & p_p_b, const std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > & p_p_e)
{
  TUSubsequence l_0 = p_p_b;
  std::pair<Rope, std::pair<mfecovar, double> >  l_1 = p_p_e.first;
  TUSubsequence r_0 = p_p_b;
  intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  r_1 = p_p_e.second;
  std::pair<Rope, std::pair<mfecovar, double> >  ret_left = sadd(l_0, l_1);
  intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  ret_right = sadd_bt_r(r_0, r_1);
  std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}

std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  probs_a_microstate::sr_bt(const TUSubsequence & p_p_lb, const std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > > & p_p_e, const TUSubsequence & p_p_rb)
{
  TUSubsequence l_0 = p_p_lb;
  std::pair<Rope, std::pair<mfecovar, double> >  l_1 = p_p_e.first;
  TUSubsequence l_2 = p_p_rb;
  TUSubsequence r_0 = p_p_lb;
  intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  r_1 = p_p_e.second;
  TUSubsequence r_2 = p_p_rb;
  std::pair<Rope, std::pair<mfecovar, double> >  ret_left = sr(l_0, l_1, l_2);
  intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> >  ret_right = sr_bt_r(r_0, r_1, r_2);
  std::pair<std::pair<Rope, std::pair<mfecovar, double> > , intrusive_ptr<Backtrace<std::pair<String, double> , unsigned int> > >  ret;
  ret.first = ret_left;
  ret.second = ret_right;
  return ret;
}


