
// A dynamic programming evaluator generated by GAP-C.
// 
//   GAP-C version:
//     bellmansgapc-2013.01.16
// 
//   GAP-C call:
//     /home/jhuang/gapc/bin/gapc ali_microstate_HISHAPES.gap -i hishapehmfepp -o aliHishapes.cc -t --kbest --kbacktrace 
// 
// 


#ifndef aliHishapes_hh
#define aliHishapes_hh

#include "rtlib/adp.hh"

typedef Basic_Subsequence<M_Char, unsigned> TUSubsequence;

typedef Shape shape_t;
#include <rtlib/subopt.hh>
#include "rna.hh"
#include "alifold.hh"

#include <rtlib/generic_opts.hh>

class aliHishapes_insp_hash_h {
public:
typedef std::pair<Rope, mfecovar>  type;
private:
static uint32_t k_;
public:
uint32_t hash(const type &x) const
{
return hashable_value(left_most(x));
}
type init(const type &src) const
{
type dst(src);
{
  return src;
}
}
void update(type &dst, const type &src) 
{
  if ((src.second < dst.second))
    {
      dst.second = src.second;
    }

}
bool equal(const type &a, const type &b) const
{
return left_most(a) == left_most(b);
}
bool filter() const { return false; }
bool filter(const type &x) const
{
assert(0); return false;
}
void finalize(type &src) const
{
}
static void set_k(uint32_t a) { k_ = a; }
uint32_t k() const
{
  return k_;
}
bool cutoff() const
{
  return true;
}
bool equal_score(const type &src, const type &dst) const
{
  return (src.second == dst.second);
}
struct compare {
bool operator()(const type &src, const type &dst) const
{
  return (src.second < dst.second);
}
};
};

typedef Hash::Ref<std::pair<Rope, mfecovar> , aliHishapes_insp_hash_h > aliHishapes_hash_h;


class aliHishapes {

  public:
Basic_Sequence<M_Char> t_0_seq;
unsigned int t_0_left_most;
unsigned int t_0_right_most;

aliHishapes_hash_h LBRope_firstG_mfecovar_secondG_EMhdecl0x1f4cd30_zero;
std::pair<Rope, mfecovar>  BRope_firstG_mfecovar_secondG_E_zero;

class dangle_table_t {

private:

unsigned int t_0_left_most;
unsigned int t_0_right_most;
std::vector<aliHishapes_hash_h > array;
std::vector<bool> tabulated;
unsigned int t_0_n;
aliHishapes_hash_h zero;
unsigned int size()
{
  return (1 * ((((t_0_n * (t_0_n + 1)) / 2) + t_0_n) + 1));
}


public:

dangle_table_t()
{
  empty(zero);
}

void init(unsigned int t_0_n_, const std::string &tname)
{
t_0_n = t_0_n_;
t_0_left_most = 0;
t_0_right_most = t_0_n;
unsigned int newsize = size();
array.resize(newsize);
tabulated.clear();
tabulated.resize(newsize);
}
bool is_tabulated(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 5))
    {
      return true;
    }

  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  return tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void clear() { tabulated.clear(); }
aliHishapes_hash_h &  get(unsigned int t_0_i, unsigned int t_0_j)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 5))
    {
      return zero;
    }

  assert( tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))]);
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  return array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void set(unsigned int t_0_i, unsigned int t_0_j,  const aliHishapes_hash_h &  e)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 5))
    {
      assert( 0);
    }

  assert( !is_tabulated(t_0_i, t_0_j));
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = e;
  tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = true;
}


};
dangle_table_t dangle_table;


class iloop_table_t {

private:

unsigned int t_0_left_most;
unsigned int t_0_right_most;
std::vector<aliHishapes_hash_h > array;
std::vector<bool> tabulated;
unsigned int t_0_n;
aliHishapes_hash_h zero;
unsigned int size()
{
  return (1 * ((((t_0_n * (t_0_n + 1)) / 2) + t_0_n) + 1));
}


public:

iloop_table_t()
{
  empty(zero);
}

void init(unsigned int t_0_n_, const std::string &tname)
{
t_0_n = t_0_n_;
t_0_left_most = 0;
t_0_right_most = t_0_n;
unsigned int newsize = size();
array.resize(newsize);
tabulated.clear();
tabulated.resize(newsize);
}
bool is_tabulated(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 9))
    {
      return true;
    }

  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  return tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void clear() { tabulated.clear(); }
aliHishapes_hash_h &  get(unsigned int t_0_i, unsigned int t_0_j)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 9))
    {
      return zero;
    }

  assert( tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))]);
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  return array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void set(unsigned int t_0_i, unsigned int t_0_j,  const aliHishapes_hash_h &  e)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 9))
    {
      assert( 0);
    }

  assert( !is_tabulated(t_0_i, t_0_j));
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = e;
  tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = true;
}


};
iloop_table_t iloop_table;


class ml_comps_table_t {

private:

unsigned int t_0_left_most;
unsigned int t_0_right_most;
std::vector<aliHishapes_hash_h > array;
std::vector<bool> tabulated;
unsigned int t_0_n;
aliHishapes_hash_h zero;
unsigned int size()
{
  return (1 * ((((t_0_n * (t_0_n + 1)) / 2) + t_0_n) + 1));
}


public:

ml_comps_table_t()
{
  empty(zero);
}

void init(unsigned int t_0_n_, const std::string &tname)
{
t_0_n = t_0_n_;
t_0_left_most = 0;
t_0_right_most = t_0_n;
unsigned int newsize = size();
array.resize(newsize);
tabulated.clear();
tabulated.resize(newsize);
}
bool is_tabulated(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 10))
    {
      return true;
    }

  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  return tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void clear() { tabulated.clear(); }
aliHishapes_hash_h &  get(unsigned int t_0_i, unsigned int t_0_j)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 10))
    {
      return zero;
    }

  assert( tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))]);
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  return array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void set(unsigned int t_0_i, unsigned int t_0_j,  const aliHishapes_hash_h &  e)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 10))
    {
      assert( 0);
    }

  assert( !is_tabulated(t_0_i, t_0_j));
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = e;
  tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = true;
}


};
ml_comps_table_t ml_comps_table;


class ml_comps1_table_t {

private:

unsigned int t_0_left_most;
unsigned int t_0_right_most;
std::vector<aliHishapes_hash_h > array;
std::vector<bool> tabulated;
unsigned int t_0_n;
aliHishapes_hash_h zero;
unsigned int size()
{
  return (1 * ((((t_0_n * (t_0_n + 1)) / 2) + t_0_n) + 1));
}


public:

ml_comps1_table_t()
{
  empty(zero);
}

void init(unsigned int t_0_n_, const std::string &tname)
{
t_0_n = t_0_n_;
t_0_left_most = 0;
t_0_right_most = t_0_n;
unsigned int newsize = size();
array.resize(newsize);
tabulated.clear();
tabulated.resize(newsize);
}
bool is_tabulated(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 5))
    {
      return true;
    }

  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  return tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void clear() { tabulated.clear(); }
aliHishapes_hash_h &  get(unsigned int t_0_i, unsigned int t_0_j)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 5))
    {
      return zero;
    }

  assert( tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))]);
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  return array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void set(unsigned int t_0_i, unsigned int t_0_j,  const aliHishapes_hash_h &  e)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 5))
    {
      assert( 0);
    }

  assert( !is_tabulated(t_0_i, t_0_j));
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = e;
  tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = true;
}


};
ml_comps1_table_t ml_comps1_table;


class strong_table_t {

private:

unsigned int t_0_left_most;
unsigned int t_0_right_most;
std::vector<aliHishapes_hash_h > array;
std::vector<bool> tabulated;
unsigned int t_0_n;
aliHishapes_hash_h zero;
unsigned int size()
{
  return (1 * ((((t_0_n * (t_0_n + 1)) / 2) + t_0_n) + 1));
}


public:

strong_table_t()
{
  empty(zero);
}

void init(unsigned int t_0_n_, const std::string &tname)
{
t_0_n = t_0_n_;
t_0_left_most = 0;
t_0_right_most = t_0_n;
unsigned int newsize = size();
array.resize(newsize);
tabulated.clear();
tabulated.resize(newsize);
}
bool is_tabulated(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 5))
    {
      return true;
    }

  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  return tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void clear() { tabulated.clear(); }
aliHishapes_hash_h &  get(unsigned int t_0_i, unsigned int t_0_j)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 5))
    {
      return zero;
    }

  assert( tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))]);
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  return array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void set(unsigned int t_0_i, unsigned int t_0_j,  const aliHishapes_hash_h &  e)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 5))
    {
      assert( 0);
    }

  assert( !is_tabulated(t_0_i, t_0_j));
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = e;
  tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = true;
}


};
strong_table_t strong_table;


class struct_table_t {

private:

unsigned int t_0_left_most;
unsigned int t_0_right_most;
std::vector<aliHishapes_hash_h > array;
std::vector<bool> tabulated;
unsigned int t_0_n;
aliHishapes_hash_h zero;
unsigned int size()
{
  return (1 * ((t_0_n + 1) * 1));
}


public:

struct_table_t()
{
  empty(zero);
}

void init(unsigned int t_0_n_, const std::string &tname)
{
t_0_n = t_0_n_;
t_0_left_most = 0;
t_0_right_most = t_0_n;
unsigned int newsize = size();
array.resize(newsize);
tabulated.clear();
tabulated.resize(newsize);
}
bool is_tabulated(unsigned int t_0_i)
{
  unsigned int t_0_j = t_0_n;
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if ((t_0_j < (t_0_n - 0)))
    {
      return true;
    }

  unsigned int t_0_real_j = (t_0_n - t_0_j);
  return tabulated[(0 + (1 * (t_0_i + (t_0_real_j * (t_0_n + 1)))))];
}


void clear() { tabulated.clear(); }
aliHishapes_hash_h &  get(unsigned int t_0_i)
{
  unsigned int t_0_j = t_0_n;
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if ((t_0_j < (t_0_n - 0)))
    {
      return zero;
    }

  unsigned int t_0_real_j = (t_0_n - t_0_j);
  assert( tabulated[(0 + (1 * (t_0_i + (t_0_real_j * (t_0_n + 1)))))]);
  assert( ((0 + (1 * (t_0_i + (t_0_real_j * (t_0_n + 1))))) < size()));
  return array[(0 + (1 * (t_0_i + (t_0_real_j * (t_0_n + 1)))))];
}


void set(unsigned int t_0_i,  const aliHishapes_hash_h &  e)
{
  unsigned int t_0_j = t_0_n;
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if ((t_0_j < (t_0_n - 0)))
    {
      return;
    }

  unsigned int t_0_real_j = (t_0_n - t_0_j);
  assert( !is_tabulated(t_0_i));
  assert( ((0 + (1 * (t_0_i + (t_0_real_j * (t_0_n + 1))))) < size()));
  array[(0 + (1 * (t_0_i + (t_0_real_j * (t_0_n + 1)))))] = e;
  tabulated[(0 + (1 * (t_0_i + (t_0_real_j * (t_0_n + 1)))))] = true;
}


};
struct_table_t struct_table;


class weak_table_t {

private:

unsigned int t_0_left_most;
unsigned int t_0_right_most;
std::vector<aliHishapes_hash_h > array;
std::vector<bool> tabulated;
unsigned int t_0_n;
aliHishapes_hash_h zero;
unsigned int size()
{
  return (1 * ((((t_0_n * (t_0_n + 1)) / 2) + t_0_n) + 1));
}


public:

weak_table_t()
{
  empty(zero);
}

void init(unsigned int t_0_n_, const std::string &tname)
{
t_0_n = t_0_n_;
t_0_left_most = 0;
t_0_right_most = t_0_n;
unsigned int newsize = size();
array.resize(newsize);
tabulated.clear();
tabulated.resize(newsize);
}
bool is_tabulated(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 5))
    {
      return true;
    }

  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  return tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void clear() { tabulated.clear(); }
aliHishapes_hash_h &  get(unsigned int t_0_i, unsigned int t_0_j)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 5))
    {
      return zero;
    }

  assert( tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))]);
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  return array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void set(unsigned int t_0_i, unsigned int t_0_j,  const aliHishapes_hash_h &  e)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 5))
    {
      assert( 0);
    }

  assert( !is_tabulated(t_0_i, t_0_j));
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = e;
  tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = true;
}


};
weak_table_t weak_table;



void init(const gapc::Opts &opts)
{
const std::vector<std::pair<const char *, unsigned> > &inp = opts.inputs;
if(inp.size() != 1)
  throw gapc::OptException("Number of input sequences does not match.");

  t_0_seq.copy(inp[0].first, inp[0].second);
char_to_rna(t_0_seq);
  dangle_table.init( t_0_seq.size(), "dangle_table");
  iloop_table.init( t_0_seq.size(), "iloop_table");
  ml_comps_table.init( t_0_seq.size(), "ml_comps_table");
  ml_comps1_table.init( t_0_seq.size(), "ml_comps1_table");
  strong_table.init( t_0_seq.size(), "strong_table");
  struct_table.init( t_0_seq.size(), "struct_table");
  weak_table.init( t_0_seq.size(), "weak_table");
empty(LBRope_firstG_mfecovar_secondG_EMhdecl0x1f4cd30_zero);
empty(BRope_firstG_mfecovar_secondG_E_zero);

t_0_left_most = 0;
t_0_right_most = t_0_seq.size();
aliHishapes_insp_hash_h::set_k(opts.k);
}

  private:
    aliHishapes_hash_h &  nt_dangle(unsigned int t_0_i, unsigned int t_0_j);
    std::pair<Rope, mfecovar>  nt_hairpin(unsigned int t_0_i, unsigned int t_0_j);
    aliHishapes_hash_h &  nt_iloop(unsigned int t_0_i, unsigned int t_0_j);
    aliHishapes_hash_h nt_leftB(unsigned int t_0_i, unsigned int t_0_j);
    aliHishapes_hash_h &  nt_ml_comps(unsigned int t_0_i, unsigned int t_0_j);
    aliHishapes_hash_h &  nt_ml_comps1(unsigned int t_0_i, unsigned int t_0_j);
    aliHishapes_hash_h nt_multiloop(unsigned int t_0_i, unsigned int t_0_j);
    aliHishapes_hash_h nt_rightB(unsigned int t_0_i, unsigned int t_0_j);
    aliHishapes_hash_h nt_stack(unsigned int t_0_i, unsigned int t_0_j);
    aliHishapes_hash_h &  nt_strong(unsigned int t_0_i, unsigned int t_0_j);
    aliHishapes_hash_h &  nt_struct(unsigned int t_0_i);
    aliHishapes_hash_h &  nt_weak(unsigned int t_0_i, unsigned int t_0_j);

    std::pair<Rope, mfecovar>  addss(const std::pair<Rope, mfecovar> & p_e, const TUSubsequence & p_rb);
    std::pair<Rope, mfecovar>  bl(const TUSubsequence & p_lb, const TUSubsequence & p_lregion, const std::pair<Rope, mfecovar> & p_e, const TUSubsequence & p_rb);
    std::pair<Rope, mfecovar>  br(const TUSubsequence & p_lb, const std::pair<Rope, mfecovar> & p_e, const TUSubsequence & p_rregion, const TUSubsequence & p_rb);
    std::pair<Rope, mfecovar>  cadd(const std::pair<Rope, mfecovar> & p_le, const std::pair<Rope, mfecovar> & p_re);
    std::pair<Rope, mfecovar>  drem(const TUSubsequence & p_lloc, const std::pair<Rope, mfecovar> & p_e, const TUSubsequence & p_rloc);
    std::pair<Rope, mfecovar>  edl(const TUSubsequence & p_lb, const std::pair<Rope, mfecovar> & p_e, const TUSubsequence & p_rloc);
    std::pair<Rope, mfecovar>  edlr(const TUSubsequence & p_lb, const std::pair<Rope, mfecovar> & p_e, const TUSubsequence & p_rb);
    std::pair<Rope, mfecovar>  edr(const TUSubsequence & p_lloc, const std::pair<Rope, mfecovar> & p_e, const TUSubsequence & p_rb);
template <typename Iterator>
    aliHishapes_hash_h h(std::pair<Iterator, Iterator> i)
;
    std::pair<Rope, mfecovar>  hl(const TUSubsequence & p_lb, const TUSubsequence & p_region, const TUSubsequence & p_rb);
    std::pair<Rope, mfecovar>  il(const TUSubsequence & p_lb, const TUSubsequence & p_lregion, const std::pair<Rope, mfecovar> & p_e, const TUSubsequence & p_rregion, const TUSubsequence & p_rb);
    std::pair<Rope, mfecovar>  incl(const std::pair<Rope, mfecovar> & p_e);
    std::pair<Rope, mfecovar>  ml(const TUSubsequence & p_lb, const std::pair<Rope, mfecovar> & p_e, const TUSubsequence & p_rb);
    std::pair<Rope, mfecovar>  mldl(const TUSubsequence & p_lb, const TUSubsequence & p_dl, const std::pair<Rope, mfecovar> & p_e, const TUSubsequence & p_rb);
    std::pair<Rope, mfecovar>  mldlr(const TUSubsequence & p_lb, const TUSubsequence & p_dl, const std::pair<Rope, mfecovar> & p_e, const TUSubsequence & p_dr, const TUSubsequence & p_rb);
    std::pair<Rope, mfecovar>  mldr(const TUSubsequence & p_lb, const std::pair<Rope, mfecovar> & p_e, const TUSubsequence & p_dr, const TUSubsequence & p_rb);
    std::pair<Rope, mfecovar>  nil(const TUSubsequence & p_loc);
    std::pair<Rope, mfecovar>  sadd(const TUSubsequence & p_b, const std::pair<Rope, mfecovar> & p_e);
    std::pair<Rope, mfecovar>  sr(const TUSubsequence & p_lb, const std::pair<Rope, mfecovar> & p_e, const TUSubsequence & p_rb);


    Rope addss_l(const Rope & e, const TUSubsequence & rb);
    Rope bl_l(const TUSubsequence & lb, const TUSubsequence & lregion, const Rope & e, const TUSubsequence & rb);
    Rope br_l(const TUSubsequence & lb, const Rope & e, const TUSubsequence & rregion, const TUSubsequence & rb);
    Rope cadd_l(const Rope & le, const Rope & re);
    Rope drem_l(const TUSubsequence & lloc, const Rope & e, const TUSubsequence & rloc);
    Rope edl_l(const TUSubsequence & lb, const Rope & e, const TUSubsequence & rloc);
    Rope edlr_l(const TUSubsequence & lb, const Rope & e, const TUSubsequence & rb);
    Rope edr_l(const TUSubsequence & lloc, const Rope & e, const TUSubsequence & rb);
    Rope hl_l(const TUSubsequence & lb, const TUSubsequence & region, const TUSubsequence & rb);
    Rope il_l(const TUSubsequence & lb, const TUSubsequence & lregion, const Rope & e, const TUSubsequence & rregion, const TUSubsequence & rb);
    Rope incl_l(const Rope & e);
    Rope ml_l(const TUSubsequence & lb, const Rope & e, const TUSubsequence & rb);
    Rope mldl_l(const TUSubsequence & lb, const TUSubsequence & dl, const Rope & e, const TUSubsequence & rb);
    Rope mldlr_l(const TUSubsequence & lb, const TUSubsequence & dl, const Rope & e, const TUSubsequence & dr, const TUSubsequence & rb);
    Rope mldr_l(const TUSubsequence & lb, const Rope & e, const TUSubsequence & dr, const TUSubsequence & rb);
    Rope nil_l(const TUSubsequence & loc);
    Rope sadd_l(const TUSubsequence & b, const Rope & e);
    Rope sr_l(const TUSubsequence & lb, const Rope & e, const TUSubsequence & rb);


    mfecovar addss_r(const mfecovar & x, const TUSubsequence & r);
    mfecovar bl_r(const TUSubsequence & lb, const TUSubsequence & lr, const mfecovar & x, const TUSubsequence & rb);
    mfecovar br_r(const TUSubsequence & lb, const mfecovar & x, const TUSubsequence & rr, const TUSubsequence & rb);
    mfecovar cadd_r(const mfecovar & x, const mfecovar & y);
    mfecovar drem_r(const TUSubsequence & lb, const mfecovar & x, const TUSubsequence & rb);
    mfecovar edl_r(const TUSubsequence & ldangle, const mfecovar & x, const TUSubsequence & rb);
    mfecovar edlr_r(const TUSubsequence & ldangle, const mfecovar & x, const TUSubsequence & rdangle);
    mfecovar edr_r(const TUSubsequence & lb, const mfecovar & x, const TUSubsequence & rdangle);
    mfecovar hl_r(const TUSubsequence & lb, const TUSubsequence & r, const TUSubsequence & rb);
    mfecovar il_r(const TUSubsequence & lb, const TUSubsequence & lr, const mfecovar & x, const TUSubsequence & rr, const TUSubsequence & rb);
    mfecovar incl_r(const mfecovar & x);
    mfecovar ml_r(const TUSubsequence & lb, const mfecovar & x, const TUSubsequence & rb);
    mfecovar mldl_r(const TUSubsequence & lb, const TUSubsequence & dl, const mfecovar & x, const TUSubsequence & rb);
    mfecovar mldlr_r(const TUSubsequence & lb, const TUSubsequence & dl, const mfecovar & x, const TUSubsequence & dr, const TUSubsequence & rb);
    mfecovar mldr_r(const TUSubsequence & lb, const mfecovar & x, const TUSubsequence & dr, const TUSubsequence & rb);
    mfecovar nil_r(const TUSubsequence & n);
    mfecovar sadd_r(const TUSubsequence & lb, const mfecovar & x);
    mfecovar sr_r(const TUSubsequence & lb, const mfecovar & x, const TUSubsequence & rb);


 public:
   void cyk();

 public:
   aliHishapes_hash_h &  run()
{
  return nt_struct(t_0_left_most);
}
void print_stats(std::ostream &o)
{
#ifdef STATS
      o << "\n\nN = " << seq.size() << '\n';
      dangle_table.print_stats(o, "dangle_table");
      iloop_table.print_stats(o, "iloop_table");
      ml_comps_table.print_stats(o, "ml_comps_table");
      ml_comps1_table.print_stats(o, "ml_comps1_table");
      strong_table.print_stats(o, "strong_table");
      struct_table.print_stats(o, "struct_table");
      weak_table.print_stats(o, "weak_table");
#endif
}

template <typename Value, typename pos_int>
struct Backtrace_addss : Backtrace_Score<std::pair<Rope, mfecovar> , Value, pos_int> {
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_e;
      TUSubsequence arg_rb;

Backtrace_addss(intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_, TUSubsequence arg_rb_)
 : arg_e(arg_e_), arg_rb(arg_rb_)
{}

~Backtrace_addss()
{
erase(arg_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      String addss(const String & e, const TUSubsequence & rb)
      {
#line 262 ""
        String res;
        append( res, e);
        append( res, '.', size(rb));
        return res;
#line 798 ""
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_e);
        if (!arg_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = arg_e;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = addss(arg_e_elem, arg_rb);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_e_bt_itr = arg_e_t->begin(); arg_e_bt_itr != arg_e_t->end(); ++ arg_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = *arg_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = addss(arg_e_elem, arg_rb);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        }
        erase( arg_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_bl : Backtrace_Score<std::pair<Rope, mfecovar> , Value, pos_int> {
      TUSubsequence arg_lb;
      TUSubsequence arg_lregion;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_e;
      TUSubsequence arg_rb;

Backtrace_bl(TUSubsequence arg_lb_, TUSubsequence arg_lregion_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_, TUSubsequence arg_rb_)
 : arg_lb(arg_lb_), arg_lregion(arg_lregion_), arg_e(arg_e_), arg_rb(arg_rb_)
{}

~Backtrace_bl()
{
erase(arg_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      String bl(const TUSubsequence & lb, const TUSubsequence & lregion, const String & e, const TUSubsequence & rb)
      {
#line 150 ""
        String res;
        append( res, '(');
        append( res, '.', size(lregion));
        append( res, e);
        append( res, ')');
        return res;
#line 860 ""
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_e);
        if (!arg_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = arg_e;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = bl(arg_lb, arg_lregion, arg_e_elem, arg_rb);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_e_bt_itr = arg_e_t->begin(); arg_e_bt_itr != arg_e_t->end(); ++ arg_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = *arg_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = bl(arg_lb, arg_lregion, arg_e_elem, arg_rb);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        }
        erase( arg_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_br : Backtrace_Score<std::pair<Rope, mfecovar> , Value, pos_int> {
      TUSubsequence arg_lb;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_e;
      TUSubsequence arg_rregion;
      TUSubsequence arg_rb;

Backtrace_br(TUSubsequence arg_lb_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_, TUSubsequence arg_rregion_, TUSubsequence arg_rb_)
 : arg_lb(arg_lb_), arg_e(arg_e_), arg_rregion(arg_rregion_), arg_rb(arg_rb_)
{}

~Backtrace_br()
{
erase(arg_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      String br(const TUSubsequence & lb, const String & e, const TUSubsequence & rregion, const TUSubsequence & rb)
      {
#line 159 ""
        String res;
        append( res, '(');
        append( res, e);
        append( res, '.', size(rregion));
        append( res, ')');
        return res;
#line 922 ""
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_e);
        if (!arg_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = arg_e;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = br(arg_lb, arg_e_elem, arg_rregion, arg_rb);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_e_bt_itr = arg_e_t->begin(); arg_e_bt_itr != arg_e_t->end(); ++ arg_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = *arg_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = br(arg_lb, arg_e_elem, arg_rregion, arg_rb);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        }
        erase( arg_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_cadd : Backtrace_Score<std::pair<Rope, mfecovar> , Value, pos_int> {
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_le;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_re;

Backtrace_cadd(intrusive_ptr<Backtrace<Value, pos_int> >  arg_le_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_re_)
 : arg_le(arg_le_), arg_re(arg_re_)
{}

~Backtrace_cadd()
{
erase(arg_le);
erase(arg_re);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      String cadd(const String & le, const String & re)
      {
#line 58 ""
        String res;
        append( res, le);
        append( res, re);
        return res;
#line 981 ""
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_le_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_le);
        if (!arg_le_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_le_bt = arg_le;
          intrusive_ptr<Backtrace_List<Value, pos_int> > arg_re_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_re);
          if (!arg_re_t) {
            intrusive_ptr<Backtrace<Value, pos_int> >  arg_re_bt = arg_re;
            intrusive_ptr<Eval_List<Value> > arg_le_elist = evaluate(arg_le_bt);
            intrusive_ptr<Eval_List<Value> > arg_re_elist = evaluate(arg_re_bt);
            for (typename Eval_List<Value>::iterator arg_le_elem_itr = arg_le_elist->begin(); arg_le_elem_itr != arg_le_elist->end(); ++ arg_le_elem_itr) {
              String arg_le_elem = *arg_le_elem_itr;
              for (typename Eval_List<Value>::iterator arg_re_elem_itr = arg_re_elist->begin(); arg_re_elem_itr != arg_re_elist->end(); ++ arg_re_elem_itr) {
                String arg_re_elem = *arg_re_elem_itr;
                String ret = cadd(arg_le_elem, arg_re_elem);
                push_back( answer, ret);
              }
            }
            erase( arg_le_elist);
            erase( arg_re_elist);
          } else 
          for (typename Backtrace_List<Value, pos_int>::iterator arg_re_bt_itr = arg_re_t->begin(); arg_re_bt_itr != arg_re_t->end(); ++ arg_re_bt_itr) {
            intrusive_ptr<Backtrace<Value, pos_int> >  arg_re_bt = *arg_re_bt_itr;
            intrusive_ptr<Eval_List<Value> > arg_le_elist = evaluate(arg_le_bt);
            intrusive_ptr<Eval_List<Value> > arg_re_elist = evaluate(arg_re_bt);
            for (typename Eval_List<Value>::iterator arg_le_elem_itr = arg_le_elist->begin(); arg_le_elem_itr != arg_le_elist->end(); ++ arg_le_elem_itr) {
              String arg_le_elem = *arg_le_elem_itr;
              for (typename Eval_List<Value>::iterator arg_re_elem_itr = arg_re_elist->begin(); arg_re_elem_itr != arg_re_elist->end(); ++ arg_re_elem_itr) {
                String arg_re_elem = *arg_re_elem_itr;
                String ret = cadd(arg_le_elem, arg_re_elem);
                push_back( answer, ret);
              }
            }
            erase( arg_le_elist);
            erase( arg_re_elist);
          }
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_le_bt_itr = arg_le_t->begin(); arg_le_bt_itr != arg_le_t->end(); ++ arg_le_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_le_bt = *arg_le_bt_itr;
          intrusive_ptr<Backtrace_List<Value, pos_int> > arg_re_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_re);
          if (!arg_re_t) {
            intrusive_ptr<Backtrace<Value, pos_int> >  arg_re_bt = arg_re;
            intrusive_ptr<Eval_List<Value> > arg_le_elist = evaluate(arg_le_bt);
            intrusive_ptr<Eval_List<Value> > arg_re_elist = evaluate(arg_re_bt);
            for (typename Eval_List<Value>::iterator arg_le_elem_itr = arg_le_elist->begin(); arg_le_elem_itr != arg_le_elist->end(); ++ arg_le_elem_itr) {
              String arg_le_elem = *arg_le_elem_itr;
              for (typename Eval_List<Value>::iterator arg_re_elem_itr = arg_re_elist->begin(); arg_re_elem_itr != arg_re_elist->end(); ++ arg_re_elem_itr) {
                String arg_re_elem = *arg_re_elem_itr;
                String ret = cadd(arg_le_elem, arg_re_elem);
                push_back( answer, ret);
              }
            }
            erase( arg_le_elist);
            erase( arg_re_elist);
          } else 
          for (typename Backtrace_List<Value, pos_int>::iterator arg_re_bt_itr = arg_re_t->begin(); arg_re_bt_itr != arg_re_t->end(); ++ arg_re_bt_itr) {
            intrusive_ptr<Backtrace<Value, pos_int> >  arg_re_bt = *arg_re_bt_itr;
            intrusive_ptr<Eval_List<Value> > arg_le_elist = evaluate(arg_le_bt);
            intrusive_ptr<Eval_List<Value> > arg_re_elist = evaluate(arg_re_bt);
            for (typename Eval_List<Value>::iterator arg_le_elem_itr = arg_le_elist->begin(); arg_le_elem_itr != arg_le_elist->end(); ++ arg_le_elem_itr) {
              String arg_le_elem = *arg_le_elem_itr;
              for (typename Eval_List<Value>::iterator arg_re_elem_itr = arg_re_elist->begin(); arg_re_elem_itr != arg_re_elist->end(); ++ arg_re_elem_itr) {
                String arg_re_elem = *arg_re_elem_itr;
                String ret = cadd(arg_le_elem, arg_re_elem);
                push_back( answer, ret);
              }
            }
            erase( arg_le_elist);
            erase( arg_re_elist);
          }
        }
        erase( arg_le);
        erase( arg_re);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_drem : Backtrace_Score<std::pair<Rope, mfecovar> , Value, pos_int> {
      TUSubsequence arg_lloc;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_e;
      TUSubsequence arg_rloc;

Backtrace_drem(TUSubsequence arg_lloc_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_, TUSubsequence arg_rloc_)
 : arg_lloc(arg_lloc_), arg_e(arg_e_), arg_rloc(arg_rloc_)
{}

~Backtrace_drem()
{
erase(arg_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      String drem(const TUSubsequence & lloc, const String & e, const TUSubsequence & rloc)
      {
#line 129 ""
        return e;
#line 1086 ""
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_e);
        if (!arg_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = arg_e;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = drem(arg_lloc, arg_e_elem, arg_rloc);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_e_bt_itr = arg_e_t->begin(); arg_e_bt_itr != arg_e_t->end(); ++ arg_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = *arg_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = drem(arg_lloc, arg_e_elem, arg_rloc);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        }
        erase( arg_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_edl : Backtrace_Score<std::pair<Rope, mfecovar> , Value, pos_int> {
      TUSubsequence arg_lb;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_e;
      TUSubsequence arg_loc;

Backtrace_edl(TUSubsequence arg_lb_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_, TUSubsequence arg_loc_)
 : arg_lb(arg_lb_), arg_e(arg_e_), arg_loc(arg_loc_)
{}

~Backtrace_edl()
{
erase(arg_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      String edl(const TUSubsequence & lb, const String & e, const TUSubsequence & loc)
      {
#line 107 ""
        String res;
        append( res, '.');
        append( res, e);
        return res;
#line 1145 ""
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_e);
        if (!arg_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = arg_e;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = edl(arg_lb, arg_e_elem, arg_loc);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_e_bt_itr = arg_e_t->begin(); arg_e_bt_itr != arg_e_t->end(); ++ arg_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = *arg_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = edl(arg_lb, arg_e_elem, arg_loc);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        }
        erase( arg_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_edlr : Backtrace_Score<std::pair<Rope, mfecovar> , Value, pos_int> {
      TUSubsequence arg_lb;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_e;
      TUSubsequence arg_rb;

Backtrace_edlr(TUSubsequence arg_lb_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_, TUSubsequence arg_rb_)
 : arg_lb(arg_lb_), arg_e(arg_e_), arg_rb(arg_rb_)
{}

~Backtrace_edlr()
{
erase(arg_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      String edlr(const TUSubsequence & lb, const String & e, const TUSubsequence & rb)
      {
#line 121 ""
        String res;
        append( res, '.');
        append( res, e);
        append( res, '.');
        return res;
#line 1205 ""
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_e);
        if (!arg_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = arg_e;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = edlr(arg_lb, arg_e_elem, arg_rb);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_e_bt_itr = arg_e_t->begin(); arg_e_bt_itr != arg_e_t->end(); ++ arg_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = *arg_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = edlr(arg_lb, arg_e_elem, arg_rb);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        }
        erase( arg_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_edr : Backtrace_Score<std::pair<Rope, mfecovar> , Value, pos_int> {
      TUSubsequence arg_loc;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_e;
      TUSubsequence arg_rb;

Backtrace_edr(TUSubsequence arg_loc_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_, TUSubsequence arg_rb_)
 : arg_loc(arg_loc_), arg_e(arg_e_), arg_rb(arg_rb_)
{}

~Backtrace_edr()
{
erase(arg_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      String edr(const TUSubsequence & loc, const String & e, const TUSubsequence & rb)
      {
#line 114 ""
        String res;
        append( res, e);
        append( res, '.');
        return res;
#line 1264 ""
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_e);
        if (!arg_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = arg_e;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = edr(arg_loc, arg_e_elem, arg_rb);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_e_bt_itr = arg_e_t->begin(); arg_e_bt_itr != arg_e_t->end(); ++ arg_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = *arg_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = edr(arg_loc, arg_e_elem, arg_rb);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        }
        erase( arg_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_hl : Backtrace_Score<std::pair<Rope, mfecovar> , Value, pos_int> {
      TUSubsequence arg_lb;
      TUSubsequence arg_region;
      TUSubsequence arg_rb;

Backtrace_hl(TUSubsequence arg_lb_, TUSubsequence arg_region_, TUSubsequence arg_rb_)
 : arg_lb(arg_lb_), arg_region(arg_region_), arg_rb(arg_rb_)
{}

~Backtrace_hl()
{
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      String hl(const TUSubsequence & lb, const TUSubsequence & region, const TUSubsequence & rb)
      {
#line 141 ""
        String res;
        append( res, '(');
        append( res, '.', size(region));
        append( res, ')');
        return res;
#line 1323 ""
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        String ret = hl(arg_lb, arg_region, arg_rb);
        push_back( answer, ret);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_il : Backtrace_Score<std::pair<Rope, mfecovar> , Value, pos_int> {
      TUSubsequence arg_lb;
      TUSubsequence arg_lregion;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_e;
      TUSubsequence arg_rregion;
      TUSubsequence arg_rb;

Backtrace_il(TUSubsequence arg_lb_, TUSubsequence arg_lregion_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_, TUSubsequence arg_rregion_, TUSubsequence arg_rb_)
 : arg_lb(arg_lb_), arg_lregion(arg_lregion_), arg_e(arg_e_), arg_rregion(arg_rregion_), arg_rb(arg_rb_)
{}

~Backtrace_il()
{
erase(arg_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      String il(const TUSubsequence & lb, const TUSubsequence & lregion, const String & e, const TUSubsequence & rregion, const TUSubsequence & rb)
      {
#line 168 ""
        String res;
        append( res, '(');
        append( res, '.', size(lregion));
        append( res, e);
        append( res, '.', size(rregion));
        append( res, ')');
        return res;
#line 1367 ""
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_e);
        if (!arg_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = arg_e;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = il(arg_lb, arg_lregion, arg_e_elem, arg_rregion, arg_rb);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_e_bt_itr = arg_e_t->begin(); arg_e_bt_itr != arg_e_t->end(); ++ arg_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = *arg_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = il(arg_lb, arg_lregion, arg_e_elem, arg_rregion, arg_rb);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        }
        erase( arg_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_incl : Backtrace_Score<std::pair<Rope, mfecovar> , Value, pos_int> {
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_e;

Backtrace_incl(intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_)
 : arg_e(arg_e_)
{}

~Backtrace_incl()
{
erase(arg_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      String incl(const String & e)
      {
#line 280 ""
        return e;
#line 1421 ""
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_e);
        if (!arg_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = arg_e;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = incl(arg_e_elem);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_e_bt_itr = arg_e_t->begin(); arg_e_bt_itr != arg_e_t->end(); ++ arg_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = *arg_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = incl(arg_e_elem);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        }
        erase( arg_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_ml : Backtrace_Score<std::pair<Rope, mfecovar> , Value, pos_int> {
      TUSubsequence arg_lb;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_e;
      TUSubsequence arg_rb;

Backtrace_ml(TUSubsequence arg_lb_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_, TUSubsequence arg_rb_)
 : arg_lb(arg_lb_), arg_e(arg_e_), arg_rb(arg_rb_)
{}

~Backtrace_ml()
{
erase(arg_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      String ml(const TUSubsequence & lb, const String & e, const TUSubsequence & rb)
      {
#line 178 ""
        String res;
        append( res, '(');
        append( res, e);
        append( res, ')');
        return res;
#line 1481 ""
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_e);
        if (!arg_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = arg_e;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = ml(arg_lb, arg_e_elem, arg_rb);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_e_bt_itr = arg_e_t->begin(); arg_e_bt_itr != arg_e_t->end(); ++ arg_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = *arg_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = ml(arg_lb, arg_e_elem, arg_rb);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        }
        erase( arg_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_mldl : Backtrace_Score<std::pair<Rope, mfecovar> , Value, pos_int> {
      TUSubsequence arg_lb;
      TUSubsequence arg_dl;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_e;
      TUSubsequence arg_rb;

Backtrace_mldl(TUSubsequence arg_lb_, TUSubsequence arg_dl_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_, TUSubsequence arg_rb_)
 : arg_lb(arg_lb_), arg_dl(arg_dl_), arg_e(arg_e_), arg_rb(arg_rb_)
{}

~Backtrace_mldl()
{
erase(arg_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      String mldl(const TUSubsequence & lb, const TUSubsequence & dl, const String & e, const TUSubsequence & rb)
      {
#line 244 ""
        String res;
        append( res, '(');
        append( res, '.');
        append( res, e);
        append( res, ')');
        return res;
#line 1543 ""
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_e);
        if (!arg_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = arg_e;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = mldl(arg_lb, arg_dl, arg_e_elem, arg_rb);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_e_bt_itr = arg_e_t->begin(); arg_e_bt_itr != arg_e_t->end(); ++ arg_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = *arg_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = mldl(arg_lb, arg_dl, arg_e_elem, arg_rb);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        }
        erase( arg_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_mldlr : Backtrace_Score<std::pair<Rope, mfecovar> , Value, pos_int> {
      TUSubsequence arg_lb;
      TUSubsequence arg_dl;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_e;
      TUSubsequence arg_dr;
      TUSubsequence arg_rb;

Backtrace_mldlr(TUSubsequence arg_lb_, TUSubsequence arg_dl_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_, TUSubsequence arg_dr_, TUSubsequence arg_rb_)
 : arg_lb(arg_lb_), arg_dl(arg_dl_), arg_e(arg_e_), arg_dr(arg_dr_), arg_rb(arg_rb_)
{}

~Backtrace_mldlr()
{
erase(arg_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      String mldlr(const TUSubsequence & lb, const TUSubsequence & dl, const String & e, const TUSubsequence & dr, const TUSubsequence & rb)
      {
#line 204 ""
        String res;
        append( res, '(');
        append( res, '.');
        append( res, e);
        append( res, '.');
        append( res, ')');
        return res;
#line 1607 ""
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_e);
        if (!arg_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = arg_e;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = mldlr(arg_lb, arg_dl, arg_e_elem, arg_dr, arg_rb);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_e_bt_itr = arg_e_t->begin(); arg_e_bt_itr != arg_e_t->end(); ++ arg_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = *arg_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = mldlr(arg_lb, arg_dl, arg_e_elem, arg_dr, arg_rb);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        }
        erase( arg_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_mldr : Backtrace_Score<std::pair<Rope, mfecovar> , Value, pos_int> {
      TUSubsequence arg_lb;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_e;
      TUSubsequence arg_dr;
      TUSubsequence arg_rb;

Backtrace_mldr(TUSubsequence arg_lb_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_, TUSubsequence arg_dr_, TUSubsequence arg_rb_)
 : arg_lb(arg_lb_), arg_e(arg_e_), arg_dr(arg_dr_), arg_rb(arg_rb_)
{}

~Backtrace_mldr()
{
erase(arg_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      String mldr(const TUSubsequence & lb, const String & e, const TUSubsequence & dr, const TUSubsequence & rb)
      {
#line 186 ""
        String res;
        append( res, '(');
        append( res, e);
        append( res, '.');
        append( res, ')');
        return res;
#line 1669 ""
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_e);
        if (!arg_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = arg_e;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = mldr(arg_lb, arg_e_elem, arg_dr, arg_rb);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_e_bt_itr = arg_e_t->begin(); arg_e_bt_itr != arg_e_t->end(); ++ arg_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = *arg_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = mldr(arg_lb, arg_e_elem, arg_dr, arg_rb);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        }
        erase( arg_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_nil : Backtrace_Score<std::pair<Rope, mfecovar> , Value, pos_int> {
      TUSubsequence arg_loc;

Backtrace_nil(TUSubsequence arg_loc_)
 : arg_loc(arg_loc_)
{}

~Backtrace_nil()
{
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      String nil(const TUSubsequence & loc)
      {
#line 102 ""
        String r;
        return r;
#line 1723 ""
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        String ret = nil(arg_loc);
        push_back( answer, ret);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_sadd : Backtrace_Score<std::pair<Rope, mfecovar> , Value, pos_int> {
      TUSubsequence arg_lb;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_e;

Backtrace_sadd(TUSubsequence arg_lb_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_)
 : arg_lb(arg_lb_), arg_e(arg_e_)
{}

~Backtrace_sadd()
{
erase(arg_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      String sadd(const TUSubsequence & lb, const String & e)
      {
#line 51 ""
        String res;
        append( res, '.');
        append( res, e);
        return res;
#line 1761 ""
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_e);
        if (!arg_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = arg_e;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = sadd(arg_lb, arg_e_elem);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_e_bt_itr = arg_e_t->begin(); arg_e_bt_itr != arg_e_t->end(); ++ arg_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = *arg_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = sadd(arg_lb, arg_e_elem);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        }
        erase( arg_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_sr : Backtrace_Score<std::pair<Rope, mfecovar> , Value, pos_int> {
      TUSubsequence arg_lb;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_e;
      TUSubsequence arg_rb;

Backtrace_sr(TUSubsequence arg_lb_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_, TUSubsequence arg_rb_)
 : arg_lb(arg_lb_), arg_e(arg_e_), arg_rb(arg_rb_)
{}

~Backtrace_sr()
{
erase(arg_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      String sr(const TUSubsequence & lb, const String & e, const TUSubsequence & rb)
      {
#line 133 ""
        String res;
        append( res, '(');
        append( res, e);
        append( res, ')');
        return res;
#line 1821 ""
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_e);
        if (!arg_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = arg_e;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = sr(arg_lb, arg_e_elem, arg_rb);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_e_bt_itr = arg_e_t->begin(); arg_e_bt_itr != arg_e_t->end(); ++ arg_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_e_bt = *arg_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_e_elist = evaluate(arg_e_bt);
          for (typename Eval_List<Value>::iterator arg_e_elem_itr = arg_e_elist->begin(); arg_e_elem_itr != arg_e_elist->end(); ++ arg_e_elem_itr) {
            String arg_e_elem = *arg_e_elem_itr;
            String ret = sr(arg_lb, arg_e_elem, arg_rb);
            push_back( answer, ret);
          }
          erase( arg_e_elist);
        }
        erase( arg_e);
        return answer;
      }


};
template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_struct_Back : public Backtrace_NT_Back_Base<std::pair<Rope, mfecovar> , Klass, Value, pos_int>
{
pos_int t_0_i;
Backtrace_nt_struct_Back(Klass *klass_, pos_int t_0_i_)
  : Backtrace_NT_Back_Base<std::pair<Rope, mfecovar> , Klass, Value, pos_int>(klass_), t_0_i(t_0_i_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_struct(t_0_i));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_struct_Front : public Backtrace_Score<std::pair<Rope, mfecovar>  , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_struct_Back<aliHishapes, Value, pos_int> > back;

Backtrace_nt_struct_Front(intrusive_ptr<Backtrace_nt_struct_Back<aliHishapes, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<std::pair<Rope, mfecovar> , aliHishapes, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_dangle_Back : public Backtrace_NT_Back_Base<std::pair<Rope, mfecovar> , Klass, Value, pos_int>
{
pos_int t_0_i;
pos_int t_0_j;
Backtrace_nt_dangle_Back(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_)
  : Backtrace_NT_Back_Base<std::pair<Rope, mfecovar> , Klass, Value, pos_int>(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_dangle(t_0_i, t_0_j));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_dangle_Front : public Backtrace_Score<std::pair<Rope, mfecovar>  , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_dangle_Back<aliHishapes, Value, pos_int> > back;

Backtrace_nt_dangle_Front(intrusive_ptr<Backtrace_nt_dangle_Back<aliHishapes, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<std::pair<Rope, mfecovar> , aliHishapes, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_strong_Back : public Backtrace_NT_Back_Base<std::pair<Rope, mfecovar> , Klass, Value, pos_int>
{
pos_int t_0_i;
pos_int t_0_j;
Backtrace_nt_strong_Back(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_)
  : Backtrace_NT_Back_Base<std::pair<Rope, mfecovar> , Klass, Value, pos_int>(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_strong(t_0_i, t_0_j));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_strong_Front : public Backtrace_Score<std::pair<Rope, mfecovar>  , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_strong_Back<aliHishapes, Value, pos_int> > back;

Backtrace_nt_strong_Front(intrusive_ptr<Backtrace_nt_strong_Back<aliHishapes, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<std::pair<Rope, mfecovar> , aliHishapes, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_weak_Back : public Backtrace_NT_Back_Base<std::pair<Rope, mfecovar> , Klass, Value, pos_int>
{
pos_int t_0_i;
pos_int t_0_j;
Backtrace_nt_weak_Back(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_)
  : Backtrace_NT_Back_Base<std::pair<Rope, mfecovar> , Klass, Value, pos_int>(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_weak(t_0_i, t_0_j));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_weak_Front : public Backtrace_Score<std::pair<Rope, mfecovar>  , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_weak_Back<aliHishapes, Value, pos_int> > back;

Backtrace_nt_weak_Front(intrusive_ptr<Backtrace_nt_weak_Back<aliHishapes, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<std::pair<Rope, mfecovar> , aliHishapes, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_stack_Back : public Backtrace_NT_Back_Base<std::pair<Rope, mfecovar> , Klass, Value, pos_int>
{
pos_int t_0_i;
pos_int t_0_j;
Backtrace_nt_stack_Back(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_)
  : Backtrace_NT_Back_Base<std::pair<Rope, mfecovar> , Klass, Value, pos_int>(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_stack(t_0_i, t_0_j));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_stack_Front : public Backtrace_Score<std::pair<Rope, mfecovar>  , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_stack_Back<aliHishapes, Value, pos_int> > back;

Backtrace_nt_stack_Front(intrusive_ptr<Backtrace_nt_stack_Back<aliHishapes, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<std::pair<Rope, mfecovar> , aliHishapes, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_hairpin_Back : public Backtrace_NT_Back_Base<std::pair<Rope, mfecovar> , Klass, Value, pos_int>
{
pos_int t_0_i;
pos_int t_0_j;
Backtrace_nt_hairpin_Back(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_)
  : Backtrace_NT_Back_Base<std::pair<Rope, mfecovar> , Klass, Value, pos_int>(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_hairpin(t_0_i, t_0_j));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_hairpin_Front : public Backtrace_Score<std::pair<Rope, mfecovar>  , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_hairpin_Back<aliHishapes, Value, pos_int> > back;

Backtrace_nt_hairpin_Front(intrusive_ptr<Backtrace_nt_hairpin_Back<aliHishapes, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<std::pair<Rope, mfecovar> , aliHishapes, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_leftB_Back : public Backtrace_NT_Back_Base<std::pair<Rope, mfecovar> , Klass, Value, pos_int>
{
pos_int t_0_i;
pos_int t_0_j;
Backtrace_nt_leftB_Back(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_)
  : Backtrace_NT_Back_Base<std::pair<Rope, mfecovar> , Klass, Value, pos_int>(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_leftB(t_0_i, t_0_j));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_leftB_Front : public Backtrace_Score<std::pair<Rope, mfecovar>  , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_leftB_Back<aliHishapes, Value, pos_int> > back;

Backtrace_nt_leftB_Front(intrusive_ptr<Backtrace_nt_leftB_Back<aliHishapes, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<std::pair<Rope, mfecovar> , aliHishapes, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_rightB_Back : public Backtrace_NT_Back_Base<std::pair<Rope, mfecovar> , Klass, Value, pos_int>
{
pos_int t_0_i;
pos_int t_0_j;
Backtrace_nt_rightB_Back(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_)
  : Backtrace_NT_Back_Base<std::pair<Rope, mfecovar> , Klass, Value, pos_int>(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_rightB(t_0_i, t_0_j));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_rightB_Front : public Backtrace_Score<std::pair<Rope, mfecovar>  , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_rightB_Back<aliHishapes, Value, pos_int> > back;

Backtrace_nt_rightB_Front(intrusive_ptr<Backtrace_nt_rightB_Back<aliHishapes, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<std::pair<Rope, mfecovar> , aliHishapes, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_iloop_Back : public Backtrace_NT_Back_Base<std::pair<Rope, mfecovar> , Klass, Value, pos_int>
{
pos_int t_0_i;
pos_int t_0_j;
Backtrace_nt_iloop_Back(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_)
  : Backtrace_NT_Back_Base<std::pair<Rope, mfecovar> , Klass, Value, pos_int>(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_iloop(t_0_i, t_0_j));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_iloop_Front : public Backtrace_Score<std::pair<Rope, mfecovar>  , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_iloop_Back<aliHishapes, Value, pos_int> > back;

Backtrace_nt_iloop_Front(intrusive_ptr<Backtrace_nt_iloop_Back<aliHishapes, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<std::pair<Rope, mfecovar> , aliHishapes, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_multiloop_Back : public Backtrace_NT_Back_Base<std::pair<Rope, mfecovar> , Klass, Value, pos_int>
{
pos_int t_0_i;
pos_int t_0_j;
Backtrace_nt_multiloop_Back(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_)
  : Backtrace_NT_Back_Base<std::pair<Rope, mfecovar> , Klass, Value, pos_int>(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_multiloop(t_0_i, t_0_j));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_multiloop_Front : public Backtrace_Score<std::pair<Rope, mfecovar>  , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_multiloop_Back<aliHishapes, Value, pos_int> > back;

Backtrace_nt_multiloop_Front(intrusive_ptr<Backtrace_nt_multiloop_Back<aliHishapes, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<std::pair<Rope, mfecovar> , aliHishapes, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_ml_comps_Back : public Backtrace_NT_Back_Base<std::pair<Rope, mfecovar> , Klass, Value, pos_int>
{
pos_int t_0_i;
pos_int t_0_j;
Backtrace_nt_ml_comps_Back(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_)
  : Backtrace_NT_Back_Base<std::pair<Rope, mfecovar> , Klass, Value, pos_int>(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_ml_comps(t_0_i, t_0_j));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_ml_comps_Front : public Backtrace_Score<std::pair<Rope, mfecovar>  , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_ml_comps_Back<aliHishapes, Value, pos_int> > back;

Backtrace_nt_ml_comps_Front(intrusive_ptr<Backtrace_nt_ml_comps_Back<aliHishapes, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<std::pair<Rope, mfecovar> , aliHishapes, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_ml_comps1_Back : public Backtrace_NT_Back_Base<std::pair<Rope, mfecovar> , Klass, Value, pos_int>
{
pos_int t_0_i;
pos_int t_0_j;
Backtrace_nt_ml_comps1_Back(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_)
  : Backtrace_NT_Back_Base<std::pair<Rope, mfecovar> , Klass, Value, pos_int>(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_ml_comps1(t_0_i, t_0_j));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_ml_comps1_Front : public Backtrace_Score<std::pair<Rope, mfecovar>  , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_ml_comps1_Back<aliHishapes, Value, pos_int> > back;

Backtrace_nt_ml_comps1_Front(intrusive_ptr<Backtrace_nt_ml_comps1_Back<aliHishapes, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<std::pair<Rope, mfecovar> , aliHishapes, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

    List_Ref<std::pair<std::pair<Rope, mfecovar> , intrusive_ptr<Backtrace<String, unsigned int> > > > bt_proxy_nt_struct(unsigned int t_0_i);
    List_Ref<std::pair<std::pair<Rope, mfecovar> , intrusive_ptr<Backtrace<String, unsigned int> > > > bt_proxy_nt_dangle(unsigned int t_0_i, unsigned int t_0_j);
    List_Ref<std::pair<std::pair<Rope, mfecovar> , intrusive_ptr<Backtrace<String, unsigned int> > > > bt_proxy_nt_strong(unsigned int t_0_i, unsigned int t_0_j);
    List_Ref<std::pair<std::pair<Rope, mfecovar> , intrusive_ptr<Backtrace<String, unsigned int> > > > bt_proxy_nt_weak(unsigned int t_0_i, unsigned int t_0_j);
    List_Ref<std::pair<std::pair<Rope, mfecovar> , intrusive_ptr<Backtrace<String, unsigned int> > > > bt_proxy_nt_stack(unsigned int t_0_i, unsigned int t_0_j);
    std::pair<std::pair<Rope, mfecovar> , intrusive_ptr<Backtrace<String, unsigned int> > >  bt_proxy_nt_hairpin(unsigned int t_0_i, unsigned int t_0_j);
    List_Ref<std::pair<std::pair<Rope, mfecovar> , intrusive_ptr<Backtrace<String, unsigned int> > > > bt_proxy_nt_leftB(unsigned int t_0_i, unsigned int t_0_j);
    List_Ref<std::pair<std::pair<Rope, mfecovar> , intrusive_ptr<Backtrace<String, unsigned int> > > > bt_proxy_nt_rightB(unsigned int t_0_i, unsigned int t_0_j);
    List_Ref<std::pair<std::pair<Rope, mfecovar> , intrusive_ptr<Backtrace<String, unsigned int> > > > bt_proxy_nt_iloop(unsigned int t_0_i, unsigned int t_0_j);
    List_Ref<std::pair<std::pair<Rope, mfecovar> , intrusive_ptr<Backtrace<String, unsigned int> > > > bt_proxy_nt_multiloop(unsigned int t_0_i, unsigned int t_0_j);
    List_Ref<std::pair<std::pair<Rope, mfecovar> , intrusive_ptr<Backtrace<String, unsigned int> > > > bt_proxy_nt_ml_comps(unsigned int t_0_i, unsigned int t_0_j);
    List_Ref<std::pair<std::pair<Rope, mfecovar> , intrusive_ptr<Backtrace<String, unsigned int> > > > bt_proxy_nt_ml_comps1(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<String, unsigned int> >  bt_nt_dangle(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<String, unsigned int> >  bt_nt_hairpin(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<String, unsigned int> >  bt_nt_iloop(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<String, unsigned int> >  bt_nt_leftB(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<String, unsigned int> >  bt_nt_ml_comps(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<String, unsigned int> >  bt_nt_ml_comps1(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<String, unsigned int> >  bt_nt_multiloop(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<String, unsigned int> >  bt_nt_rightB(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<String, unsigned int> >  bt_nt_stack(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<String, unsigned int> >  bt_nt_strong(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<String, unsigned int> >  bt_nt_struct(unsigned int t_0_i);
    intrusive_ptr<Backtrace<String, unsigned int> >  bt_nt_weak(unsigned int t_0_i, unsigned int t_0_j);

    intrusive_ptr<Backtrace<String, unsigned int> >  addss_bt_r(intrusive_ptr<Backtrace<String, unsigned int> >  param_0, const TUSubsequence & param_1);
    intrusive_ptr<Backtrace<String, unsigned int> >  bl_bt_r(const TUSubsequence & param_0, const TUSubsequence & param_1, intrusive_ptr<Backtrace<String, unsigned int> >  param_2, const TUSubsequence & param_3);
    intrusive_ptr<Backtrace<String, unsigned int> >  br_bt_r(const TUSubsequence & param_0, intrusive_ptr<Backtrace<String, unsigned int> >  param_1, const TUSubsequence & param_2, const TUSubsequence & param_3);
    intrusive_ptr<Backtrace<String, unsigned int> >  cadd_bt_r(intrusive_ptr<Backtrace<String, unsigned int> >  param_0, intrusive_ptr<Backtrace<String, unsigned int> >  param_1);
    intrusive_ptr<Backtrace<String, unsigned int> >  drem_bt_r(const TUSubsequence & param_0, intrusive_ptr<Backtrace<String, unsigned int> >  param_1, const TUSubsequence & param_2);
    intrusive_ptr<Backtrace<String, unsigned int> >  edl_bt_r(const TUSubsequence & param_0, intrusive_ptr<Backtrace<String, unsigned int> >  param_1, const TUSubsequence & param_2);
    intrusive_ptr<Backtrace<String, unsigned int> >  edlr_bt_r(const TUSubsequence & param_0, intrusive_ptr<Backtrace<String, unsigned int> >  param_1, const TUSubsequence & param_2);
    intrusive_ptr<Backtrace<String, unsigned int> >  edr_bt_r(const TUSubsequence & param_0, intrusive_ptr<Backtrace<String, unsigned int> >  param_1, const TUSubsequence & param_2);
    List_Ref<intrusive_ptr<Backtrace<String, unsigned int> > > h_bt_r(List_Ref<intrusive_ptr<Backtrace<String, unsigned int> > > param_0);
    intrusive_ptr<Backtrace<String, unsigned int> >  hl_bt_r(const TUSubsequence & param_0, const TUSubsequence & param_1, const TUSubsequence & param_2);
    intrusive_ptr<Backtrace<String, unsigned int> >  il_bt_r(const TUSubsequence & param_0, const TUSubsequence & param_1, intrusive_ptr<Backtrace<String, unsigned int> >  param_2, const TUSubsequence & param_3, const TUSubsequence & param_4);
    intrusive_ptr<Backtrace<String, unsigned int> >  incl_bt_r(intrusive_ptr<Backtrace<String, unsigned int> >  param_0);
    intrusive_ptr<Backtrace<String, unsigned int> >  ml_bt_r(const TUSubsequence & param_0, intrusive_ptr<Backtrace<String, unsigned int> >  param_1, const TUSubsequence & param_2);
    intrusive_ptr<Backtrace<String, unsigned int> >  mldl_bt_r(const TUSubsequence & param_0, const TUSubsequence & param_1, intrusive_ptr<Backtrace<String, unsigned int> >  param_2, const TUSubsequence & param_3);
    intrusive_ptr<Backtrace<String, unsigned int> >  mldlr_bt_r(const TUSubsequence & param_0, const TUSubsequence & param_1, intrusive_ptr<Backtrace<String, unsigned int> >  param_2, const TUSubsequence & param_3, const TUSubsequence & param_4);
    intrusive_ptr<Backtrace<String, unsigned int> >  mldr_bt_r(const TUSubsequence & param_0, intrusive_ptr<Backtrace<String, unsigned int> >  param_1, const TUSubsequence & param_2, const TUSubsequence & param_3);
    intrusive_ptr<Backtrace<String, unsigned int> >  nil_bt_r(const TUSubsequence & param_0);
    intrusive_ptr<Backtrace<String, unsigned int> >  sadd_bt_r(const TUSubsequence & param_0, intrusive_ptr<Backtrace<String, unsigned int> >  param_1);
    intrusive_ptr<Backtrace<String, unsigned int> >  sr_bt_r(const TUSubsequence & param_0, intrusive_ptr<Backtrace<String, unsigned int> >  param_1, const TUSubsequence & param_2);


    std::pair<std::pair<Rope, mfecovar> , intrusive_ptr<Backtrace<String, unsigned int> > >  addss_bt(const std::pair<std::pair<Rope, mfecovar> , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e, const TUSubsequence & p_p_rb);
    std::pair<std::pair<Rope, mfecovar> , intrusive_ptr<Backtrace<String, unsigned int> > >  bl_bt(const TUSubsequence & p_p_lb, const TUSubsequence & p_p_lregion, const std::pair<std::pair<Rope, mfecovar> , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e, const TUSubsequence & p_p_rb);
    std::pair<std::pair<Rope, mfecovar> , intrusive_ptr<Backtrace<String, unsigned int> > >  br_bt(const TUSubsequence & p_p_lb, const std::pair<std::pair<Rope, mfecovar> , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e, const TUSubsequence & p_p_rregion, const TUSubsequence & p_p_rb);
    std::pair<std::pair<Rope, mfecovar> , intrusive_ptr<Backtrace<String, unsigned int> > >  cadd_bt(const std::pair<std::pair<Rope, mfecovar> , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_le, const std::pair<std::pair<Rope, mfecovar> , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_re);
    std::pair<std::pair<Rope, mfecovar> , intrusive_ptr<Backtrace<String, unsigned int> > >  drem_bt(const TUSubsequence & p_p_lloc, const std::pair<std::pair<Rope, mfecovar> , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e, const TUSubsequence & p_p_rloc);
    std::pair<std::pair<Rope, mfecovar> , intrusive_ptr<Backtrace<String, unsigned int> > >  edl_bt(const TUSubsequence & p_p_lb, const std::pair<std::pair<Rope, mfecovar> , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e, const TUSubsequence & p_p_rloc);
    std::pair<std::pair<Rope, mfecovar> , intrusive_ptr<Backtrace<String, unsigned int> > >  edlr_bt(const TUSubsequence & p_p_lb, const std::pair<std::pair<Rope, mfecovar> , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e, const TUSubsequence & p_p_rb);
    std::pair<std::pair<Rope, mfecovar> , intrusive_ptr<Backtrace<String, unsigned int> > >  edr_bt(const TUSubsequence & p_p_lloc, const std::pair<std::pair<Rope, mfecovar> , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e, const TUSubsequence & p_p_rb);
    List_Ref<std::pair<std::pair<Rope, mfecovar> , intrusive_ptr<Backtrace<String, unsigned int> > > > h_bt(List_Ref<std::pair<std::pair<Rope, mfecovar> , intrusive_ptr<Backtrace<String, unsigned int> > > > i, aliHishapes_hash_h &  left_answers);
template <typename Iterator>
    List_Ref<std::pair<std::pair<Rope, mfecovar> , intrusive_ptr<Backtrace<String, unsigned int> > > > h_bt(std::pair<Iterator, Iterator> i, aliHishapes_hash_h &  left_answers)
;
    List_Ref<std::pair<std::pair<Rope, mfecovar> , intrusive_ptr<Backtrace<String, unsigned int> > > > h_bt(List_Ref<std::pair<std::pair<Rope, mfecovar> , intrusive_ptr<Backtrace<String, unsigned int> > > > i);
template <typename Iterator>
    List_Ref<std::pair<std::pair<Rope, mfecovar> , intrusive_ptr<Backtrace<String, unsigned int> > > > h_bt(std::pair<Iterator, Iterator> i)
;
    std::pair<std::pair<Rope, mfecovar> , intrusive_ptr<Backtrace<String, unsigned int> > >  hl_bt(const TUSubsequence & p_p_lb, const TUSubsequence & p_p_region, const TUSubsequence & p_p_rb);
    std::pair<std::pair<Rope, mfecovar> , intrusive_ptr<Backtrace<String, unsigned int> > >  il_bt(const TUSubsequence & p_p_lb, const TUSubsequence & p_p_lregion, const std::pair<std::pair<Rope, mfecovar> , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e, const TUSubsequence & p_p_rregion, const TUSubsequence & p_p_rb);
    std::pair<std::pair<Rope, mfecovar> , intrusive_ptr<Backtrace<String, unsigned int> > >  incl_bt(const std::pair<std::pair<Rope, mfecovar> , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e);
    std::pair<std::pair<Rope, mfecovar> , intrusive_ptr<Backtrace<String, unsigned int> > >  ml_bt(const TUSubsequence & p_p_lb, const std::pair<std::pair<Rope, mfecovar> , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e, const TUSubsequence & p_p_rb);
    std::pair<std::pair<Rope, mfecovar> , intrusive_ptr<Backtrace<String, unsigned int> > >  mldl_bt(const TUSubsequence & p_p_lb, const TUSubsequence & p_p_dl, const std::pair<std::pair<Rope, mfecovar> , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e, const TUSubsequence & p_p_rb);
    std::pair<std::pair<Rope, mfecovar> , intrusive_ptr<Backtrace<String, unsigned int> > >  mldlr_bt(const TUSubsequence & p_p_lb, const TUSubsequence & p_p_dl, const std::pair<std::pair<Rope, mfecovar> , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e, const TUSubsequence & p_p_dr, const TUSubsequence & p_p_rb);
    std::pair<std::pair<Rope, mfecovar> , intrusive_ptr<Backtrace<String, unsigned int> > >  mldr_bt(const TUSubsequence & p_p_lb, const std::pair<std::pair<Rope, mfecovar> , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e, const TUSubsequence & p_p_dr, const TUSubsequence & p_p_rb);
    std::pair<std::pair<Rope, mfecovar> , intrusive_ptr<Backtrace<String, unsigned int> > >  nil_bt(const TUSubsequence & p_p_loc);
    std::pair<std::pair<Rope, mfecovar> , intrusive_ptr<Backtrace<String, unsigned int> > >  sadd_bt(const TUSubsequence & p_p_b, const std::pair<std::pair<Rope, mfecovar> , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e);
    std::pair<std::pair<Rope, mfecovar> , intrusive_ptr<Backtrace<String, unsigned int> > >  sr_bt(const TUSubsequence & p_p_lb, const std::pair<std::pair<Rope, mfecovar> , intrusive_ptr<Backtrace<String, unsigned int> > > & p_p_e, const TUSubsequence & p_p_rb);

template <typename Value>   void  print_result(std::ostream &out, Value& res)

{
}
   intrusive_ptr<Backtrace<String, unsigned int> >  backtrack(unsigned int t_0_i)
{
List_Ref<std::pair<std::pair<Rope, mfecovar> , intrusive_ptr<Backtrace<String, unsigned int> > > > bt  = bt_proxy_nt_struct(t_0_i);
return execute_backtrack_k(bt);
}
template <typename Value>   void  print_backtrack(std::ostream &out, Value& value)

{
intrusive_ptr<Backtrace<String, unsigned int> >  bt   = backtrack(t_0_left_most);
intrusive_ptr<Backtrace_List<String, unsigned int> > l =
  boost::dynamic_pointer_cast<Backtrace_List<String, unsigned int> >(bt);
assert(!bt || (bt && l));
if (l) {
for (Backtrace_List<String, unsigned int>::iterator i = l->begin();
     i != l->end(); ++i)
  (*i)->print(out);
}
}
   void  print_subopt(std::ostream &out, int  delta = 0) {}

};

#ifndef NO_GAPC_TYPEDEFS
namespace gapc {
  typedef aliHishapes class_name;
  typedef aliHishapes_hash_h &  return_type;
}
#endif

#endif

