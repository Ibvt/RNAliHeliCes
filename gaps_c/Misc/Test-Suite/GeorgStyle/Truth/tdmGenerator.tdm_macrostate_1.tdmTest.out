Answer: 
grammar gra_macrostate uses sig_foldrna(axiom = struct) {
  struct = left_dangle___L_L_L_L_LJJ_JJL_LJJ_J | left_unpaired___L_L_L_L_LJJ_JJL_LJJ_J # h;
  weak__LJ = stack__LJ | hairpin__LJ # h;
  stack__LJ = sr(BASE, weak__LJ, BASE) with basepair # h;
  strong__LJ = {weak__LJ} with allowLonelyBasepairs(true) | {sr(BASE, weak__LJ, BASE) with basepair} with allowLonelyBasepairs(false) # h;
  hairpin__LJ = hl(BASE, REGION with minsize(3), BASE) with basepair # h;
  weak__L_LJJ = leftB__L_LJJ | stack__L_LJJ # h;
  leftB__L_LJJ = bl(BASE, REGION with maxsize(30), strong__LJ, BASE) with basepair # h;
  stack__L_LJJ = sr(BASE, weak__L_LJJ, BASE) with basepair # h;
  strong__L_LJJ = {weak__L_LJJ} with allowLonelyBasepairs(true) | {sr(BASE, weak__L_LJJ, BASE) with basepair} with allowLonelyBasepairs(false) # h;
  edangler__L_LJJ = edr(LOC, strong__L_LJJ, BASE) # h;
  nodangle__L_LJJ = drem(LOC, strong__L_LJJ, LOC) # h;
  weak__L_L_LJJ_J = iloop__L_L_LJJ_J | stack__L_L_LJJ_J # h;
  iloop__L_L_LJJ_J = il(BASE, REGION with maxsize(30), strong__L_LJJ, REGION with maxsize(30), BASE) with basepair # h;
  stack__L_L_LJJ_J = sr(BASE, weak__L_L_LJJ_J, BASE) with basepair # h;
  strong__L_L_LJJ_J = {weak__L_L_LJJ_J} with allowLonelyBasepairs(true) | {sr(BASE, weak__L_L_LJJ_J, BASE) with basepair} with allowLonelyBasepairs(false) # h;
  weak__L_L_L_LJJ_JJ = leftB__L_L_L_LJJ_JJ | stack__L_L_L_LJJ_JJ # h;
  leftB__L_L_L_LJJ_JJ = bl(BASE, REGION with maxsize(30), strong__L_L_LJJ_J, BASE) with basepair # h;
  no_dl_ss_end__L_LJJ = incl(edangler__L_LJJ) | addss(incl(edangler__L_LJJ), REGION) # h;
  stack__L_L_L_LJJ_JJ = sr(BASE, weak__L_L_L_LJJ_JJ, BASE) with basepair # h;
  strong__L_L_L_LJJ_JJ = {weak__L_L_L_LJJ_JJ} with allowLonelyBasepairs(true) | {sr(BASE, weak__L_L_L_LJJ_JJ, BASE) with basepair} with allowLonelyBasepairs(false) # h;
  block_dl__L_L_L_LJJ_JJ = incl(edanglel__L_L_L_LJJ_JJ) | ssadd(REGION, edanglel__L_L_L_LJJ_JJ) # h;
  edanglel__L_L_L_LJJ_JJ = edl(BASE, strong__L_L_L_LJJ_JJ, LOC) # h;
  no_dl_no_ss_end__L_LJJ = incl(nodangle__L_LJJ) # h;
  nodangle__L_L_L_LJJ_JJ = drem(LOC, strong__L_L_L_LJJ_JJ, LOC) # h;
  weak__L_L_L_L_LJJ_JJL_LJJ_J = stack__L_L_L_L_LJJ_JJL_LJJ_J | multiloop__L_L_L_L_LJJ_JJL_LJJ_J # h;
  ml_comps2__L_L_L_LJJ_JJL_LJJ = combine(incl(nodangle__L_L_L_LJJ_JJ), no_dl_no_ss_end__L_LJJ) # h;
  stack__L_L_L_L_LJJ_JJL_LJJ_J = sr(BASE, weak__L_L_L_L_LJJ_JJL_LJJ_J, BASE) with basepair # h;
  ml_comps1___L_L_L_LJJ_JJL_LJJ = combine(block_dl__L_L_L_LJJ_JJ, no_dl_no_ss_end__L_LJJ) # h;
  ml_comps3__L_L_L_LJJ_JJL_LJJ_ = combine(incl(nodangle__L_L_L_LJJ_JJ), no_dl_ss_end__L_LJJ) # h;
  strong__L_L_L_L_LJJ_JJL_LJJ_J = {sr(BASE, weak__L_L_L_L_LJJ_JJL_LJJ_J, BASE) with basepair} with allowLonelyBasepairs(false) | {weak__L_L_L_L_LJJ_JJL_LJJ_J} with allowLonelyBasepairs(true) # h;
  ml_comps4___L_L_L_LJJ_JJL_LJJ_ = combine(block_dl__L_L_L_LJJ_JJ, no_dl_ss_end__L_LJJ) # h;
  edanglel__L_L_L_L_LJJ_JJL_LJJ_J = edl(BASE, strong__L_L_L_L_LJJ_JJL_LJJ_J, LOC) # h;
  multiloop__L_L_L_L_LJJ_JJL_LJJ_J = mladldr (BASE, BASE, ml_comps3__L_L_L_LJJ_JJL_LJJ_, BASE, BASE) with basepair | mladlr  (BASE, BASE, ml_comps2__L_L_L_LJJ_JJL_LJJ, BASE, BASE) with basepair | mldladr (BASE, BASE, ml_comps1___L_L_L_LJJ_JJL_LJJ, BASE, BASE) with basepair | mldlr   (BASE, BASE, ml_comps4___L_L_L_LJJ_JJL_LJJ_, BASE, BASE) with basepair # h;
  left_dangle___L_L_L_L_LJJ_JJL_LJJ_J = cadd_Pr(edanglel__L_L_L_L_LJJ_JJL_LJJ_J, nil(LOC)) # h;
  left_unpaired___L_L_L_L_LJJ_JJL_LJJ_J = sadd(BASE, left_dangle___L_L_L_L_LJJ_JJL_LJJ_J) | sadd(BASE, left_unpaired___L_L_L_L_LJJ_JJL_LJJ_J) # h;
}

