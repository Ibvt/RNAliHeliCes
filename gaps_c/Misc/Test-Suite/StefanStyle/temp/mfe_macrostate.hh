
// A dynamic programming evaluator generated by GAP-C.
// 
//   GAP-C version:
//     bellmansgapc-2013.05.02
// 
//   GAP-C call:
//     /home/jhuang/local/gapc/bin/gapc -I ../../../../ -p alg_ali_mfe_macrostate * (alg_ali_dotBracket * alg_ali_shapeX * alg_ali_pfunc_macrostate) ../../../../ali_macrostate.gap --kbacktrace --no-coopt -o mfe_macrostate.cc 
// 
// 


#ifndef mfe_macrostate_hh
#define mfe_macrostate_hh

#include "rtlib/adp.hh"

typedef Basic_Subsequence<M_Char, unsigned> TUSubsequence;

typedef Shape shape_t;
#include <rtlib/subopt.hh>
#include "rna.hh"
#include "Extensions/alifold.hh"
#include "Extensions/mfesubopt.hh"
#include "Extensions/probabilities.hh"
#include "Extensions/typesRNAfolding.hh"
#include "Extensions/shapes.hh"

#include "Extensions/rnaoptions.hh"

class mfe_macrostate {

  public:
Basic_Sequence<M_Char> t_0_seq;
unsigned int t_0_left_most;
unsigned int t_0_right_most;

mfecovar_macrostate mfecovar_macrostate_zero;

class block_dl_table_t {

private:

unsigned int t_0_left_most;
unsigned int t_0_right_most;
std::vector<mfecovar_macrostate > array;
std::vector<bool> tabulated;
unsigned int t_0_n;
mfecovar_macrostate zero;
unsigned int size()
{
  return (1 * ((((t_0_n * (t_0_n + 1)) / 2) + t_0_n) + 1));
}


public:

block_dl_table_t()
{
  empty(zero);
}

void init(unsigned int t_0_n_, const std::string &tname)
{
t_0_n = t_0_n_;
t_0_left_most = 0;
t_0_right_most = t_0_n;
unsigned int newsize = size();
array.resize(newsize);
tabulated.clear();
tabulated.resize(newsize);
}
bool is_tabulated(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 6))
    {
      return true;
    }

  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  return tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void clear() { tabulated.clear(); }
mfecovar_macrostate &  get(unsigned int t_0_i, unsigned int t_0_j)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 6))
    {
      return zero;
    }

  assert( tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))]);
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  return array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void set(unsigned int t_0_i, unsigned int t_0_j, const mfecovar_macrostate & e)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 6))
    {
      assert( 0);
    }

  assert( !is_tabulated(t_0_i, t_0_j));
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = e;
  tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = true;
}


};
block_dl_table_t block_dl_table;


class block_dlr_table_t {

private:

unsigned int t_0_left_most;
unsigned int t_0_right_most;
std::vector<mfecovar_macrostate > array;
std::vector<bool> tabulated;
unsigned int t_0_n;
mfecovar_macrostate zero;
unsigned int size()
{
  return (1 * ((((t_0_n * (t_0_n + 1)) / 2) + t_0_n) + 1));
}


public:

block_dlr_table_t()
{
  empty(zero);
}

void init(unsigned int t_0_n_, const std::string &tname)
{
t_0_n = t_0_n_;
t_0_left_most = 0;
t_0_right_most = t_0_n;
unsigned int newsize = size();
array.resize(newsize);
tabulated.clear();
tabulated.resize(newsize);
}
bool is_tabulated(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 7))
    {
      return true;
    }

  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  return tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void clear() { tabulated.clear(); }
mfecovar_macrostate &  get(unsigned int t_0_i, unsigned int t_0_j)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 7))
    {
      return zero;
    }

  assert( tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))]);
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  return array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void set(unsigned int t_0_i, unsigned int t_0_j, const mfecovar_macrostate & e)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 7))
    {
      assert( 0);
    }

  assert( !is_tabulated(t_0_i, t_0_j));
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = e;
  tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = true;
}


};
block_dlr_table_t block_dlr_table;


class dl_or_ss_left_no_ss_end_table_t {

private:

unsigned int t_0_left_most;
unsigned int t_0_right_most;
std::vector<mfecovar_macrostate > array;
std::vector<bool> tabulated;
unsigned int t_0_n;
mfecovar_macrostate zero;
unsigned int size()
{
  return (1 * ((((t_0_n * (t_0_n + 1)) / 2) + t_0_n) + 1));
}


public:

dl_or_ss_left_no_ss_end_table_t()
{
  empty(zero);
}

void init(unsigned int t_0_n_, const std::string &tname)
{
t_0_n = t_0_n_;
t_0_left_most = 0;
t_0_right_most = t_0_n;
unsigned int newsize = size();
array.resize(newsize);
tabulated.clear();
tabulated.resize(newsize);
}
bool is_tabulated(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 6))
    {
      return true;
    }

  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  return tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void clear() { tabulated.clear(); }
mfecovar_macrostate &  get(unsigned int t_0_i, unsigned int t_0_j)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 6))
    {
      return zero;
    }

  assert( tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))]);
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  return array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void set(unsigned int t_0_i, unsigned int t_0_j, const mfecovar_macrostate & e)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 6))
    {
      assert( 0);
    }

  assert( !is_tabulated(t_0_i, t_0_j));
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = e;
  tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = true;
}


};
dl_or_ss_left_no_ss_end_table_t dl_or_ss_left_no_ss_end_table;


class dl_or_ss_left_ss_end_table_t {

private:

unsigned int t_0_left_most;
unsigned int t_0_right_most;
std::vector<mfecovar_macrostate > array;
std::vector<bool> tabulated;
unsigned int t_0_n;
mfecovar_macrostate zero;
unsigned int size()
{
  return (1 * ((((t_0_n * (t_0_n + 1)) / 2) + t_0_n) + 1));
}


public:

dl_or_ss_left_ss_end_table_t()
{
  empty(zero);
}

void init(unsigned int t_0_n_, const std::string &tname)
{
t_0_n = t_0_n_;
t_0_left_most = 0;
t_0_right_most = t_0_n;
unsigned int newsize = size();
array.resize(newsize);
tabulated.clear();
tabulated.resize(newsize);
}
bool is_tabulated(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 7))
    {
      return true;
    }

  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  return tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void clear() { tabulated.clear(); }
mfecovar_macrostate &  get(unsigned int t_0_i, unsigned int t_0_j)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 7))
    {
      return zero;
    }

  assert( tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))]);
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  return array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void set(unsigned int t_0_i, unsigned int t_0_j, const mfecovar_macrostate & e)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 7))
    {
      assert( 0);
    }

  assert( !is_tabulated(t_0_i, t_0_j));
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = e;
  tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = true;
}


};
dl_or_ss_left_ss_end_table_t dl_or_ss_left_ss_end_table;


class edanglel_table_t {

private:

unsigned int t_0_left_most;
unsigned int t_0_right_most;
std::vector<mfecovar_macrostate > array;
std::vector<bool> tabulated;
unsigned int t_0_n;
mfecovar_macrostate zero;
unsigned int size()
{
  return (1 * ((((t_0_n * (t_0_n + 1)) / 2) + t_0_n) + 1));
}


public:

edanglel_table_t()
{
  empty(zero);
}

void init(unsigned int t_0_n_, const std::string &tname)
{
t_0_n = t_0_n_;
t_0_left_most = 0;
t_0_right_most = t_0_n;
unsigned int newsize = size();
array.resize(newsize);
tabulated.clear();
tabulated.resize(newsize);
}
bool is_tabulated(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 6))
    {
      return true;
    }

  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  return tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void clear() { tabulated.clear(); }
mfecovar_macrostate &  get(unsigned int t_0_i, unsigned int t_0_j)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 6))
    {
      return zero;
    }

  assert( tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))]);
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  return array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void set(unsigned int t_0_i, unsigned int t_0_j, const mfecovar_macrostate & e)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 6))
    {
      assert( 0);
    }

  assert( !is_tabulated(t_0_i, t_0_j));
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = e;
  tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = true;
}


};
edanglel_table_t edanglel_table;


class edanglelr_table_t {

private:

unsigned int t_0_left_most;
unsigned int t_0_right_most;
std::vector<mfecovar_macrostate > array;
std::vector<bool> tabulated;
unsigned int t_0_n;
mfecovar_macrostate zero;
unsigned int size()
{
  return (1 * ((((t_0_n * (t_0_n + 1)) / 2) + t_0_n) + 1));
}


public:

edanglelr_table_t()
{
  empty(zero);
}

void init(unsigned int t_0_n_, const std::string &tname)
{
t_0_n = t_0_n_;
t_0_left_most = 0;
t_0_right_most = t_0_n;
unsigned int newsize = size();
array.resize(newsize);
tabulated.clear();
tabulated.resize(newsize);
}
bool is_tabulated(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 7))
    {
      return true;
    }

  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  return tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void clear() { tabulated.clear(); }
mfecovar_macrostate &  get(unsigned int t_0_i, unsigned int t_0_j)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 7))
    {
      return zero;
    }

  assert( tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))]);
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  return array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void set(unsigned int t_0_i, unsigned int t_0_j, const mfecovar_macrostate & e)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 7))
    {
      assert( 0);
    }

  assert( !is_tabulated(t_0_i, t_0_j));
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = e;
  tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = true;
}


};
edanglelr_table_t edanglelr_table;


class edangler_table_t {

private:

unsigned int t_0_left_most;
unsigned int t_0_right_most;
std::vector<mfecovar_macrostate > array;
std::vector<bool> tabulated;
unsigned int t_0_n;
mfecovar_macrostate zero;
unsigned int size()
{
  return (1 * ((((t_0_n * (t_0_n + 1)) / 2) + t_0_n) + 1));
}


public:

edangler_table_t()
{
  empty(zero);
}

void init(unsigned int t_0_n_, const std::string &tname)
{
t_0_n = t_0_n_;
t_0_left_most = 0;
t_0_right_most = t_0_n;
unsigned int newsize = size();
array.resize(newsize);
tabulated.clear();
tabulated.resize(newsize);
}
bool is_tabulated(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 6))
    {
      return true;
    }

  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  return tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void clear() { tabulated.clear(); }
mfecovar_macrostate &  get(unsigned int t_0_i, unsigned int t_0_j)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 6))
    {
      return zero;
    }

  assert( tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))]);
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  return array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void set(unsigned int t_0_i, unsigned int t_0_j, const mfecovar_macrostate & e)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 6))
    {
      assert( 0);
    }

  assert( !is_tabulated(t_0_i, t_0_j));
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = e;
  tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = true;
}


};
edangler_table_t edangler_table;


class iloop_table_t {

private:

unsigned int t_0_left_most;
unsigned int t_0_right_most;
std::vector<mfecovar_macrostate > array;
std::vector<bool> tabulated;
unsigned int t_0_n;
mfecovar_macrostate zero;
unsigned int size()
{
  return (1 * ((((t_0_n * (t_0_n + 1)) / 2) + t_0_n) + 1));
}


public:

iloop_table_t()
{
  empty(zero);
}

void init(unsigned int t_0_n_, const std::string &tname)
{
t_0_n = t_0_n_;
t_0_left_most = 0;
t_0_right_most = t_0_n;
unsigned int newsize = size();
array.resize(newsize);
tabulated.clear();
tabulated.resize(newsize);
}
bool is_tabulated(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 9))
    {
      return true;
    }

  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  return tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void clear() { tabulated.clear(); }
mfecovar_macrostate &  get(unsigned int t_0_i, unsigned int t_0_j)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 9))
    {
      return zero;
    }

  assert( tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))]);
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  return array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void set(unsigned int t_0_i, unsigned int t_0_j, const mfecovar_macrostate & e)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 9))
    {
      assert( 0);
    }

  assert( !is_tabulated(t_0_i, t_0_j));
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = e;
  tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = true;
}


};
iloop_table_t iloop_table;


class left_dangle_table_t {

private:

unsigned int t_0_left_most;
unsigned int t_0_right_most;
std::vector<mfecovar_macrostate > array;
std::vector<bool> tabulated;
unsigned int t_0_n;
mfecovar_macrostate zero;
unsigned int size()
{
  return (1 * ((t_0_n + 1) * 1));
}


public:

left_dangle_table_t()
{
  empty(zero);
}

void init(unsigned int t_0_n_, const std::string &tname)
{
t_0_n = t_0_n_;
t_0_left_most = 0;
t_0_right_most = t_0_n;
unsigned int newsize = size();
array.resize(newsize);
tabulated.clear();
tabulated.resize(newsize);
}
bool is_tabulated(unsigned int t_0_i)
{
  unsigned int t_0_j = t_0_n;
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if ((t_0_j < (t_0_n - 0)))
    {
      return true;
    }

  unsigned int t_0_real_j = (t_0_n - t_0_j);
  return tabulated[(0 + (1 * (t_0_i + (t_0_real_j * (t_0_n + 1)))))];
}


void clear() { tabulated.clear(); }
mfecovar_macrostate &  get(unsigned int t_0_i)
{
  unsigned int t_0_j = t_0_n;
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if ((t_0_j < (t_0_n - 0)))
    {
      return zero;
    }

  unsigned int t_0_real_j = (t_0_n - t_0_j);
  assert( tabulated[(0 + (1 * (t_0_i + (t_0_real_j * (t_0_n + 1)))))]);
  assert( ((0 + (1 * (t_0_i + (t_0_real_j * (t_0_n + 1))))) < size()));
  return array[(0 + (1 * (t_0_i + (t_0_real_j * (t_0_n + 1)))))];
}


void set(unsigned int t_0_i, const mfecovar_macrostate & e)
{
  unsigned int t_0_j = t_0_n;
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if ((t_0_j < (t_0_n - 0)))
    {
      return;
    }

  unsigned int t_0_real_j = (t_0_n - t_0_j);
  assert( !is_tabulated(t_0_i));
  assert( ((0 + (1 * (t_0_i + (t_0_real_j * (t_0_n + 1))))) < size()));
  array[(0 + (1 * (t_0_i + (t_0_real_j * (t_0_n + 1)))))] = e;
  tabulated[(0 + (1 * (t_0_i + (t_0_real_j * (t_0_n + 1)))))] = true;
}


};
left_dangle_table_t left_dangle_table;


class left_unpaired_table_t {

private:

unsigned int t_0_left_most;
unsigned int t_0_right_most;
std::vector<mfecovar_macrostate > array;
std::vector<bool> tabulated;
unsigned int t_0_n;
mfecovar_macrostate zero;
unsigned int size()
{
  return (1 * ((t_0_n + 1) * 1));
}


public:

left_unpaired_table_t()
{
  empty(zero);
}

void init(unsigned int t_0_n_, const std::string &tname)
{
t_0_n = t_0_n_;
t_0_left_most = 0;
t_0_right_most = t_0_n;
unsigned int newsize = size();
array.resize(newsize);
tabulated.clear();
tabulated.resize(newsize);
}
bool is_tabulated(unsigned int t_0_i)
{
  if (((t_0_right_most - t_0_i) < 1))
    {
      return true;
    }

  unsigned int t_0_j = t_0_n;
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if ((t_0_j < (t_0_n - 0)))
    {
      return true;
    }

  unsigned int t_0_real_j = (t_0_n - t_0_j);
  return tabulated[(0 + (1 * (t_0_i + (t_0_real_j * (t_0_n + 1)))))];
}


void clear() { tabulated.clear(); }
mfecovar_macrostate &  get(unsigned int t_0_i)
{
  unsigned int t_0_j = t_0_n;
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if ((t_0_j < (t_0_n - 0)))
    {
      return zero;
    }

  unsigned int t_0_real_j = (t_0_n - t_0_j);
  if (((t_0_right_most - t_0_i) < 1))
    {
      return zero;
    }

  assert( tabulated[(0 + (1 * (t_0_i + (t_0_real_j * (t_0_n + 1)))))]);
  assert( ((0 + (1 * (t_0_i + (t_0_real_j * (t_0_n + 1))))) < size()));
  return array[(0 + (1 * (t_0_i + (t_0_real_j * (t_0_n + 1)))))];
}


void set(unsigned int t_0_i, const mfecovar_macrostate & e)
{
  unsigned int t_0_j = t_0_n;
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if ((t_0_j < (t_0_n - 0)))
    {
      return;
    }

  unsigned int t_0_real_j = (t_0_n - t_0_j);
  if (((t_0_right_most - t_0_i) < 1))
    {
      assert( 0);
    }

  assert( !is_tabulated(t_0_i));
  assert( ((0 + (1 * (t_0_i + (t_0_real_j * (t_0_n + 1))))) < size()));
  array[(0 + (1 * (t_0_i + (t_0_real_j * (t_0_n + 1)))))] = e;
  tabulated[(0 + (1 * (t_0_i + (t_0_real_j * (t_0_n + 1)))))] = true;
}


};
left_unpaired_table_t left_unpaired_table;


class ml_comps1_table_t {

private:

unsigned int t_0_left_most;
unsigned int t_0_right_most;
std::vector<mfecovar_macrostate > array;
std::vector<bool> tabulated;
unsigned int t_0_n;
mfecovar_macrostate zero;
unsigned int size()
{
  return (1 * ((((t_0_n * (t_0_n + 1)) / 2) + t_0_n) + 1));
}


public:

ml_comps1_table_t()
{
  empty(zero);
}

void init(unsigned int t_0_n_, const std::string &tname)
{
t_0_n = t_0_n_;
t_0_left_most = 0;
t_0_right_most = t_0_n;
unsigned int newsize = size();
array.resize(newsize);
tabulated.clear();
tabulated.resize(newsize);
}
bool is_tabulated(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 11))
    {
      return true;
    }

  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  return tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void clear() { tabulated.clear(); }
mfecovar_macrostate &  get(unsigned int t_0_i, unsigned int t_0_j)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 11))
    {
      return zero;
    }

  assert( tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))]);
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  return array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void set(unsigned int t_0_i, unsigned int t_0_j, const mfecovar_macrostate & e)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 11))
    {
      assert( 0);
    }

  assert( !is_tabulated(t_0_i, t_0_j));
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = e;
  tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = true;
}


};
ml_comps1_table_t ml_comps1_table;


class ml_comps2_table_t {

private:

unsigned int t_0_left_most;
unsigned int t_0_right_most;
std::vector<mfecovar_macrostate > array;
std::vector<bool> tabulated;
unsigned int t_0_n;
mfecovar_macrostate zero;
unsigned int size()
{
  return (1 * ((((t_0_n * (t_0_n + 1)) / 2) + t_0_n) + 1));
}


public:

ml_comps2_table_t()
{
  empty(zero);
}

void init(unsigned int t_0_n_, const std::string &tname)
{
t_0_n = t_0_n_;
t_0_left_most = 0;
t_0_right_most = t_0_n;
unsigned int newsize = size();
array.resize(newsize);
tabulated.clear();
tabulated.resize(newsize);
}
bool is_tabulated(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 10))
    {
      return true;
    }

  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  return tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void clear() { tabulated.clear(); }
mfecovar_macrostate &  get(unsigned int t_0_i, unsigned int t_0_j)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 10))
    {
      return zero;
    }

  assert( tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))]);
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  return array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void set(unsigned int t_0_i, unsigned int t_0_j, const mfecovar_macrostate & e)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 10))
    {
      assert( 0);
    }

  assert( !is_tabulated(t_0_i, t_0_j));
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = e;
  tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = true;
}


};
ml_comps2_table_t ml_comps2_table;


class ml_comps3_table_t {

private:

unsigned int t_0_left_most;
unsigned int t_0_right_most;
std::vector<mfecovar_macrostate > array;
std::vector<bool> tabulated;
unsigned int t_0_n;
mfecovar_macrostate zero;
unsigned int size()
{
  return (1 * ((((t_0_n * (t_0_n + 1)) / 2) + t_0_n) + 1));
}


public:

ml_comps3_table_t()
{
  empty(zero);
}

void init(unsigned int t_0_n_, const std::string &tname)
{
t_0_n = t_0_n_;
t_0_left_most = 0;
t_0_right_most = t_0_n;
unsigned int newsize = size();
array.resize(newsize);
tabulated.clear();
tabulated.resize(newsize);
}
bool is_tabulated(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 11))
    {
      return true;
    }

  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  return tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void clear() { tabulated.clear(); }
mfecovar_macrostate &  get(unsigned int t_0_i, unsigned int t_0_j)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 11))
    {
      return zero;
    }

  assert( tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))]);
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  return array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void set(unsigned int t_0_i, unsigned int t_0_j, const mfecovar_macrostate & e)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 11))
    {
      assert( 0);
    }

  assert( !is_tabulated(t_0_i, t_0_j));
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = e;
  tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = true;
}


};
ml_comps3_table_t ml_comps3_table;


class ml_comps4_table_t {

private:

unsigned int t_0_left_most;
unsigned int t_0_right_most;
std::vector<mfecovar_macrostate > array;
std::vector<bool> tabulated;
unsigned int t_0_n;
mfecovar_macrostate zero;
unsigned int size()
{
  return (1 * ((((t_0_n * (t_0_n + 1)) / 2) + t_0_n) + 1));
}


public:

ml_comps4_table_t()
{
  empty(zero);
}

void init(unsigned int t_0_n_, const std::string &tname)
{
t_0_n = t_0_n_;
t_0_left_most = 0;
t_0_right_most = t_0_n;
unsigned int newsize = size();
array.resize(newsize);
tabulated.clear();
tabulated.resize(newsize);
}
bool is_tabulated(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 12))
    {
      return true;
    }

  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  return tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void clear() { tabulated.clear(); }
mfecovar_macrostate &  get(unsigned int t_0_i, unsigned int t_0_j)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 12))
    {
      return zero;
    }

  assert( tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))]);
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  return array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void set(unsigned int t_0_i, unsigned int t_0_j, const mfecovar_macrostate & e)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 12))
    {
      assert( 0);
    }

  assert( !is_tabulated(t_0_i, t_0_j));
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = e;
  tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = true;
}


};
ml_comps4_table_t ml_comps4_table;


class no_dl_no_ss_end_table_t {

private:

unsigned int t_0_left_most;
unsigned int t_0_right_most;
std::vector<mfecovar_macrostate > array;
std::vector<bool> tabulated;
unsigned int t_0_n;
mfecovar_macrostate zero;
unsigned int size()
{
  return (1 * ((((t_0_n * (t_0_n + 1)) / 2) + t_0_n) + 1));
}


public:

no_dl_no_ss_end_table_t()
{
  empty(zero);
}

void init(unsigned int t_0_n_, const std::string &tname)
{
t_0_n = t_0_n_;
t_0_left_most = 0;
t_0_right_most = t_0_n;
unsigned int newsize = size();
array.resize(newsize);
tabulated.clear();
tabulated.resize(newsize);
}
bool is_tabulated(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 5))
    {
      return true;
    }

  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  return tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void clear() { tabulated.clear(); }
mfecovar_macrostate &  get(unsigned int t_0_i, unsigned int t_0_j)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 5))
    {
      return zero;
    }

  assert( tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))]);
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  return array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void set(unsigned int t_0_i, unsigned int t_0_j, const mfecovar_macrostate & e)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 5))
    {
      assert( 0);
    }

  assert( !is_tabulated(t_0_i, t_0_j));
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = e;
  tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = true;
}


};
no_dl_no_ss_end_table_t no_dl_no_ss_end_table;


class no_dl_ss_end_table_t {

private:

unsigned int t_0_left_most;
unsigned int t_0_right_most;
std::vector<mfecovar_macrostate > array;
std::vector<bool> tabulated;
unsigned int t_0_n;
mfecovar_macrostate zero;
unsigned int size()
{
  return (1 * ((((t_0_n * (t_0_n + 1)) / 2) + t_0_n) + 1));
}


public:

no_dl_ss_end_table_t()
{
  empty(zero);
}

void init(unsigned int t_0_n_, const std::string &tname)
{
t_0_n = t_0_n_;
t_0_left_most = 0;
t_0_right_most = t_0_n;
unsigned int newsize = size();
array.resize(newsize);
tabulated.clear();
tabulated.resize(newsize);
}
bool is_tabulated(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 6))
    {
      return true;
    }

  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  return tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void clear() { tabulated.clear(); }
mfecovar_macrostate &  get(unsigned int t_0_i, unsigned int t_0_j)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 6))
    {
      return zero;
    }

  assert( tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))]);
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  return array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void set(unsigned int t_0_i, unsigned int t_0_j, const mfecovar_macrostate & e)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 6))
    {
      assert( 0);
    }

  assert( !is_tabulated(t_0_i, t_0_j));
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = e;
  tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = true;
}


};
no_dl_ss_end_table_t no_dl_ss_end_table;


class nodangle_table_t {

private:

unsigned int t_0_left_most;
unsigned int t_0_right_most;
std::vector<mfecovar_macrostate > array;
std::vector<bool> tabulated;
unsigned int t_0_n;
mfecovar_macrostate zero;
unsigned int size()
{
  return (1 * ((((t_0_n * (t_0_n + 1)) / 2) + t_0_n) + 1));
}


public:

nodangle_table_t()
{
  empty(zero);
}

void init(unsigned int t_0_n_, const std::string &tname)
{
t_0_n = t_0_n_;
t_0_left_most = 0;
t_0_right_most = t_0_n;
unsigned int newsize = size();
array.resize(newsize);
tabulated.clear();
tabulated.resize(newsize);
}
bool is_tabulated(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 5))
    {
      return true;
    }

  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  return tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void clear() { tabulated.clear(); }
mfecovar_macrostate &  get(unsigned int t_0_i, unsigned int t_0_j)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 5))
    {
      return zero;
    }

  assert( tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))]);
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  return array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void set(unsigned int t_0_i, unsigned int t_0_j, const mfecovar_macrostate & e)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 5))
    {
      assert( 0);
    }

  assert( !is_tabulated(t_0_i, t_0_j));
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = e;
  tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = true;
}


};
nodangle_table_t nodangle_table;


class noleft_dangle_table_t {

private:

unsigned int t_0_left_most;
unsigned int t_0_right_most;
std::vector<mfecovar_macrostate > array;
std::vector<bool> tabulated;
unsigned int t_0_n;
mfecovar_macrostate zero;
unsigned int size()
{
  return (1 * ((t_0_n + 1) * 1));
}


public:

noleft_dangle_table_t()
{
  empty(zero);
}

void init(unsigned int t_0_n_, const std::string &tname)
{
t_0_n = t_0_n_;
t_0_left_most = 0;
t_0_right_most = t_0_n;
unsigned int newsize = size();
array.resize(newsize);
tabulated.clear();
tabulated.resize(newsize);
}
bool is_tabulated(unsigned int t_0_i)
{
  if (((t_0_right_most - t_0_i) < 5))
    {
      return true;
    }

  unsigned int t_0_j = t_0_n;
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if ((t_0_j < (t_0_n - 0)))
    {
      return true;
    }

  unsigned int t_0_real_j = (t_0_n - t_0_j);
  return tabulated[(0 + (1 * (t_0_i + (t_0_real_j * (t_0_n + 1)))))];
}


void clear() { tabulated.clear(); }
mfecovar_macrostate &  get(unsigned int t_0_i)
{
  unsigned int t_0_j = t_0_n;
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if ((t_0_j < (t_0_n - 0)))
    {
      return zero;
    }

  unsigned int t_0_real_j = (t_0_n - t_0_j);
  if (((t_0_right_most - t_0_i) < 5))
    {
      return zero;
    }

  assert( tabulated[(0 + (1 * (t_0_i + (t_0_real_j * (t_0_n + 1)))))]);
  assert( ((0 + (1 * (t_0_i + (t_0_real_j * (t_0_n + 1))))) < size()));
  return array[(0 + (1 * (t_0_i + (t_0_real_j * (t_0_n + 1)))))];
}


void set(unsigned int t_0_i, const mfecovar_macrostate & e)
{
  unsigned int t_0_j = t_0_n;
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if ((t_0_j < (t_0_n - 0)))
    {
      return;
    }

  unsigned int t_0_real_j = (t_0_n - t_0_j);
  if (((t_0_right_most - t_0_i) < 5))
    {
      assert( 0);
    }

  assert( !is_tabulated(t_0_i));
  assert( ((0 + (1 * (t_0_i + (t_0_real_j * (t_0_n + 1))))) < size()));
  array[(0 + (1 * (t_0_i + (t_0_real_j * (t_0_n + 1)))))] = e;
  tabulated[(0 + (1 * (t_0_i + (t_0_real_j * (t_0_n + 1)))))] = true;
}


};
noleft_dangle_table_t noleft_dangle_table;


class strong_table_t {

private:

unsigned int t_0_left_most;
unsigned int t_0_right_most;
std::vector<mfecovar_macrostate > array;
std::vector<bool> tabulated;
unsigned int t_0_n;
mfecovar_macrostate zero;
unsigned int size()
{
  return (1 * ((((t_0_n * (t_0_n + 1)) / 2) + t_0_n) + 1));
}


public:

strong_table_t()
{
  empty(zero);
}

void init(unsigned int t_0_n_, const std::string &tname)
{
t_0_n = t_0_n_;
t_0_left_most = 0;
t_0_right_most = t_0_n;
unsigned int newsize = size();
array.resize(newsize);
tabulated.clear();
tabulated.resize(newsize);
}
bool is_tabulated(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 5))
    {
      return true;
    }

  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  return tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void clear() { tabulated.clear(); }
mfecovar_macrostate &  get(unsigned int t_0_i, unsigned int t_0_j)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 5))
    {
      return zero;
    }

  assert( tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))]);
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  return array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void set(unsigned int t_0_i, unsigned int t_0_j, const mfecovar_macrostate & e)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 5))
    {
      assert( 0);
    }

  assert( !is_tabulated(t_0_i, t_0_j));
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = e;
  tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = true;
}


};
strong_table_t strong_table;


class weak_table_t {

private:

unsigned int t_0_left_most;
unsigned int t_0_right_most;
std::vector<mfecovar_macrostate > array;
std::vector<bool> tabulated;
unsigned int t_0_n;
mfecovar_macrostate zero;
unsigned int size()
{
  return (1 * ((((t_0_n * (t_0_n + 1)) / 2) + t_0_n) + 1));
}


public:

weak_table_t()
{
  empty(zero);
}

void init(unsigned int t_0_n_, const std::string &tname)
{
t_0_n = t_0_n_;
t_0_left_most = 0;
t_0_right_most = t_0_n;
unsigned int newsize = size();
array.resize(newsize);
tabulated.clear();
tabulated.resize(newsize);
}
bool is_tabulated(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 5))
    {
      return true;
    }

  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  return tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void clear() { tabulated.clear(); }
mfecovar_macrostate &  get(unsigned int t_0_i, unsigned int t_0_j)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 5))
    {
      return zero;
    }

  assert( tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))]);
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  return array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void set(unsigned int t_0_i, unsigned int t_0_j, const mfecovar_macrostate & e)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 5))
    {
      assert( 0);
    }

  assert( !is_tabulated(t_0_i, t_0_j));
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = e;
  tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = true;
}


};
weak_table_t weak_table;



void init(const gapc::Opts &opts)
{
const std::vector<std::pair<const char *, unsigned> > &inp = opts.inputs;
if(inp.size() != 1)
  throw gapc::OptException("Number of input sequences does not match.");

  t_0_seq.copy(inp[0].first, inp[0].second);
char_to_rna(t_0_seq);
  block_dl_table.init( t_0_seq.size(), "block_dl_table");
  block_dlr_table.init( t_0_seq.size(), "block_dlr_table");
  dl_or_ss_left_no_ss_end_table.init( t_0_seq.size(), "dl_or_ss_left_no_ss_end_table");
  dl_or_ss_left_ss_end_table.init( t_0_seq.size(), "dl_or_ss_left_ss_end_table");
  edanglel_table.init( t_0_seq.size(), "edanglel_table");
  edanglelr_table.init( t_0_seq.size(), "edanglelr_table");
  edangler_table.init( t_0_seq.size(), "edangler_table");
  iloop_table.init( t_0_seq.size(), "iloop_table");
  left_dangle_table.init( t_0_seq.size(), "left_dangle_table");
  left_unpaired_table.init( t_0_seq.size(), "left_unpaired_table");
  ml_comps1_table.init( t_0_seq.size(), "ml_comps1_table");
  ml_comps2_table.init( t_0_seq.size(), "ml_comps2_table");
  ml_comps3_table.init( t_0_seq.size(), "ml_comps3_table");
  ml_comps4_table.init( t_0_seq.size(), "ml_comps4_table");
  no_dl_no_ss_end_table.init( t_0_seq.size(), "no_dl_no_ss_end_table");
  no_dl_ss_end_table.init( t_0_seq.size(), "no_dl_ss_end_table");
  nodangle_table.init( t_0_seq.size(), "nodangle_table");
  noleft_dangle_table.init( t_0_seq.size(), "noleft_dangle_table");
  strong_table.init( t_0_seq.size(), "strong_table");
  weak_table.init( t_0_seq.size(), "weak_table");
empty(mfecovar_macrostate_zero);

t_0_left_most = 0;
t_0_right_most = t_0_seq.size();
}

  private:
    mfecovar_macrostate &  nt_block_dl(unsigned int t_0_i, unsigned int t_0_j);
    mfecovar_macrostate &  nt_block_dlr(unsigned int t_0_i, unsigned int t_0_j);
    mfecovar_macrostate &  nt_dl_or_ss_left_no_ss_end(unsigned int t_0_i, unsigned int t_0_j);
    mfecovar_macrostate &  nt_dl_or_ss_left_ss_end(unsigned int t_0_i, unsigned int t_0_j);
    mfecovar_macrostate &  nt_edanglel(unsigned int t_0_i, unsigned int t_0_j);
    mfecovar_macrostate &  nt_edanglelr(unsigned int t_0_i, unsigned int t_0_j);
    mfecovar_macrostate &  nt_edangler(unsigned int t_0_i, unsigned int t_0_j);
    mfecovar_macrostate nt_hairpin(unsigned int t_0_i, unsigned int t_0_j);
    mfecovar_macrostate &  nt_iloop(unsigned int t_0_i, unsigned int t_0_j);
    mfecovar_macrostate nt_leftB(unsigned int t_0_i, unsigned int t_0_j);
    mfecovar_macrostate &  nt_left_dangle(unsigned int t_0_i);
    mfecovar_macrostate &  nt_left_unpaired(unsigned int t_0_i);
    mfecovar_macrostate &  nt_ml_comps1(unsigned int t_0_i, unsigned int t_0_j);
    mfecovar_macrostate &  nt_ml_comps2(unsigned int t_0_i, unsigned int t_0_j);
    mfecovar_macrostate &  nt_ml_comps3(unsigned int t_0_i, unsigned int t_0_j);
    mfecovar_macrostate &  nt_ml_comps4(unsigned int t_0_i, unsigned int t_0_j);
    mfecovar_macrostate nt_multiloop(unsigned int t_0_i, unsigned int t_0_j);
    mfecovar_macrostate &  nt_no_dl_no_ss_end(unsigned int t_0_i, unsigned int t_0_j);
    mfecovar_macrostate &  nt_no_dl_ss_end(unsigned int t_0_i, unsigned int t_0_j);
    mfecovar_macrostate &  nt_nodangle(unsigned int t_0_i, unsigned int t_0_j);
    mfecovar_macrostate &  nt_noleft_dangle(unsigned int t_0_i);
    mfecovar_macrostate nt_rightB(unsigned int t_0_i, unsigned int t_0_j);
    mfecovar_macrostate nt_stack(unsigned int t_0_i, unsigned int t_0_j);
    mfecovar_macrostate &  nt_strong(unsigned int t_0_i, unsigned int t_0_j);
    mfecovar_macrostate nt_struct();
    mfecovar_macrostate &  nt_weak(unsigned int t_0_i, unsigned int t_0_j);

    mfecovar_macrostate acomb(const mfecovar_macrostate & le, const TUSubsequence & b, const mfecovar_macrostate & re);
    mfecovar_macrostate addss(const mfecovar_macrostate & e, const TUSubsequence & rb);
    mfecovar_macrostate ambd(const mfecovar_macrostate & le, const TUSubsequence & b, const mfecovar_macrostate & re);
    mfecovar_macrostate ambd_Pr(const mfecovar_macrostate & le, const TUSubsequence & b, const mfecovar_macrostate & re);
    mfecovar_macrostate bl(const TUSubsequence & lb, const TUSubsequence & lregion, const mfecovar_macrostate & e, const TUSubsequence & rb);
    mfecovar_macrostate br(const TUSubsequence & lb, const mfecovar_macrostate & e, const TUSubsequence & rregion, const TUSubsequence & rb);
    mfecovar_macrostate cadd(const mfecovar_macrostate & le, const mfecovar_macrostate & re);
    mfecovar_macrostate cadd_Pr(const mfecovar_macrostate & le, const mfecovar_macrostate & re);
    mfecovar_macrostate cadd_Pr_Pr(const mfecovar_macrostate & le, const mfecovar_macrostate & re);
    mfecovar_macrostate cadd_Pr_Pr_Pr(const mfecovar_macrostate & le, const mfecovar_macrostate & re);
    mfecovar_macrostate combine(const mfecovar_macrostate & le, const mfecovar_macrostate & re);
    mfecovar_macrostate drem(const TUSubsequence & lloc, const mfecovar_macrostate & e, const TUSubsequence & rloc);
    mfecovar_macrostate edl(const TUSubsequence & lb, const mfecovar_macrostate & e, const TUSubsequence & rloc);
    mfecovar_macrostate edlr(const TUSubsequence & lb, const mfecovar_macrostate & e, const TUSubsequence & rb);
    mfecovar_macrostate edr(const TUSubsequence & lloc, const mfecovar_macrostate & e, const TUSubsequence & rb);
    mfecovar_macrostate h(mfecovar_macrostate i);
    mfecovar_macrostate hl(const TUSubsequence & lb, const TUSubsequence & region, const TUSubsequence & rb);
    mfecovar_macrostate il(const TUSubsequence & lb, const TUSubsequence & lregion, const mfecovar_macrostate & e, const TUSubsequence & rregion, const TUSubsequence & rb);
    mfecovar_macrostate incl(const mfecovar_macrostate & e);
    mfecovar_macrostate ml(const TUSubsequence & lb, const mfecovar_macrostate & e, const TUSubsequence & rb);
    mfecovar_macrostate mladl(const TUSubsequence & lb, const TUSubsequence & dl, const mfecovar_macrostate & e, const TUSubsequence & rb);
    mfecovar_macrostate mladldr(const TUSubsequence & lb, const TUSubsequence & dl, const mfecovar_macrostate & e, const TUSubsequence & dr, const TUSubsequence & rb);
    mfecovar_macrostate mladlr(const TUSubsequence & lb, const TUSubsequence & dl, const mfecovar_macrostate & e, const TUSubsequence & dr, const TUSubsequence & rb);
    mfecovar_macrostate mladr(const TUSubsequence & lb, const mfecovar_macrostate & e, const TUSubsequence & dr, const TUSubsequence & rb);
    mfecovar_macrostate mldl(const TUSubsequence & lb, const TUSubsequence & dl, const mfecovar_macrostate & e, const TUSubsequence & rb);
    mfecovar_macrostate mldladr(const TUSubsequence & lb, const TUSubsequence & dl, const mfecovar_macrostate & e, const TUSubsequence & dr, const TUSubsequence & rb);
    mfecovar_macrostate mldlr(const TUSubsequence & lb, const TUSubsequence & dl, const mfecovar_macrostate & e, const TUSubsequence & dr, const TUSubsequence & rb);
    mfecovar_macrostate mldr(const TUSubsequence & lb, const mfecovar_macrostate & e, const TUSubsequence & dr, const TUSubsequence & rb);
    mfecovar_macrostate nil(const TUSubsequence & loc);
    mfecovar_macrostate sadd(const TUSubsequence & lb, const mfecovar_macrostate & e);
    mfecovar_macrostate sr(const TUSubsequence & lb, const mfecovar_macrostate & e, const TUSubsequence & rb);
    mfecovar_macrostate ssadd(const TUSubsequence & lb, const mfecovar_macrostate & e);
    mfecovar_macrostate trafo(const mfecovar_macrostate & e);


 public:
   void cyk();

 public:
   mfecovar_macrostate run()
{
  return nt_struct();
}
void print_stats(std::ostream &o)
{
#ifdef STATS
      o << "\n\nN = " << seq.size() << '\n';
      block_dl_table.print_stats(o, "block_dl_table");
      block_dlr_table.print_stats(o, "block_dlr_table");
      dl_or_ss_left_no_ss_end_table.print_stats(o, "dl_or_ss_left_no_ss_end_table");
      dl_or_ss_left_ss_end_table.print_stats(o, "dl_or_ss_left_ss_end_table");
      edanglel_table.print_stats(o, "edanglel_table");
      edanglelr_table.print_stats(o, "edanglelr_table");
      edangler_table.print_stats(o, "edangler_table");
      iloop_table.print_stats(o, "iloop_table");
      left_dangle_table.print_stats(o, "left_dangle_table");
      left_unpaired_table.print_stats(o, "left_unpaired_table");
      ml_comps1_table.print_stats(o, "ml_comps1_table");
      ml_comps2_table.print_stats(o, "ml_comps2_table");
      ml_comps3_table.print_stats(o, "ml_comps3_table");
      ml_comps4_table.print_stats(o, "ml_comps4_table");
      no_dl_no_ss_end_table.print_stats(o, "no_dl_no_ss_end_table");
      no_dl_ss_end_table.print_stats(o, "no_dl_ss_end_table");
      nodangle_table.print_stats(o, "nodangle_table");
      noleft_dangle_table.print_stats(o, "noleft_dangle_table");
      strong_table.print_stats(o, "strong_table");
      weak_table.print_stats(o, "weak_table");
#endif
}

template <typename Value, typename pos_int>
struct Backtrace_acomb : Backtrace_Score<mfecovar_macrostate, Value, pos_int> {
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_le;
      TUSubsequence arg_p_p_b;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_re;

Backtrace_acomb(intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_le_, TUSubsequence arg_p_p_b_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_re_)
 : arg_p_p_le(arg_p_p_le_), arg_p_p_b(arg_p_p_b_), arg_p_p_re(arg_p_p_re_)
{}

~Backtrace_acomb()
{
erase(arg_p_p_le);
erase(arg_p_p_re);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      std::pair<String, shape_t>  acomb_l(const std::pair<String, shape_t> & p_le, const TUSubsequence & p_b, const std::pair<String, shape_t> & p_re)
      {
        String l_0 = p_le.first;
        TUSubsequence l_1 = p_b;
        String l_2 = p_re.first;
        shape_t r_0 = p_le.second;
        TUSubsequence r_1 = p_b;
        shape_t r_2 = p_re.second;
        String ret_left = acomb_l_l(l_0, l_1, l_2);
        shape_t ret_right = acomb_l_r(r_0, r_1, r_2);
        std::pair<String, shape_t>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      String acomb_l_l(const String & le, const TUSubsequence & b, const String & re)
      {
#line 304 ""
        String res;
        append( res, le);
        append( res, '.');
        append( res, re);
        return res;
#line 1826 ""
      }


      shape_t acomb_l_r(shape_t le, const TUSubsequence & b, shape_t re)
      {
#line 1089 ""
        if ((shapelevel() == 1))
          {
            return ((le + shape_t('_')) + re);
          }

        else
          {
            return (le + re);
          }

#line 1843 ""
      }


      answer_ali_pfunc_macrostate acomb_r(const answer_ali_pfunc_macrostate & le, const TUSubsequence & b, const answer_ali_pfunc_macrostate & re)
      {
#line 1948 ""
        answer_ali_pfunc_macrostate res;
        int wcDr = 0;
        int wobDr = 0;
        int wcDl = 0;
        int wobDl = 0;
        for(        int k = 0; (k < int(rows(b)));         k = (k + 1))
        {
          base_t baseLeftStem = base_t(column(seq_char(le.firststem, (b.i - 1)), k));
          base_t baseRightStem = base_t(column(seq_char(re.firststem, (b.i + 1)), k));
          base_t baseAmbigious = base_t(column(seq_char(b, b.i), k));
          wcDr = (wcDr + dr_dangle_dg(wc_comp(baseLeftStem), baseLeftStem, baseAmbigious));
          wobDr = (wobDr + dr_dangle_dg(wob_comp(baseLeftStem), baseLeftStem, baseAmbigious));
          wcDl = (wcDl + dl_dangle_dg(baseAmbigious, baseRightStem, wc_comp(baseRightStem)));
          wobDl = (wobDl + dl_dangle_dg(baseAmbigious, baseRightStem, wob_comp(baseRightStem)));
        }

        wcDr = int((wcDr / float(rows(b))));
        wobDr = int((wobDr / float(rows(b))));
        wcDl = int((wcDl / float(rows(b))));
        wobDl = int((wobDl / float(rows(b))));
        res.pf.q1 = ((le.pf.q1 *  ( ((re.pf.q1 * mk_pf(min(wcDr, wcDl))) + (re.pf.q3 * mk_pf(min(wcDr, wobDl)))) ) ) + (le.pf.q2 *  ( ((re.pf.q1 * mk_pf(min(wobDr, wcDl))) + (re.pf.q3 * mk_pf(min(wobDr, wobDl)))) ) ));
        res.pf.q2 = ((le.pf.q2 *  ( ((re.pf.q2 * mk_pf(min(wobDr, wcDl))) + (re.pf.q4 * mk_pf(min(wobDr, wobDl)))) ) ) + (le.pf.q1 *  ( ((re.pf.q2 * mk_pf(min(wcDr, wcDl))) + (re.pf.q4 * mk_pf(min(wcDr, wobDl)))) ) ));
        res.pf.q3 = ((le.pf.q3 *  ( ((re.pf.q3 * mk_pf(min(wcDr, wobDl))) + (re.pf.q1 * mk_pf(min(wcDr, wcDl)))) ) ) + (le.pf.q4 *  ( ((re.pf.q3 * mk_pf(min(wobDr, wobDl))) + (re.pf.q1 * mk_pf(min(wobDr, wcDl)))) ) ));
        res.pf.q4 = ((le.pf.q4 *  ( ((re.pf.q4 * mk_pf(min(wobDr, wobDl))) + (re.pf.q2 * mk_pf(min(wobDr, wcDl)))) ) ) + (le.pf.q3 *  ( ((re.pf.q4 * mk_pf(min(wcDr, wobDl))) + (re.pf.q2 * mk_pf(min(wcDr, wcDl)))) ) ));
        res.pf.q1 = (res.pf.q1 * scale(1));
        res.pf.q2 = (res.pf.q2 * scale(1));
        res.pf.q3 = (res.pf.q3 * scale(1));
        res.pf.q4 = (res.pf.q4 * scale(1));
        res.firststem = le.firststem;
        return res;
#line 1880 ""
      }


      std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  acomb(const std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate> & p_p_le, const TUSubsequence & p_p_b, const std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate> & p_p_re)
      {
        std::pair<String, shape_t>  l_0 = p_p_le.first;
        TUSubsequence l_1 = p_p_b;
        std::pair<String, shape_t>  l_2 = p_p_re.first;
        answer_ali_pfunc_macrostate r_0 = p_p_le.second;
        TUSubsequence r_1 = p_p_b;
        answer_ali_pfunc_macrostate r_2 = p_p_re.second;
        std::pair<String, shape_t>  ret_left = acomb_l(l_0, l_1, l_2);
        answer_ali_pfunc_macrostate ret_right = acomb_r(r_0, r_1, r_2);
        std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_p_p_le_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_p_p_le);
        if (!arg_p_p_le_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_le_bt = arg_p_p_le;
          intrusive_ptr<Backtrace_List<Value, pos_int> > arg_p_p_re_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_p_p_re);
          if (!arg_p_p_re_t) {
            intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_re_bt = arg_p_p_re;
            intrusive_ptr<Eval_List<Value> > arg_p_p_le_elist = evaluate(arg_p_p_le_bt);
            intrusive_ptr<Eval_List<Value> > arg_p_p_re_elist = evaluate(arg_p_p_re_bt);
            for (typename Eval_List<Value>::iterator arg_p_p_le_elem_itr = arg_p_p_le_elist->begin(); arg_p_p_le_elem_itr != arg_p_p_le_elist->end(); ++ arg_p_p_le_elem_itr) {
              std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_le_elem = *arg_p_p_le_elem_itr;
              for (typename Eval_List<Value>::iterator arg_p_p_re_elem_itr = arg_p_p_re_elist->begin(); arg_p_p_re_elem_itr != arg_p_p_re_elist->end(); ++ arg_p_p_re_elem_itr) {
                std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_re_elem = *arg_p_p_re_elem_itr;
                std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret = acomb(arg_p_p_le_elem, arg_p_p_b, arg_p_p_re_elem);
                push_back( answer, ret);
              }
            }
            erase( arg_p_p_le_elist);
            erase( arg_p_p_re_elist);
          } else 
          for (typename Backtrace_List<Value, pos_int>::iterator arg_p_p_re_bt_itr = arg_p_p_re_t->begin(); arg_p_p_re_bt_itr != arg_p_p_re_t->end(); ++ arg_p_p_re_bt_itr) {
            intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_re_bt = *arg_p_p_re_bt_itr;
            intrusive_ptr<Eval_List<Value> > arg_p_p_le_elist = evaluate(arg_p_p_le_bt);
            intrusive_ptr<Eval_List<Value> > arg_p_p_re_elist = evaluate(arg_p_p_re_bt);
            for (typename Eval_List<Value>::iterator arg_p_p_le_elem_itr = arg_p_p_le_elist->begin(); arg_p_p_le_elem_itr != arg_p_p_le_elist->end(); ++ arg_p_p_le_elem_itr) {
              std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_le_elem = *arg_p_p_le_elem_itr;
              for (typename Eval_List<Value>::iterator arg_p_p_re_elem_itr = arg_p_p_re_elist->begin(); arg_p_p_re_elem_itr != arg_p_p_re_elist->end(); ++ arg_p_p_re_elem_itr) {
                std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_re_elem = *arg_p_p_re_elem_itr;
                std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret = acomb(arg_p_p_le_elem, arg_p_p_b, arg_p_p_re_elem);
                push_back( answer, ret);
              }
            }
            erase( arg_p_p_le_elist);
            erase( arg_p_p_re_elist);
          }
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_p_p_le_bt_itr = arg_p_p_le_t->begin(); arg_p_p_le_bt_itr != arg_p_p_le_t->end(); ++ arg_p_p_le_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_le_bt = *arg_p_p_le_bt_itr;
          intrusive_ptr<Backtrace_List<Value, pos_int> > arg_p_p_re_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_p_p_re);
          if (!arg_p_p_re_t) {
            intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_re_bt = arg_p_p_re;
            intrusive_ptr<Eval_List<Value> > arg_p_p_le_elist = evaluate(arg_p_p_le_bt);
            intrusive_ptr<Eval_List<Value> > arg_p_p_re_elist = evaluate(arg_p_p_re_bt);
            for (typename Eval_List<Value>::iterator arg_p_p_le_elem_itr = arg_p_p_le_elist->begin(); arg_p_p_le_elem_itr != arg_p_p_le_elist->end(); ++ arg_p_p_le_elem_itr) {
              std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_le_elem = *arg_p_p_le_elem_itr;
              for (typename Eval_List<Value>::iterator arg_p_p_re_elem_itr = arg_p_p_re_elist->begin(); arg_p_p_re_elem_itr != arg_p_p_re_elist->end(); ++ arg_p_p_re_elem_itr) {
                std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_re_elem = *arg_p_p_re_elem_itr;
                std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret = acomb(arg_p_p_le_elem, arg_p_p_b, arg_p_p_re_elem);
                push_back( answer, ret);
              }
            }
            erase( arg_p_p_le_elist);
            erase( arg_p_p_re_elist);
          } else 
          for (typename Backtrace_List<Value, pos_int>::iterator arg_p_p_re_bt_itr = arg_p_p_re_t->begin(); arg_p_p_re_bt_itr != arg_p_p_re_t->end(); ++ arg_p_p_re_bt_itr) {
            intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_re_bt = *arg_p_p_re_bt_itr;
            intrusive_ptr<Eval_List<Value> > arg_p_p_le_elist = evaluate(arg_p_p_le_bt);
            intrusive_ptr<Eval_List<Value> > arg_p_p_re_elist = evaluate(arg_p_p_re_bt);
            for (typename Eval_List<Value>::iterator arg_p_p_le_elem_itr = arg_p_p_le_elist->begin(); arg_p_p_le_elem_itr != arg_p_p_le_elist->end(); ++ arg_p_p_le_elem_itr) {
              std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_le_elem = *arg_p_p_le_elem_itr;
              for (typename Eval_List<Value>::iterator arg_p_p_re_elem_itr = arg_p_p_re_elist->begin(); arg_p_p_re_elem_itr != arg_p_p_re_elist->end(); ++ arg_p_p_re_elem_itr) {
                std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_re_elem = *arg_p_p_re_elem_itr;
                std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret = acomb(arg_p_p_le_elem, arg_p_p_b, arg_p_p_re_elem);
                push_back( answer, ret);
              }
            }
            erase( arg_p_p_le_elist);
            erase( arg_p_p_re_elist);
          }
        }
        erase( arg_p_p_le);
        erase( arg_p_p_re);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_addss : Backtrace_Score<mfecovar_macrostate, Value, pos_int> {
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e;
      TUSubsequence arg_p_p_rb;

Backtrace_addss(intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_, TUSubsequence arg_p_p_rb_)
 : arg_p_p_e(arg_p_p_e_), arg_p_p_rb(arg_p_p_rb_)
{}

~Backtrace_addss()
{
erase(arg_p_p_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      std::pair<String, shape_t>  addss_l(const std::pair<String, shape_t> & p_e, const TUSubsequence & p_rb)
      {
        String l_0 = p_e.first;
        TUSubsequence l_1 = p_rb;
        shape_t r_0 = p_e.second;
        TUSubsequence r_1 = p_rb;
        String ret_left = addss_l_l(l_0, l_1);
        shape_t ret_right = addss_l_r(r_0, r_1);
        std::pair<String, shape_t>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      String addss_l_l(const String & e, const TUSubsequence & rb)
      {
#line 185 ""
        String res;
        append( res, e);
        append( res, '.', size(rb));
        return res;
#line 2019 ""
      }


      shape_t addss_l_r(shape_t x, const TUSubsequence & rb)
      {
#line 975 ""
        if (( ( (shapelevel() == 1) )  &&  ( (back(x) != '_') ) ))
          {
            return (x + shape_t('_'));
          }

        else
          {
            return x;
          }

#line 2036 ""
      }


      answer_ali_pfunc_macrostate addss_r(const answer_ali_pfunc_macrostate & e, const TUSubsequence & rregion)
      {
#line 1894 ""
        answer_ali_pfunc_macrostate res;
        res.firststem = e.firststem;
        res.pf = mult_tup((scale((rregion.j - rregion.i)) * mk_pf(int((ss_energy(rregion) / float(rows(rregion)))))), e.pf);
        return res;
#line 2047 ""
      }


      std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  addss(const std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate> & p_p_e, const TUSubsequence & p_p_rb)
      {
        std::pair<String, shape_t>  l_0 = p_p_e.first;
        TUSubsequence l_1 = p_p_rb;
        answer_ali_pfunc_macrostate r_0 = p_p_e.second;
        TUSubsequence r_1 = p_p_rb;
        std::pair<String, shape_t>  ret_left = addss_l(l_0, l_1);
        answer_ali_pfunc_macrostate ret_right = addss_r(r_0, r_1);
        std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_p_p_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_p_p_e);
        if (!arg_p_p_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_bt = arg_p_p_e;
          intrusive_ptr<Eval_List<Value> > arg_p_p_e_elist = evaluate(arg_p_p_e_bt);
          for (typename Eval_List<Value>::iterator arg_p_p_e_elem_itr = arg_p_p_e_elist->begin(); arg_p_p_e_elem_itr != arg_p_p_e_elist->end(); ++ arg_p_p_e_elem_itr) {
            std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_e_elem = *arg_p_p_e_elem_itr;
            std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret = addss(arg_p_p_e_elem, arg_p_p_rb);
            push_back( answer, ret);
          }
          erase( arg_p_p_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_p_p_e_bt_itr = arg_p_p_e_t->begin(); arg_p_p_e_bt_itr != arg_p_p_e_t->end(); ++ arg_p_p_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_bt = *arg_p_p_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_p_p_e_elist = evaluate(arg_p_p_e_bt);
          for (typename Eval_List<Value>::iterator arg_p_p_e_elem_itr = arg_p_p_e_elist->begin(); arg_p_p_e_elem_itr != arg_p_p_e_elist->end(); ++ arg_p_p_e_elem_itr) {
            std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_e_elem = *arg_p_p_e_elem_itr;
            std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret = addss(arg_p_p_e_elem, arg_p_p_rb);
            push_back( answer, ret);
          }
          erase( arg_p_p_e_elist);
        }
        erase( arg_p_p_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_ambd : Backtrace_Score<mfecovar_macrostate, Value, pos_int> {
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_le;
      TUSubsequence arg_p_p_b;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_re;

Backtrace_ambd(intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_le_, TUSubsequence arg_p_p_b_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_re_)
 : arg_p_p_le(arg_p_p_le_), arg_p_p_b(arg_p_p_b_), arg_p_p_re(arg_p_p_re_)
{}

~Backtrace_ambd()
{
erase(arg_p_p_le);
erase(arg_p_p_re);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      std::pair<String, shape_t>  ambd_l(const std::pair<String, shape_t> & p_le, const TUSubsequence & p_b, const std::pair<String, shape_t> & p_re)
      {
        String l_0 = p_le.first;
        TUSubsequence l_1 = p_b;
        String l_2 = p_re.first;
        shape_t r_0 = p_le.second;
        TUSubsequence r_1 = p_b;
        shape_t r_2 = p_re.second;
        String ret_left = ambd_l_l(l_0, l_1, l_2);
        shape_t ret_right = ambd_l_r(r_0, r_1, r_2);
        std::pair<String, shape_t>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      String ambd_l_l(const String & le, const TUSubsequence & b, const String & re)
      {
#line 222 ""
        String res;
        append( res, le);
        append( res, '.');
        append( res, re);
        return res;
#line 2140 ""
      }


      shape_t ambd_l_r(shape_t le, const TUSubsequence & b, shape_t re)
      {
#line 1011 ""
        if ((shapelevel() == 1))
          {
            return ((le + shape_t('_')) + re);
          }

        else
          {
            return (le + re);
          }

#line 2157 ""
      }


      answer_ali_pfunc_macrostate ambd_r(const answer_ali_pfunc_macrostate & le, const TUSubsequence & b, const answer_ali_pfunc_macrostate & re)
      {
#line 1486 ""
        answer_ali_pfunc_macrostate res;
        res.firststem = le.firststem;
        res.pf.q1 = (scale(1) * check_tuple(le.pf.q1, le.firststem, re.firststem, b, re.pf));
        res.pf.q2 = 0.000000e+00;
        res.pf.q3 = 0.000000e+00;
        res.pf.q4 = 0.000000e+00;
        return res;
#line 2171 ""
      }


      std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ambd(const std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate> & p_p_le, const TUSubsequence & p_p_b, const std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate> & p_p_re)
      {
        std::pair<String, shape_t>  l_0 = p_p_le.first;
        TUSubsequence l_1 = p_p_b;
        std::pair<String, shape_t>  l_2 = p_p_re.first;
        answer_ali_pfunc_macrostate r_0 = p_p_le.second;
        TUSubsequence r_1 = p_p_b;
        answer_ali_pfunc_macrostate r_2 = p_p_re.second;
        std::pair<String, shape_t>  ret_left = ambd_l(l_0, l_1, l_2);
        answer_ali_pfunc_macrostate ret_right = ambd_r(r_0, r_1, r_2);
        std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_p_p_le_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_p_p_le);
        if (!arg_p_p_le_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_le_bt = arg_p_p_le;
          intrusive_ptr<Backtrace_List<Value, pos_int> > arg_p_p_re_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_p_p_re);
          if (!arg_p_p_re_t) {
            intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_re_bt = arg_p_p_re;
            intrusive_ptr<Eval_List<Value> > arg_p_p_le_elist = evaluate(arg_p_p_le_bt);
            intrusive_ptr<Eval_List<Value> > arg_p_p_re_elist = evaluate(arg_p_p_re_bt);
            for (typename Eval_List<Value>::iterator arg_p_p_le_elem_itr = arg_p_p_le_elist->begin(); arg_p_p_le_elem_itr != arg_p_p_le_elist->end(); ++ arg_p_p_le_elem_itr) {
              std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_le_elem = *arg_p_p_le_elem_itr;
              for (typename Eval_List<Value>::iterator arg_p_p_re_elem_itr = arg_p_p_re_elist->begin(); arg_p_p_re_elem_itr != arg_p_p_re_elist->end(); ++ arg_p_p_re_elem_itr) {
                std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_re_elem = *arg_p_p_re_elem_itr;
                std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret = ambd(arg_p_p_le_elem, arg_p_p_b, arg_p_p_re_elem);
                push_back( answer, ret);
              }
            }
            erase( arg_p_p_le_elist);
            erase( arg_p_p_re_elist);
          } else 
          for (typename Backtrace_List<Value, pos_int>::iterator arg_p_p_re_bt_itr = arg_p_p_re_t->begin(); arg_p_p_re_bt_itr != arg_p_p_re_t->end(); ++ arg_p_p_re_bt_itr) {
            intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_re_bt = *arg_p_p_re_bt_itr;
            intrusive_ptr<Eval_List<Value> > arg_p_p_le_elist = evaluate(arg_p_p_le_bt);
            intrusive_ptr<Eval_List<Value> > arg_p_p_re_elist = evaluate(arg_p_p_re_bt);
            for (typename Eval_List<Value>::iterator arg_p_p_le_elem_itr = arg_p_p_le_elist->begin(); arg_p_p_le_elem_itr != arg_p_p_le_elist->end(); ++ arg_p_p_le_elem_itr) {
              std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_le_elem = *arg_p_p_le_elem_itr;
              for (typename Eval_List<Value>::iterator arg_p_p_re_elem_itr = arg_p_p_re_elist->begin(); arg_p_p_re_elem_itr != arg_p_p_re_elist->end(); ++ arg_p_p_re_elem_itr) {
                std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_re_elem = *arg_p_p_re_elem_itr;
                std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret = ambd(arg_p_p_le_elem, arg_p_p_b, arg_p_p_re_elem);
                push_back( answer, ret);
              }
            }
            erase( arg_p_p_le_elist);
            erase( arg_p_p_re_elist);
          }
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_p_p_le_bt_itr = arg_p_p_le_t->begin(); arg_p_p_le_bt_itr != arg_p_p_le_t->end(); ++ arg_p_p_le_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_le_bt = *arg_p_p_le_bt_itr;
          intrusive_ptr<Backtrace_List<Value, pos_int> > arg_p_p_re_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_p_p_re);
          if (!arg_p_p_re_t) {
            intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_re_bt = arg_p_p_re;
            intrusive_ptr<Eval_List<Value> > arg_p_p_le_elist = evaluate(arg_p_p_le_bt);
            intrusive_ptr<Eval_List<Value> > arg_p_p_re_elist = evaluate(arg_p_p_re_bt);
            for (typename Eval_List<Value>::iterator arg_p_p_le_elem_itr = arg_p_p_le_elist->begin(); arg_p_p_le_elem_itr != arg_p_p_le_elist->end(); ++ arg_p_p_le_elem_itr) {
              std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_le_elem = *arg_p_p_le_elem_itr;
              for (typename Eval_List<Value>::iterator arg_p_p_re_elem_itr = arg_p_p_re_elist->begin(); arg_p_p_re_elem_itr != arg_p_p_re_elist->end(); ++ arg_p_p_re_elem_itr) {
                std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_re_elem = *arg_p_p_re_elem_itr;
                std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret = ambd(arg_p_p_le_elem, arg_p_p_b, arg_p_p_re_elem);
                push_back( answer, ret);
              }
            }
            erase( arg_p_p_le_elist);
            erase( arg_p_p_re_elist);
          } else 
          for (typename Backtrace_List<Value, pos_int>::iterator arg_p_p_re_bt_itr = arg_p_p_re_t->begin(); arg_p_p_re_bt_itr != arg_p_p_re_t->end(); ++ arg_p_p_re_bt_itr) {
            intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_re_bt = *arg_p_p_re_bt_itr;
            intrusive_ptr<Eval_List<Value> > arg_p_p_le_elist = evaluate(arg_p_p_le_bt);
            intrusive_ptr<Eval_List<Value> > arg_p_p_re_elist = evaluate(arg_p_p_re_bt);
            for (typename Eval_List<Value>::iterator arg_p_p_le_elem_itr = arg_p_p_le_elist->begin(); arg_p_p_le_elem_itr != arg_p_p_le_elist->end(); ++ arg_p_p_le_elem_itr) {
              std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_le_elem = *arg_p_p_le_elem_itr;
              for (typename Eval_List<Value>::iterator arg_p_p_re_elem_itr = arg_p_p_re_elist->begin(); arg_p_p_re_elem_itr != arg_p_p_re_elist->end(); ++ arg_p_p_re_elem_itr) {
                std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_re_elem = *arg_p_p_re_elem_itr;
                std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret = ambd(arg_p_p_le_elem, arg_p_p_b, arg_p_p_re_elem);
                push_back( answer, ret);
              }
            }
            erase( arg_p_p_le_elist);
            erase( arg_p_p_re_elist);
          }
        }
        erase( arg_p_p_le);
        erase( arg_p_p_re);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_ambd_Pr : Backtrace_Score<mfecovar_macrostate, Value, pos_int> {
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_le;
      TUSubsequence arg_p_p_b;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_re;

Backtrace_ambd_Pr(intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_le_, TUSubsequence arg_p_p_b_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_re_)
 : arg_p_p_le(arg_p_p_le_), arg_p_p_b(arg_p_p_b_), arg_p_p_re(arg_p_p_re_)
{}

~Backtrace_ambd_Pr()
{
erase(arg_p_p_le);
erase(arg_p_p_re);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      std::pair<String, shape_t>  ambd_Pr_l(const std::pair<String, shape_t> & p_le, const TUSubsequence & p_b, const std::pair<String, shape_t> & p_re)
      {
        String l_0 = p_le.first;
        TUSubsequence l_1 = p_b;
        String l_2 = p_re.first;
        shape_t r_0 = p_le.second;
        TUSubsequence r_1 = p_b;
        shape_t r_2 = p_re.second;
        String ret_left = ambd_Pr_l_l(l_0, l_1, l_2);
        shape_t ret_right = ambd_Pr_l_r(r_0, r_1, r_2);
        std::pair<String, shape_t>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      String ambd_Pr_l_l(const String & le, const TUSubsequence & b, const String & re)
      {
#line 230 ""
        String res;
        append( res, le);
        append( res, '.');
        append( res, re);
        return res;
#line 2315 ""
      }


      shape_t ambd_Pr_l_r(shape_t le, const TUSubsequence & b, shape_t re)
      {
#line 1019 ""
        if ((shapelevel() == 1))
          {
            return ((le + shape_t('_')) + re);
          }

        else
          {
            return (le + re);
          }

#line 2332 ""
      }


      answer_ali_pfunc_macrostate ambd_Pr_r(const answer_ali_pfunc_macrostate & le, const TUSubsequence & b, const answer_ali_pfunc_macrostate & re)
      {
#line 1499 ""
        answer_ali_pfunc_macrostate res;
        res.firststem = le.firststem;
        res.pf = mk_tuple(le.firststem, (scale(1) * check_tuple(le.pf.q1, le.firststem, re.firststem, b, re.pf)));
        return res;
#line 2343 ""
      }


      std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ambd_Pr(const std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate> & p_p_le, const TUSubsequence & p_p_b, const std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate> & p_p_re)
      {
        std::pair<String, shape_t>  l_0 = p_p_le.first;
        TUSubsequence l_1 = p_p_b;
        std::pair<String, shape_t>  l_2 = p_p_re.first;
        answer_ali_pfunc_macrostate r_0 = p_p_le.second;
        TUSubsequence r_1 = p_p_b;
        answer_ali_pfunc_macrostate r_2 = p_p_re.second;
        std::pair<String, shape_t>  ret_left = ambd_Pr_l(l_0, l_1, l_2);
        answer_ali_pfunc_macrostate ret_right = ambd_Pr_r(r_0, r_1, r_2);
        std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_p_p_le_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_p_p_le);
        if (!arg_p_p_le_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_le_bt = arg_p_p_le;
          intrusive_ptr<Backtrace_List<Value, pos_int> > arg_p_p_re_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_p_p_re);
          if (!arg_p_p_re_t) {
            intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_re_bt = arg_p_p_re;
            intrusive_ptr<Eval_List<Value> > arg_p_p_le_elist = evaluate(arg_p_p_le_bt);
            intrusive_ptr<Eval_List<Value> > arg_p_p_re_elist = evaluate(arg_p_p_re_bt);
            for (typename Eval_List<Value>::iterator arg_p_p_le_elem_itr = arg_p_p_le_elist->begin(); arg_p_p_le_elem_itr != arg_p_p_le_elist->end(); ++ arg_p_p_le_elem_itr) {
              std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_le_elem = *arg_p_p_le_elem_itr;
              for (typename Eval_List<Value>::iterator arg_p_p_re_elem_itr = arg_p_p_re_elist->begin(); arg_p_p_re_elem_itr != arg_p_p_re_elist->end(); ++ arg_p_p_re_elem_itr) {
                std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_re_elem = *arg_p_p_re_elem_itr;
                std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret = ambd_Pr(arg_p_p_le_elem, arg_p_p_b, arg_p_p_re_elem);
                push_back( answer, ret);
              }
            }
            erase( arg_p_p_le_elist);
            erase( arg_p_p_re_elist);
          } else 
          for (typename Backtrace_List<Value, pos_int>::iterator arg_p_p_re_bt_itr = arg_p_p_re_t->begin(); arg_p_p_re_bt_itr != arg_p_p_re_t->end(); ++ arg_p_p_re_bt_itr) {
            intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_re_bt = *arg_p_p_re_bt_itr;
            intrusive_ptr<Eval_List<Value> > arg_p_p_le_elist = evaluate(arg_p_p_le_bt);
            intrusive_ptr<Eval_List<Value> > arg_p_p_re_elist = evaluate(arg_p_p_re_bt);
            for (typename Eval_List<Value>::iterator arg_p_p_le_elem_itr = arg_p_p_le_elist->begin(); arg_p_p_le_elem_itr != arg_p_p_le_elist->end(); ++ arg_p_p_le_elem_itr) {
              std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_le_elem = *arg_p_p_le_elem_itr;
              for (typename Eval_List<Value>::iterator arg_p_p_re_elem_itr = arg_p_p_re_elist->begin(); arg_p_p_re_elem_itr != arg_p_p_re_elist->end(); ++ arg_p_p_re_elem_itr) {
                std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_re_elem = *arg_p_p_re_elem_itr;
                std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret = ambd_Pr(arg_p_p_le_elem, arg_p_p_b, arg_p_p_re_elem);
                push_back( answer, ret);
              }
            }
            erase( arg_p_p_le_elist);
            erase( arg_p_p_re_elist);
          }
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_p_p_le_bt_itr = arg_p_p_le_t->begin(); arg_p_p_le_bt_itr != arg_p_p_le_t->end(); ++ arg_p_p_le_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_le_bt = *arg_p_p_le_bt_itr;
          intrusive_ptr<Backtrace_List<Value, pos_int> > arg_p_p_re_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_p_p_re);
          if (!arg_p_p_re_t) {
            intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_re_bt = arg_p_p_re;
            intrusive_ptr<Eval_List<Value> > arg_p_p_le_elist = evaluate(arg_p_p_le_bt);
            intrusive_ptr<Eval_List<Value> > arg_p_p_re_elist = evaluate(arg_p_p_re_bt);
            for (typename Eval_List<Value>::iterator arg_p_p_le_elem_itr = arg_p_p_le_elist->begin(); arg_p_p_le_elem_itr != arg_p_p_le_elist->end(); ++ arg_p_p_le_elem_itr) {
              std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_le_elem = *arg_p_p_le_elem_itr;
              for (typename Eval_List<Value>::iterator arg_p_p_re_elem_itr = arg_p_p_re_elist->begin(); arg_p_p_re_elem_itr != arg_p_p_re_elist->end(); ++ arg_p_p_re_elem_itr) {
                std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_re_elem = *arg_p_p_re_elem_itr;
                std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret = ambd_Pr(arg_p_p_le_elem, arg_p_p_b, arg_p_p_re_elem);
                push_back( answer, ret);
              }
            }
            erase( arg_p_p_le_elist);
            erase( arg_p_p_re_elist);
          } else 
          for (typename Backtrace_List<Value, pos_int>::iterator arg_p_p_re_bt_itr = arg_p_p_re_t->begin(); arg_p_p_re_bt_itr != arg_p_p_re_t->end(); ++ arg_p_p_re_bt_itr) {
            intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_re_bt = *arg_p_p_re_bt_itr;
            intrusive_ptr<Eval_List<Value> > arg_p_p_le_elist = evaluate(arg_p_p_le_bt);
            intrusive_ptr<Eval_List<Value> > arg_p_p_re_elist = evaluate(arg_p_p_re_bt);
            for (typename Eval_List<Value>::iterator arg_p_p_le_elem_itr = arg_p_p_le_elist->begin(); arg_p_p_le_elem_itr != arg_p_p_le_elist->end(); ++ arg_p_p_le_elem_itr) {
              std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_le_elem = *arg_p_p_le_elem_itr;
              for (typename Eval_List<Value>::iterator arg_p_p_re_elem_itr = arg_p_p_re_elist->begin(); arg_p_p_re_elem_itr != arg_p_p_re_elist->end(); ++ arg_p_p_re_elem_itr) {
                std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_re_elem = *arg_p_p_re_elem_itr;
                std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret = ambd_Pr(arg_p_p_le_elem, arg_p_p_b, arg_p_p_re_elem);
                push_back( answer, ret);
              }
            }
            erase( arg_p_p_le_elist);
            erase( arg_p_p_re_elist);
          }
        }
        erase( arg_p_p_le);
        erase( arg_p_p_re);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_bl : Backtrace_Score<mfecovar_macrostate, Value, pos_int> {
      TUSubsequence arg_p_p_lb;
      TUSubsequence arg_p_p_lregion;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e;
      TUSubsequence arg_p_p_rb;

Backtrace_bl(TUSubsequence arg_p_p_lb_, TUSubsequence arg_p_p_lregion_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_, TUSubsequence arg_p_p_rb_)
 : arg_p_p_lb(arg_p_p_lb_), arg_p_p_lregion(arg_p_p_lregion_), arg_p_p_e(arg_p_p_e_), arg_p_p_rb(arg_p_p_rb_)
{}

~Backtrace_bl()
{
erase(arg_p_p_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      std::pair<String, shape_t>  bl_l(const TUSubsequence & p_lb, const TUSubsequence & p_lregion, const std::pair<String, shape_t> & p_e, const TUSubsequence & p_rb)
      {
        TUSubsequence l_0 = p_lb;
        TUSubsequence l_1 = p_lregion;
        String l_2 = p_e.first;
        TUSubsequence l_3 = p_rb;
        TUSubsequence r_0 = p_lb;
        TUSubsequence r_1 = p_lregion;
        shape_t r_2 = p_e.second;
        TUSubsequence r_3 = p_rb;
        String ret_left = bl_l_l(l_0, l_1, l_2, l_3);
        shape_t ret_right = bl_l_r(r_0, r_1, r_2, r_3);
        std::pair<String, shape_t>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      String bl_l_l(const TUSubsequence & lb, const TUSubsequence & lregion, const String & e, const TUSubsequence & rb)
      {
#line 121 ""
        String res;
        append( res, '(');
        append( res, '.', size(lregion));
        append( res, e);
        append( res, ')');
        return res;
#line 2490 ""
      }


      shape_t bl_l_r(const TUSubsequence & lb, const TUSubsequence & lregion, shape_t x, const TUSubsequence & rb)
      {
#line 902 ""
        if ((shapelevel() <= 3))
        {
          shape_t res;
          append( res, openParen);
          if ((shapelevel() <= 2))
            {
              append( res, '_');
            }

          append( res, x);
          append( res, closeParen);
          return res;
        }

        else
          {
            return x;
          }

#line 2516 ""
      }


      answer_ali_pfunc_macrostate bl_r(const TUSubsequence & lb, const TUSubsequence & lregion, const answer_ali_pfunc_macrostate & e, const TUSubsequence & rb)
      {
#line 1608 ""
        answer_ali_pfunc_macrostate res;
        res.firststem.i = lb.i;
        res.firststem.j = rb.j;
        res.firststem.seq = lb.seq;
        res.pf.q1 = ((scale(((lregion.j - lregion.i) + 2)) * e.pf.q1) * mk_pf((int((bl_energy(lregion, rb) / float(rows(lregion)))) + covscore(lb, lb.i, rb.i))));
        res.pf.q2 = 0.000000e+00;
        res.pf.q3 = 0.000000e+00;
        res.pf.q4 = 0.000000e+00;
        return res;
#line 2532 ""
      }


      std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  bl(const TUSubsequence & p_p_lb, const TUSubsequence & p_p_lregion, const std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate> & p_p_e, const TUSubsequence & p_p_rb)
      {
        TUSubsequence l_0 = p_p_lb;
        TUSubsequence l_1 = p_p_lregion;
        std::pair<String, shape_t>  l_2 = p_p_e.first;
        TUSubsequence l_3 = p_p_rb;
        TUSubsequence r_0 = p_p_lb;
        TUSubsequence r_1 = p_p_lregion;
        answer_ali_pfunc_macrostate r_2 = p_p_e.second;
        TUSubsequence r_3 = p_p_rb;
        std::pair<String, shape_t>  ret_left = bl_l(l_0, l_1, l_2, l_3);
        answer_ali_pfunc_macrostate ret_right = bl_r(r_0, r_1, r_2, r_3);
        std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_p_p_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_p_p_e);
        if (!arg_p_p_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_bt = arg_p_p_e;
          intrusive_ptr<Eval_List<Value> > arg_p_p_e_elist = evaluate(arg_p_p_e_bt);
          for (typename Eval_List<Value>::iterator arg_p_p_e_elem_itr = arg_p_p_e_elist->begin(); arg_p_p_e_elem_itr != arg_p_p_e_elist->end(); ++ arg_p_p_e_elem_itr) {
            std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_e_elem = *arg_p_p_e_elem_itr;
            std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret = bl(arg_p_p_lb, arg_p_p_lregion, arg_p_p_e_elem, arg_p_p_rb);
            push_back( answer, ret);
          }
          erase( arg_p_p_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_p_p_e_bt_itr = arg_p_p_e_t->begin(); arg_p_p_e_bt_itr != arg_p_p_e_t->end(); ++ arg_p_p_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_bt = *arg_p_p_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_p_p_e_elist = evaluate(arg_p_p_e_bt);
          for (typename Eval_List<Value>::iterator arg_p_p_e_elem_itr = arg_p_p_e_elist->begin(); arg_p_p_e_elem_itr != arg_p_p_e_elist->end(); ++ arg_p_p_e_elem_itr) {
            std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_e_elem = *arg_p_p_e_elem_itr;
            std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret = bl(arg_p_p_lb, arg_p_p_lregion, arg_p_p_e_elem, arg_p_p_rb);
            push_back( answer, ret);
          }
          erase( arg_p_p_e_elist);
        }
        erase( arg_p_p_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_br : Backtrace_Score<mfecovar_macrostate, Value, pos_int> {
      TUSubsequence arg_p_p_lb;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e;
      TUSubsequence arg_p_p_rregion;
      TUSubsequence arg_p_p_rb;

Backtrace_br(TUSubsequence arg_p_p_lb_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_, TUSubsequence arg_p_p_rregion_, TUSubsequence arg_p_p_rb_)
 : arg_p_p_lb(arg_p_p_lb_), arg_p_p_e(arg_p_p_e_), arg_p_p_rregion(arg_p_p_rregion_), arg_p_p_rb(arg_p_p_rb_)
{}

~Backtrace_br()
{
erase(arg_p_p_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      std::pair<String, shape_t>  br_l(const TUSubsequence & p_lb, const std::pair<String, shape_t> & p_e, const TUSubsequence & p_rregion, const TUSubsequence & p_rb)
      {
        TUSubsequence l_0 = p_lb;
        String l_1 = p_e.first;
        TUSubsequence l_2 = p_rregion;
        TUSubsequence l_3 = p_rb;
        TUSubsequence r_0 = p_lb;
        shape_t r_1 = p_e.second;
        TUSubsequence r_2 = p_rregion;
        TUSubsequence r_3 = p_rb;
        String ret_left = br_l_l(l_0, l_1, l_2, l_3);
        shape_t ret_right = br_l_r(r_0, r_1, r_2, r_3);
        std::pair<String, shape_t>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      String br_l_l(const TUSubsequence & lb, const String & e, const TUSubsequence & rregion, const TUSubsequence & rb)
      {
#line 130 ""
        String res;
        append( res, '(');
        append( res, e);
        append( res, '.', size(rregion));
        append( res, ')');
        return res;
#line 2632 ""
      }


      shape_t br_l_r(const TUSubsequence & lb, shape_t x, const TUSubsequence & rregion, const TUSubsequence & rb)
      {
#line 915 ""
        if ((shapelevel() <= 3))
        {
          shape_t res;
          append( res, openParen);
          append( res, x);
          if ((shapelevel() <= 2))
            {
              append( res, '_');
            }

          append( res, closeParen);
          return res;
        }

        else
          {
            return x;
          }

#line 2658 ""
      }


      answer_ali_pfunc_macrostate br_r(const TUSubsequence & lb, const answer_ali_pfunc_macrostate & e, const TUSubsequence & rregion, const TUSubsequence & rb)
      {
#line 1623 ""
        answer_ali_pfunc_macrostate res;
        res.firststem.i = lb.i;
        res.firststem.j = rb.j;
        res.firststem.seq = lb.seq;
        res.pf.q1 = ((scale(((rregion.j - rregion.i) + 2)) * e.pf.q1) * mk_pf((int((br_energy(lb, rregion) / float(rows(rregion)))) + covscore(lb, lb.i, rb.i))));
        res.pf.q2 = 0.000000e+00;
        res.pf.q3 = 0.000000e+00;
        res.pf.q4 = 0.000000e+00;
        return res;
#line 2674 ""
      }


      std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  br(const TUSubsequence & p_p_lb, const std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate> & p_p_e, const TUSubsequence & p_p_rregion, const TUSubsequence & p_p_rb)
      {
        TUSubsequence l_0 = p_p_lb;
        std::pair<String, shape_t>  l_1 = p_p_e.first;
        TUSubsequence l_2 = p_p_rregion;
        TUSubsequence l_3 = p_p_rb;
        TUSubsequence r_0 = p_p_lb;
        answer_ali_pfunc_macrostate r_1 = p_p_e.second;
        TUSubsequence r_2 = p_p_rregion;
        TUSubsequence r_3 = p_p_rb;
        std::pair<String, shape_t>  ret_left = br_l(l_0, l_1, l_2, l_3);
        answer_ali_pfunc_macrostate ret_right = br_r(r_0, r_1, r_2, r_3);
        std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_p_p_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_p_p_e);
        if (!arg_p_p_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_bt = arg_p_p_e;
          intrusive_ptr<Eval_List<Value> > arg_p_p_e_elist = evaluate(arg_p_p_e_bt);
          for (typename Eval_List<Value>::iterator arg_p_p_e_elem_itr = arg_p_p_e_elist->begin(); arg_p_p_e_elem_itr != arg_p_p_e_elist->end(); ++ arg_p_p_e_elem_itr) {
            std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_e_elem = *arg_p_p_e_elem_itr;
            std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret = br(arg_p_p_lb, arg_p_p_e_elem, arg_p_p_rregion, arg_p_p_rb);
            push_back( answer, ret);
          }
          erase( arg_p_p_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_p_p_e_bt_itr = arg_p_p_e_t->begin(); arg_p_p_e_bt_itr != arg_p_p_e_t->end(); ++ arg_p_p_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_bt = *arg_p_p_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_p_p_e_elist = evaluate(arg_p_p_e_bt);
          for (typename Eval_List<Value>::iterator arg_p_p_e_elem_itr = arg_p_p_e_elist->begin(); arg_p_p_e_elem_itr != arg_p_p_e_elist->end(); ++ arg_p_p_e_elem_itr) {
            std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_e_elem = *arg_p_p_e_elem_itr;
            std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret = br(arg_p_p_lb, arg_p_p_e_elem, arg_p_p_rregion, arg_p_p_rb);
            push_back( answer, ret);
          }
          erase( arg_p_p_e_elist);
        }
        erase( arg_p_p_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_cadd : Backtrace_Score<mfecovar_macrostate, Value, pos_int> {
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_le;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_re;

Backtrace_cadd(intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_le_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_re_)
 : arg_p_p_le(arg_p_p_le_), arg_p_p_re(arg_p_p_re_)
{}

~Backtrace_cadd()
{
erase(arg_p_p_le);
erase(arg_p_p_re);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      std::pair<String, shape_t>  cadd_l(const std::pair<String, shape_t> & p_le, const std::pair<String, shape_t> & p_re)
      {
        String l_0 = p_le.first;
        String l_1 = p_re.first;
        shape_t r_0 = p_le.second;
        shape_t r_1 = p_re.second;
        String ret_left = cadd_l_l(l_0, l_1);
        shape_t ret_right = cadd_l_r(r_0, r_1);
        std::pair<String, shape_t>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      String cadd_l_l(const String & le, const String & re)
      {
#line 66 ""
        String res;
        append( res, le);
        append( res, re);
        return res;
#line 2767 ""
      }


      shape_t cadd_l_r(shape_t le, shape_t re)
      {
#line 844 ""
        if ((shapelevel() == 1))
          {
            if (((back(le) == '_') && (front(re) == '_')))
              {
                return (le + tail(re));
              }

            else
              {
                return (le + re);
              }

          }

        else
          {
            if ((re == '_'))
              {
                return le;
              }

            else
              {
                return (le + re);
              }

          }

#line 2802 ""
      }


      answer_ali_pfunc_macrostate cadd_r(const answer_ali_pfunc_macrostate & le, const answer_ali_pfunc_macrostate & re)
      {
#line 1442 ""
        answer_ali_pfunc_macrostate res;
        res.firststem = le.firststem;
        res.pf.q1 = (le.pf.q1 * re.pf.q1);
        res.pf.q2 = 0.000000e+00;
        res.pf.q3 = 0.000000e+00;
        res.pf.q4 = 0.000000e+00;
        return res;
#line 2816 ""
      }


      std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  cadd(const std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate> & p_p_le, const std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate> & p_p_re)
      {
        std::pair<String, shape_t>  l_0 = p_p_le.first;
        std::pair<String, shape_t>  l_1 = p_p_re.first;
        answer_ali_pfunc_macrostate r_0 = p_p_le.second;
        answer_ali_pfunc_macrostate r_1 = p_p_re.second;
        std::pair<String, shape_t>  ret_left = cadd_l(l_0, l_1);
        answer_ali_pfunc_macrostate ret_right = cadd_r(r_0, r_1);
        std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_p_p_le_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_p_p_le);
        if (!arg_p_p_le_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_le_bt = arg_p_p_le;
          intrusive_ptr<Backtrace_List<Value, pos_int> > arg_p_p_re_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_p_p_re);
          if (!arg_p_p_re_t) {
            intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_re_bt = arg_p_p_re;
            intrusive_ptr<Eval_List<Value> > arg_p_p_le_elist = evaluate(arg_p_p_le_bt);
            intrusive_ptr<Eval_List<Value> > arg_p_p_re_elist = evaluate(arg_p_p_re_bt);
            for (typename Eval_List<Value>::iterator arg_p_p_le_elem_itr = arg_p_p_le_elist->begin(); arg_p_p_le_elem_itr != arg_p_p_le_elist->end(); ++ arg_p_p_le_elem_itr) {
              std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_le_elem = *arg_p_p_le_elem_itr;
              for (typename Eval_List<Value>::iterator arg_p_p_re_elem_itr = arg_p_p_re_elist->begin(); arg_p_p_re_elem_itr != arg_p_p_re_elist->end(); ++ arg_p_p_re_elem_itr) {
                std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_re_elem = *arg_p_p_re_elem_itr;
                std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret = cadd(arg_p_p_le_elem, arg_p_p_re_elem);
                push_back( answer, ret);
              }
            }
            erase( arg_p_p_le_elist);
            erase( arg_p_p_re_elist);
          } else 
          for (typename Backtrace_List<Value, pos_int>::iterator arg_p_p_re_bt_itr = arg_p_p_re_t->begin(); arg_p_p_re_bt_itr != arg_p_p_re_t->end(); ++ arg_p_p_re_bt_itr) {
            intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_re_bt = *arg_p_p_re_bt_itr;
            intrusive_ptr<Eval_List<Value> > arg_p_p_le_elist = evaluate(arg_p_p_le_bt);
            intrusive_ptr<Eval_List<Value> > arg_p_p_re_elist = evaluate(arg_p_p_re_bt);
            for (typename Eval_List<Value>::iterator arg_p_p_le_elem_itr = arg_p_p_le_elist->begin(); arg_p_p_le_elem_itr != arg_p_p_le_elist->end(); ++ arg_p_p_le_elem_itr) {
              std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_le_elem = *arg_p_p_le_elem_itr;
              for (typename Eval_List<Value>::iterator arg_p_p_re_elem_itr = arg_p_p_re_elist->begin(); arg_p_p_re_elem_itr != arg_p_p_re_elist->end(); ++ arg_p_p_re_elem_itr) {
                std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_re_elem = *arg_p_p_re_elem_itr;
                std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret = cadd(arg_p_p_le_elem, arg_p_p_re_elem);
                push_back( answer, ret);
              }
            }
            erase( arg_p_p_le_elist);
            erase( arg_p_p_re_elist);
          }
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_p_p_le_bt_itr = arg_p_p_le_t->begin(); arg_p_p_le_bt_itr != arg_p_p_le_t->end(); ++ arg_p_p_le_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_le_bt = *arg_p_p_le_bt_itr;
          intrusive_ptr<Backtrace_List<Value, pos_int> > arg_p_p_re_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_p_p_re);
          if (!arg_p_p_re_t) {
            intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_re_bt = arg_p_p_re;
            intrusive_ptr<Eval_List<Value> > arg_p_p_le_elist = evaluate(arg_p_p_le_bt);
            intrusive_ptr<Eval_List<Value> > arg_p_p_re_elist = evaluate(arg_p_p_re_bt);
            for (typename Eval_List<Value>::iterator arg_p_p_le_elem_itr = arg_p_p_le_elist->begin(); arg_p_p_le_elem_itr != arg_p_p_le_elist->end(); ++ arg_p_p_le_elem_itr) {
              std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_le_elem = *arg_p_p_le_elem_itr;
              for (typename Eval_List<Value>::iterator arg_p_p_re_elem_itr = arg_p_p_re_elist->begin(); arg_p_p_re_elem_itr != arg_p_p_re_elist->end(); ++ arg_p_p_re_elem_itr) {
                std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_re_elem = *arg_p_p_re_elem_itr;
                std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret = cadd(arg_p_p_le_elem, arg_p_p_re_elem);
                push_back( answer, ret);
              }
            }
            erase( arg_p_p_le_elist);
            erase( arg_p_p_re_elist);
          } else 
          for (typename Backtrace_List<Value, pos_int>::iterator arg_p_p_re_bt_itr = arg_p_p_re_t->begin(); arg_p_p_re_bt_itr != arg_p_p_re_t->end(); ++ arg_p_p_re_bt_itr) {
            intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_re_bt = *arg_p_p_re_bt_itr;
            intrusive_ptr<Eval_List<Value> > arg_p_p_le_elist = evaluate(arg_p_p_le_bt);
            intrusive_ptr<Eval_List<Value> > arg_p_p_re_elist = evaluate(arg_p_p_re_bt);
            for (typename Eval_List<Value>::iterator arg_p_p_le_elem_itr = arg_p_p_le_elist->begin(); arg_p_p_le_elem_itr != arg_p_p_le_elist->end(); ++ arg_p_p_le_elem_itr) {
              std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_le_elem = *arg_p_p_le_elem_itr;
              for (typename Eval_List<Value>::iterator arg_p_p_re_elem_itr = arg_p_p_re_elist->begin(); arg_p_p_re_elem_itr != arg_p_p_re_elist->end(); ++ arg_p_p_re_elem_itr) {
                std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_re_elem = *arg_p_p_re_elem_itr;
                std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret = cadd(arg_p_p_le_elem, arg_p_p_re_elem);
                push_back( answer, ret);
              }
            }
            erase( arg_p_p_le_elist);
            erase( arg_p_p_re_elist);
          }
        }
        erase( arg_p_p_le);
        erase( arg_p_p_re);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_cadd_Pr : Backtrace_Score<mfecovar_macrostate, Value, pos_int> {
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_le;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_re;

Backtrace_cadd_Pr(intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_le_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_re_)
 : arg_p_p_le(arg_p_p_le_), arg_p_p_re(arg_p_p_re_)
{}

~Backtrace_cadd_Pr()
{
erase(arg_p_p_le);
erase(arg_p_p_re);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      std::pair<String, shape_t>  cadd_Pr_l(const std::pair<String, shape_t> & p_le, const std::pair<String, shape_t> & p_re)
      {
        String l_0 = p_le.first;
        String l_1 = p_re.first;
        shape_t r_0 = p_le.second;
        shape_t r_1 = p_re.second;
        String ret_left = cadd_Pr_l_l(l_0, l_1);
        shape_t ret_right = cadd_Pr_l_r(r_0, r_1);
        std::pair<String, shape_t>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      String cadd_Pr_l_l(const String & le, const String & re)
      {
#line 201 ""
        String res;
        append( res, le);
        append( res, re);
        return res;
#line 2954 ""
      }


      shape_t cadd_Pr_l_r(shape_t le, shape_t re)
      {
#line 991 ""
        return (le + re);
#line 2962 ""
      }


      answer_ali_pfunc_macrostate cadd_Pr_r(const answer_ali_pfunc_macrostate & le, const answer_ali_pfunc_macrostate & re)
      {
#line 1455 ""
        answer_ali_pfunc_macrostate res;
        res.firststem = le.firststem;
        res.pf.q1 = (le.pf.q1 * sum_elems(re.pf));
        res.pf.q2 = 0.000000e+00;
        res.pf.q3 = 0.000000e+00;
        res.pf.q4 = 0.000000e+00;
        return res;
#line 2976 ""
      }


      std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  cadd_Pr(const std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate> & p_p_le, const std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate> & p_p_re)
      {
        std::pair<String, shape_t>  l_0 = p_p_le.first;
        std::pair<String, shape_t>  l_1 = p_p_re.first;
        answer_ali_pfunc_macrostate r_0 = p_p_le.second;
        answer_ali_pfunc_macrostate r_1 = p_p_re.second;
        std::pair<String, shape_t>  ret_left = cadd_Pr_l(l_0, l_1);
        answer_ali_pfunc_macrostate ret_right = cadd_Pr_r(r_0, r_1);
        std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_p_p_le_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_p_p_le);
        if (!arg_p_p_le_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_le_bt = arg_p_p_le;
          intrusive_ptr<Backtrace_List<Value, pos_int> > arg_p_p_re_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_p_p_re);
          if (!arg_p_p_re_t) {
            intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_re_bt = arg_p_p_re;
            intrusive_ptr<Eval_List<Value> > arg_p_p_le_elist = evaluate(arg_p_p_le_bt);
            intrusive_ptr<Eval_List<Value> > arg_p_p_re_elist = evaluate(arg_p_p_re_bt);
            for (typename Eval_List<Value>::iterator arg_p_p_le_elem_itr = arg_p_p_le_elist->begin(); arg_p_p_le_elem_itr != arg_p_p_le_elist->end(); ++ arg_p_p_le_elem_itr) {
              std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_le_elem = *arg_p_p_le_elem_itr;
              for (typename Eval_List<Value>::iterator arg_p_p_re_elem_itr = arg_p_p_re_elist->begin(); arg_p_p_re_elem_itr != arg_p_p_re_elist->end(); ++ arg_p_p_re_elem_itr) {
                std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_re_elem = *arg_p_p_re_elem_itr;
                std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret = cadd_Pr(arg_p_p_le_elem, arg_p_p_re_elem);
                push_back( answer, ret);
              }
            }
            erase( arg_p_p_le_elist);
            erase( arg_p_p_re_elist);
          } else 
          for (typename Backtrace_List<Value, pos_int>::iterator arg_p_p_re_bt_itr = arg_p_p_re_t->begin(); arg_p_p_re_bt_itr != arg_p_p_re_t->end(); ++ arg_p_p_re_bt_itr) {
            intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_re_bt = *arg_p_p_re_bt_itr;
            intrusive_ptr<Eval_List<Value> > arg_p_p_le_elist = evaluate(arg_p_p_le_bt);
            intrusive_ptr<Eval_List<Value> > arg_p_p_re_elist = evaluate(arg_p_p_re_bt);
            for (typename Eval_List<Value>::iterator arg_p_p_le_elem_itr = arg_p_p_le_elist->begin(); arg_p_p_le_elem_itr != arg_p_p_le_elist->end(); ++ arg_p_p_le_elem_itr) {
              std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_le_elem = *arg_p_p_le_elem_itr;
              for (typename Eval_List<Value>::iterator arg_p_p_re_elem_itr = arg_p_p_re_elist->begin(); arg_p_p_re_elem_itr != arg_p_p_re_elist->end(); ++ arg_p_p_re_elem_itr) {
                std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_re_elem = *arg_p_p_re_elem_itr;
                std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret = cadd_Pr(arg_p_p_le_elem, arg_p_p_re_elem);
                push_back( answer, ret);
              }
            }
            erase( arg_p_p_le_elist);
            erase( arg_p_p_re_elist);
          }
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_p_p_le_bt_itr = arg_p_p_le_t->begin(); arg_p_p_le_bt_itr != arg_p_p_le_t->end(); ++ arg_p_p_le_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_le_bt = *arg_p_p_le_bt_itr;
          intrusive_ptr<Backtrace_List<Value, pos_int> > arg_p_p_re_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_p_p_re);
          if (!arg_p_p_re_t) {
            intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_re_bt = arg_p_p_re;
            intrusive_ptr<Eval_List<Value> > arg_p_p_le_elist = evaluate(arg_p_p_le_bt);
            intrusive_ptr<Eval_List<Value> > arg_p_p_re_elist = evaluate(arg_p_p_re_bt);
            for (typename Eval_List<Value>::iterator arg_p_p_le_elem_itr = arg_p_p_le_elist->begin(); arg_p_p_le_elem_itr != arg_p_p_le_elist->end(); ++ arg_p_p_le_elem_itr) {
              std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_le_elem = *arg_p_p_le_elem_itr;
              for (typename Eval_List<Value>::iterator arg_p_p_re_elem_itr = arg_p_p_re_elist->begin(); arg_p_p_re_elem_itr != arg_p_p_re_elist->end(); ++ arg_p_p_re_elem_itr) {
                std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_re_elem = *arg_p_p_re_elem_itr;
                std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret = cadd_Pr(arg_p_p_le_elem, arg_p_p_re_elem);
                push_back( answer, ret);
              }
            }
            erase( arg_p_p_le_elist);
            erase( arg_p_p_re_elist);
          } else 
          for (typename Backtrace_List<Value, pos_int>::iterator arg_p_p_re_bt_itr = arg_p_p_re_t->begin(); arg_p_p_re_bt_itr != arg_p_p_re_t->end(); ++ arg_p_p_re_bt_itr) {
            intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_re_bt = *arg_p_p_re_bt_itr;
            intrusive_ptr<Eval_List<Value> > arg_p_p_le_elist = evaluate(arg_p_p_le_bt);
            intrusive_ptr<Eval_List<Value> > arg_p_p_re_elist = evaluate(arg_p_p_re_bt);
            for (typename Eval_List<Value>::iterator arg_p_p_le_elem_itr = arg_p_p_le_elist->begin(); arg_p_p_le_elem_itr != arg_p_p_le_elist->end(); ++ arg_p_p_le_elem_itr) {
              std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_le_elem = *arg_p_p_le_elem_itr;
              for (typename Eval_List<Value>::iterator arg_p_p_re_elem_itr = arg_p_p_re_elist->begin(); arg_p_p_re_elem_itr != arg_p_p_re_elist->end(); ++ arg_p_p_re_elem_itr) {
                std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_re_elem = *arg_p_p_re_elem_itr;
                std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret = cadd_Pr(arg_p_p_le_elem, arg_p_p_re_elem);
                push_back( answer, ret);
              }
            }
            erase( arg_p_p_le_elist);
            erase( arg_p_p_re_elist);
          }
        }
        erase( arg_p_p_le);
        erase( arg_p_p_re);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_cadd_Pr_Pr : Backtrace_Score<mfecovar_macrostate, Value, pos_int> {
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_le;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_re;

Backtrace_cadd_Pr_Pr(intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_le_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_re_)
 : arg_p_p_le(arg_p_p_le_), arg_p_p_re(arg_p_p_re_)
{}

~Backtrace_cadd_Pr_Pr()
{
erase(arg_p_p_le);
erase(arg_p_p_re);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      std::pair<String, shape_t>  cadd_Pr_Pr_l(const std::pair<String, shape_t> & p_le, const std::pair<String, shape_t> & p_re)
      {
        String l_0 = p_le.first;
        String l_1 = p_re.first;
        shape_t r_0 = p_le.second;
        shape_t r_1 = p_re.second;
        String ret_left = cadd_Pr_Pr_l_l(l_0, l_1);
        shape_t ret_right = cadd_Pr_Pr_l_r(r_0, r_1);
        std::pair<String, shape_t>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      String cadd_Pr_Pr_l_l(const String & le, const String & re)
      {
#line 208 ""
        String res;
        append( res, le);
        append( res, re);
        return res;
#line 3114 ""
      }


      shape_t cadd_Pr_Pr_l_r(shape_t le, shape_t re)
      {
#line 995 ""
        if ((shapelevel() == 1))
          {
            return (le + tail(re));
          }

        else
          {
            if ((re == '_'))
              {
                return le;
              }

            else
              {
                return (le + re);
              }

          }

#line 3140 ""
      }


      answer_ali_pfunc_macrostate cadd_Pr_Pr_r(const answer_ali_pfunc_macrostate & le, const answer_ali_pfunc_macrostate & re)
      {
#line 1468 ""
        answer_ali_pfunc_macrostate res;
        res.firststem = le.firststem;
        res.pf = mk_tuple(le.firststem, (le.pf.q1 * re.pf.q1));
        return res;
#line 3151 ""
      }


      std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  cadd_Pr_Pr(const std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate> & p_p_le, const std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate> & p_p_re)
      {
        std::pair<String, shape_t>  l_0 = p_p_le.first;
        std::pair<String, shape_t>  l_1 = p_p_re.first;
        answer_ali_pfunc_macrostate r_0 = p_p_le.second;
        answer_ali_pfunc_macrostate r_1 = p_p_re.second;
        std::pair<String, shape_t>  ret_left = cadd_Pr_Pr_l(l_0, l_1);
        answer_ali_pfunc_macrostate ret_right = cadd_Pr_Pr_r(r_0, r_1);
        std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_p_p_le_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_p_p_le);
        if (!arg_p_p_le_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_le_bt = arg_p_p_le;
          intrusive_ptr<Backtrace_List<Value, pos_int> > arg_p_p_re_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_p_p_re);
          if (!arg_p_p_re_t) {
            intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_re_bt = arg_p_p_re;
            intrusive_ptr<Eval_List<Value> > arg_p_p_le_elist = evaluate(arg_p_p_le_bt);
            intrusive_ptr<Eval_List<Value> > arg_p_p_re_elist = evaluate(arg_p_p_re_bt);
            for (typename Eval_List<Value>::iterator arg_p_p_le_elem_itr = arg_p_p_le_elist->begin(); arg_p_p_le_elem_itr != arg_p_p_le_elist->end(); ++ arg_p_p_le_elem_itr) {
              std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_le_elem = *arg_p_p_le_elem_itr;
              for (typename Eval_List<Value>::iterator arg_p_p_re_elem_itr = arg_p_p_re_elist->begin(); arg_p_p_re_elem_itr != arg_p_p_re_elist->end(); ++ arg_p_p_re_elem_itr) {
                std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_re_elem = *arg_p_p_re_elem_itr;
                std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret = cadd_Pr_Pr(arg_p_p_le_elem, arg_p_p_re_elem);
                push_back( answer, ret);
              }
            }
            erase( arg_p_p_le_elist);
            erase( arg_p_p_re_elist);
          } else 
          for (typename Backtrace_List<Value, pos_int>::iterator arg_p_p_re_bt_itr = arg_p_p_re_t->begin(); arg_p_p_re_bt_itr != arg_p_p_re_t->end(); ++ arg_p_p_re_bt_itr) {
            intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_re_bt = *arg_p_p_re_bt_itr;
            intrusive_ptr<Eval_List<Value> > arg_p_p_le_elist = evaluate(arg_p_p_le_bt);
            intrusive_ptr<Eval_List<Value> > arg_p_p_re_elist = evaluate(arg_p_p_re_bt);
            for (typename Eval_List<Value>::iterator arg_p_p_le_elem_itr = arg_p_p_le_elist->begin(); arg_p_p_le_elem_itr != arg_p_p_le_elist->end(); ++ arg_p_p_le_elem_itr) {
              std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_le_elem = *arg_p_p_le_elem_itr;
              for (typename Eval_List<Value>::iterator arg_p_p_re_elem_itr = arg_p_p_re_elist->begin(); arg_p_p_re_elem_itr != arg_p_p_re_elist->end(); ++ arg_p_p_re_elem_itr) {
                std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_re_elem = *arg_p_p_re_elem_itr;
                std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret = cadd_Pr_Pr(arg_p_p_le_elem, arg_p_p_re_elem);
                push_back( answer, ret);
              }
            }
            erase( arg_p_p_le_elist);
            erase( arg_p_p_re_elist);
          }
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_p_p_le_bt_itr = arg_p_p_le_t->begin(); arg_p_p_le_bt_itr != arg_p_p_le_t->end(); ++ arg_p_p_le_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_le_bt = *arg_p_p_le_bt_itr;
          intrusive_ptr<Backtrace_List<Value, pos_int> > arg_p_p_re_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_p_p_re);
          if (!arg_p_p_re_t) {
            intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_re_bt = arg_p_p_re;
            intrusive_ptr<Eval_List<Value> > arg_p_p_le_elist = evaluate(arg_p_p_le_bt);
            intrusive_ptr<Eval_List<Value> > arg_p_p_re_elist = evaluate(arg_p_p_re_bt);
            for (typename Eval_List<Value>::iterator arg_p_p_le_elem_itr = arg_p_p_le_elist->begin(); arg_p_p_le_elem_itr != arg_p_p_le_elist->end(); ++ arg_p_p_le_elem_itr) {
              std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_le_elem = *arg_p_p_le_elem_itr;
              for (typename Eval_List<Value>::iterator arg_p_p_re_elem_itr = arg_p_p_re_elist->begin(); arg_p_p_re_elem_itr != arg_p_p_re_elist->end(); ++ arg_p_p_re_elem_itr) {
                std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_re_elem = *arg_p_p_re_elem_itr;
                std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret = cadd_Pr_Pr(arg_p_p_le_elem, arg_p_p_re_elem);
                push_back( answer, ret);
              }
            }
            erase( arg_p_p_le_elist);
            erase( arg_p_p_re_elist);
          } else 
          for (typename Backtrace_List<Value, pos_int>::iterator arg_p_p_re_bt_itr = arg_p_p_re_t->begin(); arg_p_p_re_bt_itr != arg_p_p_re_t->end(); ++ arg_p_p_re_bt_itr) {
            intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_re_bt = *arg_p_p_re_bt_itr;
            intrusive_ptr<Eval_List<Value> > arg_p_p_le_elist = evaluate(arg_p_p_le_bt);
            intrusive_ptr<Eval_List<Value> > arg_p_p_re_elist = evaluate(arg_p_p_re_bt);
            for (typename Eval_List<Value>::iterator arg_p_p_le_elem_itr = arg_p_p_le_elist->begin(); arg_p_p_le_elem_itr != arg_p_p_le_elist->end(); ++ arg_p_p_le_elem_itr) {
              std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_le_elem = *arg_p_p_le_elem_itr;
              for (typename Eval_List<Value>::iterator arg_p_p_re_elem_itr = arg_p_p_re_elist->begin(); arg_p_p_re_elem_itr != arg_p_p_re_elist->end(); ++ arg_p_p_re_elem_itr) {
                std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_re_elem = *arg_p_p_re_elem_itr;
                std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret = cadd_Pr_Pr(arg_p_p_le_elem, arg_p_p_re_elem);
                push_back( answer, ret);
              }
            }
            erase( arg_p_p_le_elist);
            erase( arg_p_p_re_elist);
          }
        }
        erase( arg_p_p_le);
        erase( arg_p_p_re);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_cadd_Pr_Pr_Pr : Backtrace_Score<mfecovar_macrostate, Value, pos_int> {
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_le;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_re;

Backtrace_cadd_Pr_Pr_Pr(intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_le_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_re_)
 : arg_p_p_le(arg_p_p_le_), arg_p_p_re(arg_p_p_re_)
{}

~Backtrace_cadd_Pr_Pr_Pr()
{
erase(arg_p_p_le);
erase(arg_p_p_re);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      std::pair<String, shape_t>  cadd_Pr_Pr_Pr_l(const std::pair<String, shape_t> & p_le, const std::pair<String, shape_t> & p_re)
      {
        String l_0 = p_le.first;
        String l_1 = p_re.first;
        shape_t r_0 = p_le.second;
        shape_t r_1 = p_re.second;
        String ret_left = cadd_Pr_Pr_Pr_l_l(l_0, l_1);
        shape_t ret_right = cadd_Pr_Pr_Pr_l_r(r_0, r_1);
        std::pair<String, shape_t>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      String cadd_Pr_Pr_Pr_l_l(const String & le, const String & re)
      {
#line 215 ""
        String res;
        append( res, le);
        append( res, re);
        return res;
#line 3289 ""
      }


      shape_t cadd_Pr_Pr_Pr_l_r(shape_t le, shape_t re)
      {
#line 1007 ""
        return (le + re);
#line 3297 ""
      }


      answer_ali_pfunc_macrostate cadd_Pr_Pr_Pr_r(const answer_ali_pfunc_macrostate & le, const answer_ali_pfunc_macrostate & re)
      {
#line 1477 ""
        answer_ali_pfunc_macrostate res;
        res.firststem = le.firststem;
        res.pf = mk_tuple(le.firststem, (le.pf.q1 * sum_elems(re.pf)));
        return res;
#line 3308 ""
      }


      std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  cadd_Pr_Pr_Pr(const std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate> & p_p_le, const std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate> & p_p_re)
      {
        std::pair<String, shape_t>  l_0 = p_p_le.first;
        std::pair<String, shape_t>  l_1 = p_p_re.first;
        answer_ali_pfunc_macrostate r_0 = p_p_le.second;
        answer_ali_pfunc_macrostate r_1 = p_p_re.second;
        std::pair<String, shape_t>  ret_left = cadd_Pr_Pr_Pr_l(l_0, l_1);
        answer_ali_pfunc_macrostate ret_right = cadd_Pr_Pr_Pr_r(r_0, r_1);
        std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_p_p_le_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_p_p_le);
        if (!arg_p_p_le_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_le_bt = arg_p_p_le;
          intrusive_ptr<Backtrace_List<Value, pos_int> > arg_p_p_re_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_p_p_re);
          if (!arg_p_p_re_t) {
            intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_re_bt = arg_p_p_re;
            intrusive_ptr<Eval_List<Value> > arg_p_p_le_elist = evaluate(arg_p_p_le_bt);
            intrusive_ptr<Eval_List<Value> > arg_p_p_re_elist = evaluate(arg_p_p_re_bt);
            for (typename Eval_List<Value>::iterator arg_p_p_le_elem_itr = arg_p_p_le_elist->begin(); arg_p_p_le_elem_itr != arg_p_p_le_elist->end(); ++ arg_p_p_le_elem_itr) {
              std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_le_elem = *arg_p_p_le_elem_itr;
              for (typename Eval_List<Value>::iterator arg_p_p_re_elem_itr = arg_p_p_re_elist->begin(); arg_p_p_re_elem_itr != arg_p_p_re_elist->end(); ++ arg_p_p_re_elem_itr) {
                std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_re_elem = *arg_p_p_re_elem_itr;
                std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret = cadd_Pr_Pr_Pr(arg_p_p_le_elem, arg_p_p_re_elem);
                push_back( answer, ret);
              }
            }
            erase( arg_p_p_le_elist);
            erase( arg_p_p_re_elist);
          } else 
          for (typename Backtrace_List<Value, pos_int>::iterator arg_p_p_re_bt_itr = arg_p_p_re_t->begin(); arg_p_p_re_bt_itr != arg_p_p_re_t->end(); ++ arg_p_p_re_bt_itr) {
            intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_re_bt = *arg_p_p_re_bt_itr;
            intrusive_ptr<Eval_List<Value> > arg_p_p_le_elist = evaluate(arg_p_p_le_bt);
            intrusive_ptr<Eval_List<Value> > arg_p_p_re_elist = evaluate(arg_p_p_re_bt);
            for (typename Eval_List<Value>::iterator arg_p_p_le_elem_itr = arg_p_p_le_elist->begin(); arg_p_p_le_elem_itr != arg_p_p_le_elist->end(); ++ arg_p_p_le_elem_itr) {
              std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_le_elem = *arg_p_p_le_elem_itr;
              for (typename Eval_List<Value>::iterator arg_p_p_re_elem_itr = arg_p_p_re_elist->begin(); arg_p_p_re_elem_itr != arg_p_p_re_elist->end(); ++ arg_p_p_re_elem_itr) {
                std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_re_elem = *arg_p_p_re_elem_itr;
                std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret = cadd_Pr_Pr_Pr(arg_p_p_le_elem, arg_p_p_re_elem);
                push_back( answer, ret);
              }
            }
            erase( arg_p_p_le_elist);
            erase( arg_p_p_re_elist);
          }
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_p_p_le_bt_itr = arg_p_p_le_t->begin(); arg_p_p_le_bt_itr != arg_p_p_le_t->end(); ++ arg_p_p_le_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_le_bt = *arg_p_p_le_bt_itr;
          intrusive_ptr<Backtrace_List<Value, pos_int> > arg_p_p_re_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_p_p_re);
          if (!arg_p_p_re_t) {
            intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_re_bt = arg_p_p_re;
            intrusive_ptr<Eval_List<Value> > arg_p_p_le_elist = evaluate(arg_p_p_le_bt);
            intrusive_ptr<Eval_List<Value> > arg_p_p_re_elist = evaluate(arg_p_p_re_bt);
            for (typename Eval_List<Value>::iterator arg_p_p_le_elem_itr = arg_p_p_le_elist->begin(); arg_p_p_le_elem_itr != arg_p_p_le_elist->end(); ++ arg_p_p_le_elem_itr) {
              std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_le_elem = *arg_p_p_le_elem_itr;
              for (typename Eval_List<Value>::iterator arg_p_p_re_elem_itr = arg_p_p_re_elist->begin(); arg_p_p_re_elem_itr != arg_p_p_re_elist->end(); ++ arg_p_p_re_elem_itr) {
                std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_re_elem = *arg_p_p_re_elem_itr;
                std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret = cadd_Pr_Pr_Pr(arg_p_p_le_elem, arg_p_p_re_elem);
                push_back( answer, ret);
              }
            }
            erase( arg_p_p_le_elist);
            erase( arg_p_p_re_elist);
          } else 
          for (typename Backtrace_List<Value, pos_int>::iterator arg_p_p_re_bt_itr = arg_p_p_re_t->begin(); arg_p_p_re_bt_itr != arg_p_p_re_t->end(); ++ arg_p_p_re_bt_itr) {
            intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_re_bt = *arg_p_p_re_bt_itr;
            intrusive_ptr<Eval_List<Value> > arg_p_p_le_elist = evaluate(arg_p_p_le_bt);
            intrusive_ptr<Eval_List<Value> > arg_p_p_re_elist = evaluate(arg_p_p_re_bt);
            for (typename Eval_List<Value>::iterator arg_p_p_le_elem_itr = arg_p_p_le_elist->begin(); arg_p_p_le_elem_itr != arg_p_p_le_elist->end(); ++ arg_p_p_le_elem_itr) {
              std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_le_elem = *arg_p_p_le_elem_itr;
              for (typename Eval_List<Value>::iterator arg_p_p_re_elem_itr = arg_p_p_re_elist->begin(); arg_p_p_re_elem_itr != arg_p_p_re_elist->end(); ++ arg_p_p_re_elem_itr) {
                std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_re_elem = *arg_p_p_re_elem_itr;
                std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret = cadd_Pr_Pr_Pr(arg_p_p_le_elem, arg_p_p_re_elem);
                push_back( answer, ret);
              }
            }
            erase( arg_p_p_le_elist);
            erase( arg_p_p_re_elist);
          }
        }
        erase( arg_p_p_le);
        erase( arg_p_p_re);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_combine : Backtrace_Score<mfecovar_macrostate, Value, pos_int> {
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_le;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_re;

Backtrace_combine(intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_le_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_re_)
 : arg_p_p_le(arg_p_p_le_), arg_p_p_re(arg_p_p_re_)
{}

~Backtrace_combine()
{
erase(arg_p_p_le);
erase(arg_p_p_re);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      std::pair<String, shape_t>  combine_l(const std::pair<String, shape_t> & p_le, const std::pair<String, shape_t> & p_re)
      {
        String l_0 = p_le.first;
        String l_1 = p_re.first;
        shape_t r_0 = p_le.second;
        shape_t r_1 = p_re.second;
        String ret_left = combine_l_l(l_0, l_1);
        shape_t ret_right = combine_l_r(r_0, r_1);
        std::pair<String, shape_t>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      String combine_l_l(const String & le, const String & re)
      {
#line 297 ""
        String res;
        append( res, le);
        append( res, re);
        return res;
#line 3446 ""
      }


      shape_t combine_l_r(shape_t le, shape_t re)
      {
#line 1081 ""
        if ((( ( (shapelevel() == 1) )  &&  ( (back(le) == '_') ) ) &&  ( (front(re) == '_') ) ))
          {
            return (le + tail(re));
          }

        else
          {
            return (le + re);
          }

#line 3463 ""
      }


      answer_ali_pfunc_macrostate combine_r(const answer_ali_pfunc_macrostate & le, const answer_ali_pfunc_macrostate & re)
      {
#line 1935 ""
        answer_ali_pfunc_macrostate res;
        res.firststem = le.firststem;
        res.pf.q1 = ( ( (le.pf.q1 + le.pf.q2) )  *  ( (re.pf.q1 + re.pf.q3) ) );
        res.pf.q2 = ( ( (le.pf.q1 + le.pf.q2) )  *  ( (re.pf.q2 + re.pf.q4) ) );
        res.pf.q3 = ( ( (le.pf.q3 + le.pf.q4) )  *  ( (re.pf.q3 + re.pf.q1) ) );
        res.pf.q4 = ( ( (le.pf.q4 + le.pf.q3) )  *  ( (re.pf.q4 + re.pf.q2) ) );
        return res;
#line 3477 ""
      }


      std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  combine(const std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate> & p_p_le, const std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate> & p_p_re)
      {
        std::pair<String, shape_t>  l_0 = p_p_le.first;
        std::pair<String, shape_t>  l_1 = p_p_re.first;
        answer_ali_pfunc_macrostate r_0 = p_p_le.second;
        answer_ali_pfunc_macrostate r_1 = p_p_re.second;
        std::pair<String, shape_t>  ret_left = combine_l(l_0, l_1);
        answer_ali_pfunc_macrostate ret_right = combine_r(r_0, r_1);
        std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_p_p_le_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_p_p_le);
        if (!arg_p_p_le_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_le_bt = arg_p_p_le;
          intrusive_ptr<Backtrace_List<Value, pos_int> > arg_p_p_re_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_p_p_re);
          if (!arg_p_p_re_t) {
            intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_re_bt = arg_p_p_re;
            intrusive_ptr<Eval_List<Value> > arg_p_p_le_elist = evaluate(arg_p_p_le_bt);
            intrusive_ptr<Eval_List<Value> > arg_p_p_re_elist = evaluate(arg_p_p_re_bt);
            for (typename Eval_List<Value>::iterator arg_p_p_le_elem_itr = arg_p_p_le_elist->begin(); arg_p_p_le_elem_itr != arg_p_p_le_elist->end(); ++ arg_p_p_le_elem_itr) {
              std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_le_elem = *arg_p_p_le_elem_itr;
              for (typename Eval_List<Value>::iterator arg_p_p_re_elem_itr = arg_p_p_re_elist->begin(); arg_p_p_re_elem_itr != arg_p_p_re_elist->end(); ++ arg_p_p_re_elem_itr) {
                std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_re_elem = *arg_p_p_re_elem_itr;
                std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret = combine(arg_p_p_le_elem, arg_p_p_re_elem);
                push_back( answer, ret);
              }
            }
            erase( arg_p_p_le_elist);
            erase( arg_p_p_re_elist);
          } else 
          for (typename Backtrace_List<Value, pos_int>::iterator arg_p_p_re_bt_itr = arg_p_p_re_t->begin(); arg_p_p_re_bt_itr != arg_p_p_re_t->end(); ++ arg_p_p_re_bt_itr) {
            intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_re_bt = *arg_p_p_re_bt_itr;
            intrusive_ptr<Eval_List<Value> > arg_p_p_le_elist = evaluate(arg_p_p_le_bt);
            intrusive_ptr<Eval_List<Value> > arg_p_p_re_elist = evaluate(arg_p_p_re_bt);
            for (typename Eval_List<Value>::iterator arg_p_p_le_elem_itr = arg_p_p_le_elist->begin(); arg_p_p_le_elem_itr != arg_p_p_le_elist->end(); ++ arg_p_p_le_elem_itr) {
              std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_le_elem = *arg_p_p_le_elem_itr;
              for (typename Eval_List<Value>::iterator arg_p_p_re_elem_itr = arg_p_p_re_elist->begin(); arg_p_p_re_elem_itr != arg_p_p_re_elist->end(); ++ arg_p_p_re_elem_itr) {
                std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_re_elem = *arg_p_p_re_elem_itr;
                std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret = combine(arg_p_p_le_elem, arg_p_p_re_elem);
                push_back( answer, ret);
              }
            }
            erase( arg_p_p_le_elist);
            erase( arg_p_p_re_elist);
          }
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_p_p_le_bt_itr = arg_p_p_le_t->begin(); arg_p_p_le_bt_itr != arg_p_p_le_t->end(); ++ arg_p_p_le_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_le_bt = *arg_p_p_le_bt_itr;
          intrusive_ptr<Backtrace_List<Value, pos_int> > arg_p_p_re_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_p_p_re);
          if (!arg_p_p_re_t) {
            intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_re_bt = arg_p_p_re;
            intrusive_ptr<Eval_List<Value> > arg_p_p_le_elist = evaluate(arg_p_p_le_bt);
            intrusive_ptr<Eval_List<Value> > arg_p_p_re_elist = evaluate(arg_p_p_re_bt);
            for (typename Eval_List<Value>::iterator arg_p_p_le_elem_itr = arg_p_p_le_elist->begin(); arg_p_p_le_elem_itr != arg_p_p_le_elist->end(); ++ arg_p_p_le_elem_itr) {
              std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_le_elem = *arg_p_p_le_elem_itr;
              for (typename Eval_List<Value>::iterator arg_p_p_re_elem_itr = arg_p_p_re_elist->begin(); arg_p_p_re_elem_itr != arg_p_p_re_elist->end(); ++ arg_p_p_re_elem_itr) {
                std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_re_elem = *arg_p_p_re_elem_itr;
                std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret = combine(arg_p_p_le_elem, arg_p_p_re_elem);
                push_back( answer, ret);
              }
            }
            erase( arg_p_p_le_elist);
            erase( arg_p_p_re_elist);
          } else 
          for (typename Backtrace_List<Value, pos_int>::iterator arg_p_p_re_bt_itr = arg_p_p_re_t->begin(); arg_p_p_re_bt_itr != arg_p_p_re_t->end(); ++ arg_p_p_re_bt_itr) {
            intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_re_bt = *arg_p_p_re_bt_itr;
            intrusive_ptr<Eval_List<Value> > arg_p_p_le_elist = evaluate(arg_p_p_le_bt);
            intrusive_ptr<Eval_List<Value> > arg_p_p_re_elist = evaluate(arg_p_p_re_bt);
            for (typename Eval_List<Value>::iterator arg_p_p_le_elem_itr = arg_p_p_le_elist->begin(); arg_p_p_le_elem_itr != arg_p_p_le_elist->end(); ++ arg_p_p_le_elem_itr) {
              std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_le_elem = *arg_p_p_le_elem_itr;
              for (typename Eval_List<Value>::iterator arg_p_p_re_elem_itr = arg_p_p_re_elist->begin(); arg_p_p_re_elem_itr != arg_p_p_re_elist->end(); ++ arg_p_p_re_elem_itr) {
                std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_re_elem = *arg_p_p_re_elem_itr;
                std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret = combine(arg_p_p_le_elem, arg_p_p_re_elem);
                push_back( answer, ret);
              }
            }
            erase( arg_p_p_le_elist);
            erase( arg_p_p_re_elist);
          }
        }
        erase( arg_p_p_le);
        erase( arg_p_p_re);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_drem : Backtrace_Score<mfecovar_macrostate, Value, pos_int> {
      TUSubsequence arg_p_p_lloc;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e;
      TUSubsequence arg_p_p_rloc;

Backtrace_drem(TUSubsequence arg_p_p_lloc_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_, TUSubsequence arg_p_p_rloc_)
 : arg_p_p_lloc(arg_p_p_lloc_), arg_p_p_e(arg_p_p_e_), arg_p_p_rloc(arg_p_p_rloc_)
{}

~Backtrace_drem()
{
erase(arg_p_p_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      std::pair<String, shape_t>  drem_l(const TUSubsequence & p_lloc, const std::pair<String, shape_t> & p_e, const TUSubsequence & p_rloc)
      {
        TUSubsequence l_0 = p_lloc;
        String l_1 = p_e.first;
        TUSubsequence l_2 = p_rloc;
        TUSubsequence r_0 = p_lloc;
        shape_t r_1 = p_e.second;
        TUSubsequence r_2 = p_rloc;
        String ret_left = drem_l_l(l_0, l_1, l_2);
        shape_t ret_right = drem_l_r(r_0, r_1, r_2);
        std::pair<String, shape_t>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      String drem_l_l(const TUSubsequence & lloc, const String & e, const TUSubsequence & rloc)
      {
#line 100 ""
        return e;
#line 3614 ""
      }


      shape_t drem_l_r(const TUSubsequence & lloc, shape_t e, const TUSubsequence & rloc)
      {
#line 889 ""
        return e;
#line 3622 ""
      }


      answer_ali_pfunc_macrostate drem_r(const TUSubsequence & lloc, const answer_ali_pfunc_macrostate & e, const TUSubsequence & rloc)
      {
#line 1564 ""
        answer_ali_pfunc_macrostate res;
        res.firststem = e.firststem;
        res.pf.q1 = (e.pf.q1 * mk_pf((int(termau_energy(e.firststem, e.firststem)) / float(rows(lloc)))));
        res.pf.q2 = 0.000000e+00;
        res.pf.q3 = 0.000000e+00;
        res.pf.q4 = 0.000000e+00;
        return res;
#line 3636 ""
      }


      std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  drem(const TUSubsequence & p_p_lloc, const std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate> & p_p_e, const TUSubsequence & p_p_rloc)
      {
        TUSubsequence l_0 = p_p_lloc;
        std::pair<String, shape_t>  l_1 = p_p_e.first;
        TUSubsequence l_2 = p_p_rloc;
        TUSubsequence r_0 = p_p_lloc;
        answer_ali_pfunc_macrostate r_1 = p_p_e.second;
        TUSubsequence r_2 = p_p_rloc;
        std::pair<String, shape_t>  ret_left = drem_l(l_0, l_1, l_2);
        answer_ali_pfunc_macrostate ret_right = drem_r(r_0, r_1, r_2);
        std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_p_p_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_p_p_e);
        if (!arg_p_p_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_bt = arg_p_p_e;
          intrusive_ptr<Eval_List<Value> > arg_p_p_e_elist = evaluate(arg_p_p_e_bt);
          for (typename Eval_List<Value>::iterator arg_p_p_e_elem_itr = arg_p_p_e_elist->begin(); arg_p_p_e_elem_itr != arg_p_p_e_elist->end(); ++ arg_p_p_e_elem_itr) {
            std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_e_elem = *arg_p_p_e_elem_itr;
            std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret = drem(arg_p_p_lloc, arg_p_p_e_elem, arg_p_p_rloc);
            push_back( answer, ret);
          }
          erase( arg_p_p_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_p_p_e_bt_itr = arg_p_p_e_t->begin(); arg_p_p_e_bt_itr != arg_p_p_e_t->end(); ++ arg_p_p_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_bt = *arg_p_p_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_p_p_e_elist = evaluate(arg_p_p_e_bt);
          for (typename Eval_List<Value>::iterator arg_p_p_e_elem_itr = arg_p_p_e_elist->begin(); arg_p_p_e_elem_itr != arg_p_p_e_elist->end(); ++ arg_p_p_e_elem_itr) {
            std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_e_elem = *arg_p_p_e_elem_itr;
            std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret = drem(arg_p_p_lloc, arg_p_p_e_elem, arg_p_p_rloc);
            push_back( answer, ret);
          }
          erase( arg_p_p_e_elist);
        }
        erase( arg_p_p_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_edl : Backtrace_Score<mfecovar_macrostate, Value, pos_int> {
      TUSubsequence arg_p_p_lb;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e;
      TUSubsequence arg_p_p_loc;

Backtrace_edl(TUSubsequence arg_p_p_lb_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_, TUSubsequence arg_p_p_loc_)
 : arg_p_p_lb(arg_p_p_lb_), arg_p_p_e(arg_p_p_e_), arg_p_p_loc(arg_p_p_loc_)
{}

~Backtrace_edl()
{
erase(arg_p_p_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      std::pair<String, shape_t>  edl_l(const TUSubsequence & p_lb, const std::pair<String, shape_t> & p_e, const TUSubsequence & p_loc)
      {
        TUSubsequence l_0 = p_lb;
        String l_1 = p_e.first;
        TUSubsequence l_2 = p_loc;
        TUSubsequence r_0 = p_lb;
        shape_t r_1 = p_e.second;
        TUSubsequence r_2 = p_loc;
        String ret_left = edl_l_l(l_0, l_1, l_2);
        shape_t ret_right = edl_l_r(r_0, r_1, r_2);
        std::pair<String, shape_t>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      String edl_l_l(const TUSubsequence & lb, const String & e, const TUSubsequence & loc)
      {
#line 78 ""
        String res;
        append( res, '.');
        append( res, e);
        return res;
#line 3729 ""
      }


      shape_t edl_l_r(const TUSubsequence & lb, shape_t e, const TUSubsequence & rloc)
      {
#line 865 ""
        if ((shapelevel() == 1))
          {
            return (shape_t('_') + e);
          }

        else
          {
            return e;
          }

#line 3746 ""
      }


      answer_ali_pfunc_macrostate edl_r(const TUSubsequence & lb, const answer_ali_pfunc_macrostate & e, const TUSubsequence & rloc)
      {
#line 1523 ""
        answer_ali_pfunc_macrostate res;
        res.firststem = e.firststem;
        res.pf.q1 = ((scale(1) * e.pf.q1) * mk_pf(int(( ( (dl_energy(e.firststem, e.firststem) + termau_energy(e.firststem, e.firststem)) )  / float(rows(lb))))));
        res.pf.q2 = 0.000000e+00;
        res.pf.q3 = 0.000000e+00;
        res.pf.q4 = 0.000000e+00;
        return res;
#line 3760 ""
      }


      std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  edl(const TUSubsequence & p_p_lb, const std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate> & p_p_e, const TUSubsequence & p_p_loc)
      {
        TUSubsequence l_0 = p_p_lb;
        std::pair<String, shape_t>  l_1 = p_p_e.first;
        TUSubsequence l_2 = p_p_loc;
        TUSubsequence r_0 = p_p_lb;
        answer_ali_pfunc_macrostate r_1 = p_p_e.second;
        TUSubsequence r_2 = p_p_loc;
        std::pair<String, shape_t>  ret_left = edl_l(l_0, l_1, l_2);
        answer_ali_pfunc_macrostate ret_right = edl_r(r_0, r_1, r_2);
        std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_p_p_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_p_p_e);
        if (!arg_p_p_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_bt = arg_p_p_e;
          intrusive_ptr<Eval_List<Value> > arg_p_p_e_elist = evaluate(arg_p_p_e_bt);
          for (typename Eval_List<Value>::iterator arg_p_p_e_elem_itr = arg_p_p_e_elist->begin(); arg_p_p_e_elem_itr != arg_p_p_e_elist->end(); ++ arg_p_p_e_elem_itr) {
            std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_e_elem = *arg_p_p_e_elem_itr;
            std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret = edl(arg_p_p_lb, arg_p_p_e_elem, arg_p_p_loc);
            push_back( answer, ret);
          }
          erase( arg_p_p_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_p_p_e_bt_itr = arg_p_p_e_t->begin(); arg_p_p_e_bt_itr != arg_p_p_e_t->end(); ++ arg_p_p_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_bt = *arg_p_p_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_p_p_e_elist = evaluate(arg_p_p_e_bt);
          for (typename Eval_List<Value>::iterator arg_p_p_e_elem_itr = arg_p_p_e_elist->begin(); arg_p_p_e_elem_itr != arg_p_p_e_elist->end(); ++ arg_p_p_e_elem_itr) {
            std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_e_elem = *arg_p_p_e_elem_itr;
            std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret = edl(arg_p_p_lb, arg_p_p_e_elem, arg_p_p_loc);
            push_back( answer, ret);
          }
          erase( arg_p_p_e_elist);
        }
        erase( arg_p_p_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_edlr : Backtrace_Score<mfecovar_macrostate, Value, pos_int> {
      TUSubsequence arg_p_p_lb;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e;
      TUSubsequence arg_p_p_rb;

Backtrace_edlr(TUSubsequence arg_p_p_lb_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_, TUSubsequence arg_p_p_rb_)
 : arg_p_p_lb(arg_p_p_lb_), arg_p_p_e(arg_p_p_e_), arg_p_p_rb(arg_p_p_rb_)
{}

~Backtrace_edlr()
{
erase(arg_p_p_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      std::pair<String, shape_t>  edlr_l(const TUSubsequence & p_lb, const std::pair<String, shape_t> & p_e, const TUSubsequence & p_rb)
      {
        TUSubsequence l_0 = p_lb;
        String l_1 = p_e.first;
        TUSubsequence l_2 = p_rb;
        TUSubsequence r_0 = p_lb;
        shape_t r_1 = p_e.second;
        TUSubsequence r_2 = p_rb;
        String ret_left = edlr_l_l(l_0, l_1, l_2);
        shape_t ret_right = edlr_l_r(r_0, r_1, r_2);
        std::pair<String, shape_t>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      String edlr_l_l(const TUSubsequence & lb, const String & e, const TUSubsequence & rb)
      {
#line 92 ""
        String res;
        append( res, '.');
        append( res, e);
        append( res, '.');
        return res;
#line 3854 ""
      }


      shape_t edlr_l_r(const TUSubsequence & lb, shape_t e, const TUSubsequence & rb)
      {
#line 881 ""
        if ((shapelevel() == 1))
          {
            return ((shape_t('_') + e) + shape_t('_'));
          }

        else
          {
            return e;
          }

#line 3871 ""
      }


      answer_ali_pfunc_macrostate edlr_r(const TUSubsequence & lb, const answer_ali_pfunc_macrostate & e, const TUSubsequence & rb)
      {
#line 1549 ""
        answer_ali_pfunc_macrostate res;
        int help = min(min(ext_mismatch_energy(e.firststem, e.firststem), dl_energy(e.firststem, e.firststem)), dr_energy(e.firststem, e.firststem));
        res.firststem = e.firststem;
        res.pf.q1 = ((scale(2) * e.pf.q1) * mk_pf(int(( ( (help + termau_energy(e.firststem, e.firststem)) )  / float(rows(lb))))));
        res.pf.q2 = 0.000000e+00;
        res.pf.q3 = 0.000000e+00;
        res.pf.q4 = 0.000000e+00;
        return res;
#line 3886 ""
      }


      std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  edlr(const TUSubsequence & p_p_lb, const std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate> & p_p_e, const TUSubsequence & p_p_rb)
      {
        TUSubsequence l_0 = p_p_lb;
        std::pair<String, shape_t>  l_1 = p_p_e.first;
        TUSubsequence l_2 = p_p_rb;
        TUSubsequence r_0 = p_p_lb;
        answer_ali_pfunc_macrostate r_1 = p_p_e.second;
        TUSubsequence r_2 = p_p_rb;
        std::pair<String, shape_t>  ret_left = edlr_l(l_0, l_1, l_2);
        answer_ali_pfunc_macrostate ret_right = edlr_r(r_0, r_1, r_2);
        std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_p_p_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_p_p_e);
        if (!arg_p_p_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_bt = arg_p_p_e;
          intrusive_ptr<Eval_List<Value> > arg_p_p_e_elist = evaluate(arg_p_p_e_bt);
          for (typename Eval_List<Value>::iterator arg_p_p_e_elem_itr = arg_p_p_e_elist->begin(); arg_p_p_e_elem_itr != arg_p_p_e_elist->end(); ++ arg_p_p_e_elem_itr) {
            std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_e_elem = *arg_p_p_e_elem_itr;
            std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret = edlr(arg_p_p_lb, arg_p_p_e_elem, arg_p_p_rb);
            push_back( answer, ret);
          }
          erase( arg_p_p_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_p_p_e_bt_itr = arg_p_p_e_t->begin(); arg_p_p_e_bt_itr != arg_p_p_e_t->end(); ++ arg_p_p_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_bt = *arg_p_p_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_p_p_e_elist = evaluate(arg_p_p_e_bt);
          for (typename Eval_List<Value>::iterator arg_p_p_e_elem_itr = arg_p_p_e_elist->begin(); arg_p_p_e_elem_itr != arg_p_p_e_elist->end(); ++ arg_p_p_e_elem_itr) {
            std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_e_elem = *arg_p_p_e_elem_itr;
            std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret = edlr(arg_p_p_lb, arg_p_p_e_elem, arg_p_p_rb);
            push_back( answer, ret);
          }
          erase( arg_p_p_e_elist);
        }
        erase( arg_p_p_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_edr : Backtrace_Score<mfecovar_macrostate, Value, pos_int> {
      TUSubsequence arg_p_p_loc;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e;
      TUSubsequence arg_p_p_rb;

Backtrace_edr(TUSubsequence arg_p_p_loc_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_, TUSubsequence arg_p_p_rb_)
 : arg_p_p_loc(arg_p_p_loc_), arg_p_p_e(arg_p_p_e_), arg_p_p_rb(arg_p_p_rb_)
{}

~Backtrace_edr()
{
erase(arg_p_p_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      std::pair<String, shape_t>  edr_l(const TUSubsequence & p_loc, const std::pair<String, shape_t> & p_e, const TUSubsequence & p_rb)
      {
        TUSubsequence l_0 = p_loc;
        String l_1 = p_e.first;
        TUSubsequence l_2 = p_rb;
        TUSubsequence r_0 = p_loc;
        shape_t r_1 = p_e.second;
        TUSubsequence r_2 = p_rb;
        String ret_left = edr_l_l(l_0, l_1, l_2);
        shape_t ret_right = edr_l_r(r_0, r_1, r_2);
        std::pair<String, shape_t>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      String edr_l_l(const TUSubsequence & loc, const String & e, const TUSubsequence & rb)
      {
#line 85 ""
        String res;
        append( res, e);
        append( res, '.');
        return res;
#line 3979 ""
      }


      shape_t edr_l_r(const TUSubsequence & lloc, shape_t e, const TUSubsequence & rb)
      {
#line 873 ""
        if ((shapelevel() == 1))
          {
            return (e + shape_t('_'));
          }

        else
          {
            return e;
          }

#line 3996 ""
      }


      answer_ali_pfunc_macrostate edr_r(const TUSubsequence & lloc, const answer_ali_pfunc_macrostate & e, const TUSubsequence & rb)
      {
#line 1536 ""
        answer_ali_pfunc_macrostate res;
        res.firststem = e.firststem;
        res.pf.q1 = ((scale(1) * e.pf.q1) * mk_pf(int(( ( (dr_energy(e.firststem, e.firststem) + termau_energy(e.firststem, e.firststem)) )  / float(rows(rb))))));
        res.pf.q2 = 0.000000e+00;
        res.pf.q3 = 0.000000e+00;
        res.pf.q4 = 0.000000e+00;
        return res;
#line 4010 ""
      }


      std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  edr(const TUSubsequence & p_p_loc, const std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate> & p_p_e, const TUSubsequence & p_p_rb)
      {
        TUSubsequence l_0 = p_p_loc;
        std::pair<String, shape_t>  l_1 = p_p_e.first;
        TUSubsequence l_2 = p_p_rb;
        TUSubsequence r_0 = p_p_loc;
        answer_ali_pfunc_macrostate r_1 = p_p_e.second;
        TUSubsequence r_2 = p_p_rb;
        std::pair<String, shape_t>  ret_left = edr_l(l_0, l_1, l_2);
        answer_ali_pfunc_macrostate ret_right = edr_r(r_0, r_1, r_2);
        std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_p_p_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_p_p_e);
        if (!arg_p_p_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_bt = arg_p_p_e;
          intrusive_ptr<Eval_List<Value> > arg_p_p_e_elist = evaluate(arg_p_p_e_bt);
          for (typename Eval_List<Value>::iterator arg_p_p_e_elem_itr = arg_p_p_e_elist->begin(); arg_p_p_e_elem_itr != arg_p_p_e_elist->end(); ++ arg_p_p_e_elem_itr) {
            std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_e_elem = *arg_p_p_e_elem_itr;
            std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret = edr(arg_p_p_loc, arg_p_p_e_elem, arg_p_p_rb);
            push_back( answer, ret);
          }
          erase( arg_p_p_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_p_p_e_bt_itr = arg_p_p_e_t->begin(); arg_p_p_e_bt_itr != arg_p_p_e_t->end(); ++ arg_p_p_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_bt = *arg_p_p_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_p_p_e_elist = evaluate(arg_p_p_e_bt);
          for (typename Eval_List<Value>::iterator arg_p_p_e_elem_itr = arg_p_p_e_elist->begin(); arg_p_p_e_elem_itr != arg_p_p_e_elist->end(); ++ arg_p_p_e_elem_itr) {
            std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_e_elem = *arg_p_p_e_elem_itr;
            std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret = edr(arg_p_p_loc, arg_p_p_e_elem, arg_p_p_rb);
            push_back( answer, ret);
          }
          erase( arg_p_p_e_elist);
        }
        erase( arg_p_p_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_hl : Backtrace_Score<mfecovar_macrostate, Value, pos_int> {
      TUSubsequence arg_p_p_lb;
      TUSubsequence arg_p_p_region;
      TUSubsequence arg_p_p_rb;

Backtrace_hl(TUSubsequence arg_p_p_lb_, TUSubsequence arg_p_p_region_, TUSubsequence arg_p_p_rb_)
 : arg_p_p_lb(arg_p_p_lb_), arg_p_p_region(arg_p_p_region_), arg_p_p_rb(arg_p_p_rb_)
{}

~Backtrace_hl()
{
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      std::pair<String, shape_t>  hl_l(const TUSubsequence & p_lb, const TUSubsequence & p_region, const TUSubsequence & p_rb)
      {
        TUSubsequence l_0 = p_lb;
        TUSubsequence l_1 = p_region;
        TUSubsequence l_2 = p_rb;
        TUSubsequence r_0 = p_lb;
        TUSubsequence r_1 = p_region;
        TUSubsequence r_2 = p_rb;
        String ret_left = hl_l_l(l_0, l_1, l_2);
        shape_t ret_right = hl_l_r(r_0, r_1, r_2);
        std::pair<String, shape_t>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      String hl_l_l(const TUSubsequence & lb, const TUSubsequence & region, const TUSubsequence & rb)
      {
#line 112 ""
        String res;
        append( res, '(');
        append( res, '.', size(region));
        append( res, ')');
        return res;
#line 4103 ""
      }


      shape_t hl_l_r(const TUSubsequence & lb, const TUSubsequence & region, const TUSubsequence & rb)
      {
#line 897 ""
        return (openParen + closeParen);
#line 4111 ""
      }


      answer_ali_pfunc_macrostate hl_r(const TUSubsequence & lb, const TUSubsequence & region, const TUSubsequence & rb)
      {
#line 1592 ""
        answer_ali_pfunc_macrostate res;
        res.firststem.seq = lb.seq;
        res.firststem.i = lb.i;
        res.firststem.j = rb.j;
        res.pf.q1 = (scale(((region.j - region.i) + 2)) * mk_pf((int((hl_energy(region) / float(rows(region)))) + covscore(lb, lb.i, rb.i))));
        res.pf.q2 = 0.000000e+00;
        res.pf.q3 = 0.000000e+00;
        res.pf.q4 = 0.000000e+00;
        return res;
#line 4127 ""
      }


      std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  hl(const TUSubsequence & p_p_lb, const TUSubsequence & p_p_region, const TUSubsequence & p_p_rb)
      {
        TUSubsequence l_0 = p_p_lb;
        TUSubsequence l_1 = p_p_region;
        TUSubsequence l_2 = p_p_rb;
        TUSubsequence r_0 = p_p_lb;
        TUSubsequence r_1 = p_p_region;
        TUSubsequence r_2 = p_p_rb;
        std::pair<String, shape_t>  ret_left = hl_l(l_0, l_1, l_2);
        answer_ali_pfunc_macrostate ret_right = hl_r(r_0, r_1, r_2);
        std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret = hl(arg_p_p_lb, arg_p_p_region, arg_p_p_rb);
        push_back( answer, ret);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_il : Backtrace_Score<mfecovar_macrostate, Value, pos_int> {
      TUSubsequence arg_p_p_lb;
      TUSubsequence arg_p_p_lregion;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e;
      TUSubsequence arg_p_p_rregion;
      TUSubsequence arg_p_p_rb;

Backtrace_il(TUSubsequence arg_p_p_lb_, TUSubsequence arg_p_p_lregion_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_, TUSubsequence arg_p_p_rregion_, TUSubsequence arg_p_p_rb_)
 : arg_p_p_lb(arg_p_p_lb_), arg_p_p_lregion(arg_p_p_lregion_), arg_p_p_e(arg_p_p_e_), arg_p_p_rregion(arg_p_p_rregion_), arg_p_p_rb(arg_p_p_rb_)
{}

~Backtrace_il()
{
erase(arg_p_p_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      std::pair<String, shape_t>  il_l(const TUSubsequence & p_lb, const TUSubsequence & p_lregion, const std::pair<String, shape_t> & p_e, const TUSubsequence & p_rregion, const TUSubsequence & p_rb)
      {
        TUSubsequence l_0 = p_lb;
        TUSubsequence l_1 = p_lregion;
        String l_2 = p_e.first;
        TUSubsequence l_3 = p_rregion;
        TUSubsequence l_4 = p_rb;
        TUSubsequence r_0 = p_lb;
        TUSubsequence r_1 = p_lregion;
        shape_t r_2 = p_e.second;
        TUSubsequence r_3 = p_rregion;
        TUSubsequence r_4 = p_rb;
        String ret_left = il_l_l(l_0, l_1, l_2, l_3, l_4);
        shape_t ret_right = il_l_r(r_0, r_1, r_2, r_3, r_4);
        std::pair<String, shape_t>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      String il_l_l(const TUSubsequence & lb, const TUSubsequence & lregion, const String & e, const TUSubsequence & rregion, const TUSubsequence & rb)
      {
#line 139 ""
        String res;
        append( res, '(');
        append( res, '.', size(lregion));
        append( res, e);
        append( res, '.', size(rregion));
        append( res, ')');
        return res;
#line 4209 ""
      }


      shape_t il_l_r(const TUSubsequence & lb, const TUSubsequence & lregion, shape_t x, const TUSubsequence & rregion, const TUSubsequence & rb)
      {
#line 928 ""
        if ((shapelevel() <= 4))
        {
          shape_t res;
          append( res, openParen);
          if ((shapelevel() <= 2))
            {
              append( res, '_');
            }

          append( res, x);
          if ((shapelevel() <= 2))
            {
              append( res, '_');
            }

          append( res, closeParen);
          return res;
        }

        else
          {
            return x;
          }

#line 4240 ""
      }


      answer_ali_pfunc_macrostate il_r(const TUSubsequence & lb, const TUSubsequence & lregion, const answer_ali_pfunc_macrostate & e, const TUSubsequence & rregion, const TUSubsequence & rb)
      {
#line 1638 ""
        answer_ali_pfunc_macrostate res;
        res.firststem.i = lb.i;
        res.firststem.j = rb.j;
        res.firststem.seq = lb.seq;
        res.pf.q1 = ((scale((( ( (lregion.j - lregion.i) )  +  ( (rregion.j - rregion.i) ) ) + 2)) * e.pf.q1) * mk_pf((int((il_energy(lregion, rregion) / float(rows(lregion)))) + covscore(lb, lb.i, rb.i))));
        res.pf.q2 = 0.000000e+00;
        res.pf.q3 = 0.000000e+00;
        res.pf.q4 = 0.000000e+00;
        return res;
#line 4256 ""
      }


      std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  il(const TUSubsequence & p_p_lb, const TUSubsequence & p_p_lregion, const std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate> & p_p_e, const TUSubsequence & p_p_rregion, const TUSubsequence & p_p_rb)
      {
        TUSubsequence l_0 = p_p_lb;
        TUSubsequence l_1 = p_p_lregion;
        std::pair<String, shape_t>  l_2 = p_p_e.first;
        TUSubsequence l_3 = p_p_rregion;
        TUSubsequence l_4 = p_p_rb;
        TUSubsequence r_0 = p_p_lb;
        TUSubsequence r_1 = p_p_lregion;
        answer_ali_pfunc_macrostate r_2 = p_p_e.second;
        TUSubsequence r_3 = p_p_rregion;
        TUSubsequence r_4 = p_p_rb;
        std::pair<String, shape_t>  ret_left = il_l(l_0, l_1, l_2, l_3, l_4);
        answer_ali_pfunc_macrostate ret_right = il_r(r_0, r_1, r_2, r_3, r_4);
        std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_p_p_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_p_p_e);
        if (!arg_p_p_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_bt = arg_p_p_e;
          intrusive_ptr<Eval_List<Value> > arg_p_p_e_elist = evaluate(arg_p_p_e_bt);
          for (typename Eval_List<Value>::iterator arg_p_p_e_elem_itr = arg_p_p_e_elist->begin(); arg_p_p_e_elem_itr != arg_p_p_e_elist->end(); ++ arg_p_p_e_elem_itr) {
            std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_e_elem = *arg_p_p_e_elem_itr;
            std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret = il(arg_p_p_lb, arg_p_p_lregion, arg_p_p_e_elem, arg_p_p_rregion, arg_p_p_rb);
            push_back( answer, ret);
          }
          erase( arg_p_p_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_p_p_e_bt_itr = arg_p_p_e_t->begin(); arg_p_p_e_bt_itr != arg_p_p_e_t->end(); ++ arg_p_p_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_bt = *arg_p_p_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_p_p_e_elist = evaluate(arg_p_p_e_bt);
          for (typename Eval_List<Value>::iterator arg_p_p_e_elem_itr = arg_p_p_e_elist->begin(); arg_p_p_e_elem_itr != arg_p_p_e_elist->end(); ++ arg_p_p_e_elem_itr) {
            std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_e_elem = *arg_p_p_e_elem_itr;
            std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret = il(arg_p_p_lb, arg_p_p_lregion, arg_p_p_e_elem, arg_p_p_rregion, arg_p_p_rb);
            push_back( answer, ret);
          }
          erase( arg_p_p_e_elist);
        }
        erase( arg_p_p_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_incl : Backtrace_Score<mfecovar_macrostate, Value, pos_int> {
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e;

Backtrace_incl(intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_)
 : arg_p_p_e(arg_p_p_e_)
{}

~Backtrace_incl()
{
erase(arg_p_p_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      std::pair<String, shape_t>  incl_l(const std::pair<String, shape_t> & p_e)
      {
        String l_0 = p_e.first;
        shape_t r_0 = p_e.second;
        String ret_left = incl_l_l(l_0);
        shape_t ret_right = incl_l_r(r_0);
        std::pair<String, shape_t>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      String incl_l_l(const String & e)
      {
#line 192 ""
        return e;
#line 4344 ""
      }


      shape_t incl_l_r(shape_t e)
      {
#line 983 ""
        return e;
#line 4352 ""
      }


      answer_ali_pfunc_macrostate incl_r(const answer_ali_pfunc_macrostate & e)
      {
#line 1925 ""
        answer_ali_pfunc_macrostate res;
        res.firststem = e.firststem;
        res.pf = mk_tuple(e.firststem, (e.pf.q1 * mk_pf(ul_energy())));
        return res;
#line 4363 ""
      }


      std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  incl(const std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate> & p_p_e)
      {
        std::pair<String, shape_t>  l_0 = p_p_e.first;
        answer_ali_pfunc_macrostate r_0 = p_p_e.second;
        std::pair<String, shape_t>  ret_left = incl_l(l_0);
        answer_ali_pfunc_macrostate ret_right = incl_r(r_0);
        std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_p_p_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_p_p_e);
        if (!arg_p_p_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_bt = arg_p_p_e;
          intrusive_ptr<Eval_List<Value> > arg_p_p_e_elist = evaluate(arg_p_p_e_bt);
          for (typename Eval_List<Value>::iterator arg_p_p_e_elem_itr = arg_p_p_e_elist->begin(); arg_p_p_e_elem_itr != arg_p_p_e_elist->end(); ++ arg_p_p_e_elem_itr) {
            std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_e_elem = *arg_p_p_e_elem_itr;
            std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret = incl(arg_p_p_e_elem);
            push_back( answer, ret);
          }
          erase( arg_p_p_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_p_p_e_bt_itr = arg_p_p_e_t->begin(); arg_p_p_e_bt_itr != arg_p_p_e_t->end(); ++ arg_p_p_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_bt = *arg_p_p_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_p_p_e_elist = evaluate(arg_p_p_e_bt);
          for (typename Eval_List<Value>::iterator arg_p_p_e_elem_itr = arg_p_p_e_elist->begin(); arg_p_p_e_elem_itr != arg_p_p_e_elist->end(); ++ arg_p_p_e_elem_itr) {
            std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_e_elem = *arg_p_p_e_elem_itr;
            std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret = incl(arg_p_p_e_elem);
            push_back( answer, ret);
          }
          erase( arg_p_p_e_elist);
        }
        erase( arg_p_p_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_ml : Backtrace_Score<mfecovar_macrostate, Value, pos_int> {
      TUSubsequence arg_p_p_lb;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e;
      TUSubsequence arg_p_p_rb;

Backtrace_ml(TUSubsequence arg_p_p_lb_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_, TUSubsequence arg_p_p_rb_)
 : arg_p_p_lb(arg_p_p_lb_), arg_p_p_e(arg_p_p_e_), arg_p_p_rb(arg_p_p_rb_)
{}

~Backtrace_ml()
{
erase(arg_p_p_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      std::pair<String, shape_t>  ml_l(const TUSubsequence & p_lb, const std::pair<String, shape_t> & p_e, const TUSubsequence & p_rb)
      {
        TUSubsequence l_0 = p_lb;
        String l_1 = p_e.first;
        TUSubsequence l_2 = p_rb;
        TUSubsequence r_0 = p_lb;
        shape_t r_1 = p_e.second;
        TUSubsequence r_2 = p_rb;
        String ret_left = ml_l_l(l_0, l_1, l_2);
        shape_t ret_right = ml_l_r(r_0, r_1, r_2);
        std::pair<String, shape_t>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      String ml_l_l(const TUSubsequence & lb, const String & e, const TUSubsequence & rb)
      {
#line 149 ""
        String res;
        append( res, '(');
        append( res, e);
        append( res, ')');
        return res;
#line 4453 ""
      }


      shape_t ml_l_r(const TUSubsequence & lb, shape_t e, const TUSubsequence & rb)
      {
#line 942 ""
        return ((openParen + e) + closeParen);
#line 4461 ""
      }


      answer_ali_pfunc_macrostate ml_r(const TUSubsequence & lb, const answer_ali_pfunc_macrostate & e, const TUSubsequence & rb)
      {
#line 1653 ""
        answer_ali_pfunc_macrostate res;
        res.firststem.i = lb.i;
        res.firststem.j = rb.j;
        res.firststem.seq = lb.seq;
        res.pf.q1 = ((scale(2) * sum_elems(e.pf)) * mk_pf((((ml_energy() + ul_energy()) + int((termau_energy(res.firststem, res.firststem) / float(rows(lb))))) + covscore(lb, lb.i, rb.i))));
        res.pf.q2 = 0.000000e+00;
        res.pf.q3 = 0.000000e+00;
        res.pf.q4 = 0.000000e+00;
        return res;
#line 4477 ""
      }


      std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ml(const TUSubsequence & p_p_lb, const std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate> & p_p_e, const TUSubsequence & p_p_rb)
      {
        TUSubsequence l_0 = p_p_lb;
        std::pair<String, shape_t>  l_1 = p_p_e.first;
        TUSubsequence l_2 = p_p_rb;
        TUSubsequence r_0 = p_p_lb;
        answer_ali_pfunc_macrostate r_1 = p_p_e.second;
        TUSubsequence r_2 = p_p_rb;
        std::pair<String, shape_t>  ret_left = ml_l(l_0, l_1, l_2);
        answer_ali_pfunc_macrostate ret_right = ml_r(r_0, r_1, r_2);
        std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_p_p_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_p_p_e);
        if (!arg_p_p_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_bt = arg_p_p_e;
          intrusive_ptr<Eval_List<Value> > arg_p_p_e_elist = evaluate(arg_p_p_e_bt);
          for (typename Eval_List<Value>::iterator arg_p_p_e_elem_itr = arg_p_p_e_elist->begin(); arg_p_p_e_elem_itr != arg_p_p_e_elist->end(); ++ arg_p_p_e_elem_itr) {
            std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_e_elem = *arg_p_p_e_elem_itr;
            std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret = ml(arg_p_p_lb, arg_p_p_e_elem, arg_p_p_rb);
            push_back( answer, ret);
          }
          erase( arg_p_p_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_p_p_e_bt_itr = arg_p_p_e_t->begin(); arg_p_p_e_bt_itr != arg_p_p_e_t->end(); ++ arg_p_p_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_bt = *arg_p_p_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_p_p_e_elist = evaluate(arg_p_p_e_bt);
          for (typename Eval_List<Value>::iterator arg_p_p_e_elem_itr = arg_p_p_e_elist->begin(); arg_p_p_e_elem_itr != arg_p_p_e_elist->end(); ++ arg_p_p_e_elem_itr) {
            std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_e_elem = *arg_p_p_e_elem_itr;
            std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret = ml(arg_p_p_lb, arg_p_p_e_elem, arg_p_p_rb);
            push_back( answer, ret);
          }
          erase( arg_p_p_e_elist);
        }
        erase( arg_p_p_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_mladl : Backtrace_Score<mfecovar_macrostate, Value, pos_int> {
      TUSubsequence arg_p_p_lb;
      TUSubsequence arg_p_p_dl;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e;
      TUSubsequence arg_p_p_rb;

Backtrace_mladl(TUSubsequence arg_p_p_lb_, TUSubsequence arg_p_p_dl_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_, TUSubsequence arg_p_p_rb_)
 : arg_p_p_lb(arg_p_p_lb_), arg_p_p_dl(arg_p_p_dl_), arg_p_p_e(arg_p_p_e_), arg_p_p_rb(arg_p_p_rb_)
{}

~Backtrace_mladl()
{
erase(arg_p_p_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      std::pair<String, shape_t>  mladl_l(const TUSubsequence & p_lb, const TUSubsequence & p_dl, const std::pair<String, shape_t> & p_e, const TUSubsequence & p_rb)
      {
        TUSubsequence l_0 = p_lb;
        TUSubsequence l_1 = p_dl;
        String l_2 = p_e.first;
        TUSubsequence l_3 = p_rb;
        TUSubsequence r_0 = p_lb;
        TUSubsequence r_1 = p_dl;
        shape_t r_2 = p_e.second;
        TUSubsequence r_3 = p_rb;
        String ret_left = mladl_l_l(l_0, l_1, l_2, l_3);
        shape_t ret_right = mladl_l_r(r_0, r_1, r_2, r_3);
        std::pair<String, shape_t>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      String mladl_l_l(const TUSubsequence & lb, const TUSubsequence & dl, const String & e, const TUSubsequence & rb)
      {
#line 277 ""
        String res;
        append( res, '(');
        append( res, '.');
        append( res, e);
        append( res, ')');
        return res;
#line 4575 ""
      }


      shape_t mladl_l_r(const TUSubsequence & lb, const TUSubsequence & dl, shape_t e, const TUSubsequence & rb)
      {
#line 1064 ""
        shape_t res;
        append( res, '[');
        if ((shapelevel() == 1))
          {
            append( res, '_');
          }

        append( res, e);
        append( res, ']');
        return res;
#line 4592 ""
      }


      answer_ali_pfunc_macrostate mladl_r(const TUSubsequence & lb, const TUSubsequence & dl, const answer_ali_pfunc_macrostate & e, const TUSubsequence & rb)
      {
#line 1862 ""
        answer_ali_pfunc_macrostate res;
        res.firststem.i = lb.i;
        res.firststem.j = rb.j;
        res.firststem.seq = lb.seq;
        int dangleInternal_wc = 0.000000e+00;
        int dangleInternal_wob = 0.000000e+00;
        int dangleClosing = 0.000000e+00;
        for(        int k = 0; (k < int(rows(lb)));         k = (k + 1))
        {
          base_t leftdanglingBase = base_t(column(seq_char(dl, dl.i), k));
          base_t leftmostBasefirstStem = base_t(column(seq_char(e.firststem, (dl.i + 1)), k));
          dangleInternal_wc = (dangleInternal_wc + dl_dangle_dg(leftdanglingBase, leftmostBasefirstStem, wc_comp(leftmostBasefirstStem)));
          dangleInternal_wob = (dangleInternal_wc + dl_dangle_dg(leftdanglingBase, leftmostBasefirstStem, wob_comp(leftmostBasefirstStem)));
          dangleClosing = (dangleClosing + getEnergyAtRow(res.firststem, k, 1));
        }

        dangleInternal_wc = int((dangleInternal_wc / float(rows(lb))));
        dangleInternal_wob = int((dangleInternal_wob / float(rows(lb))));
        dangleClosing = int((dangleClosing / float(rows(lb))));
        double amdangle = (( ( (e.pf.q1 + e.pf.q2) )  * mk_pf(min(dangleInternal_wc, dangleClosing))) + ( ( (e.pf.q3 + e.pf.q4) )  * mk_pf(min(dangleInternal_wob, dangleClosing))));
        res.pf.q1 = ((scale(3) * amdangle) * mk_pf((((ml_energy() + ul_energy()) + int((termau_energy(res.firststem, res.firststem) / float(rows(lb))))) + covscore(lb, lb.i, rb.i))));
        res.pf.q2 = 0.000000e+00;
        res.pf.q3 = 0.000000e+00;
        res.pf.q4 = 0.000000e+00;
        return res;
#line 4624 ""
      }


      std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  mladl(const TUSubsequence & p_p_lb, const TUSubsequence & p_p_dl, const std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate> & p_p_e, const TUSubsequence & p_p_rb)
      {
        TUSubsequence l_0 = p_p_lb;
        TUSubsequence l_1 = p_p_dl;
        std::pair<String, shape_t>  l_2 = p_p_e.first;
        TUSubsequence l_3 = p_p_rb;
        TUSubsequence r_0 = p_p_lb;
        TUSubsequence r_1 = p_p_dl;
        answer_ali_pfunc_macrostate r_2 = p_p_e.second;
        TUSubsequence r_3 = p_p_rb;
        std::pair<String, shape_t>  ret_left = mladl_l(l_0, l_1, l_2, l_3);
        answer_ali_pfunc_macrostate ret_right = mladl_r(r_0, r_1, r_2, r_3);
        std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_p_p_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_p_p_e);
        if (!arg_p_p_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_bt = arg_p_p_e;
          intrusive_ptr<Eval_List<Value> > arg_p_p_e_elist = evaluate(arg_p_p_e_bt);
          for (typename Eval_List<Value>::iterator arg_p_p_e_elem_itr = arg_p_p_e_elist->begin(); arg_p_p_e_elem_itr != arg_p_p_e_elist->end(); ++ arg_p_p_e_elem_itr) {
            std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_e_elem = *arg_p_p_e_elem_itr;
            std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret = mladl(arg_p_p_lb, arg_p_p_dl, arg_p_p_e_elem, arg_p_p_rb);
            push_back( answer, ret);
          }
          erase( arg_p_p_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_p_p_e_bt_itr = arg_p_p_e_t->begin(); arg_p_p_e_bt_itr != arg_p_p_e_t->end(); ++ arg_p_p_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_bt = *arg_p_p_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_p_p_e_elist = evaluate(arg_p_p_e_bt);
          for (typename Eval_List<Value>::iterator arg_p_p_e_elem_itr = arg_p_p_e_elist->begin(); arg_p_p_e_elem_itr != arg_p_p_e_elist->end(); ++ arg_p_p_e_elem_itr) {
            std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_e_elem = *arg_p_p_e_elem_itr;
            std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret = mladl(arg_p_p_lb, arg_p_p_dl, arg_p_p_e_elem, arg_p_p_rb);
            push_back( answer, ret);
          }
          erase( arg_p_p_e_elist);
        }
        erase( arg_p_p_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_mladldr : Backtrace_Score<mfecovar_macrostate, Value, pos_int> {
      TUSubsequence arg_p_p_lb;
      TUSubsequence arg_p_p_dl;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e;
      TUSubsequence arg_p_p_dr;
      TUSubsequence arg_p_p_rb;

Backtrace_mladldr(TUSubsequence arg_p_p_lb_, TUSubsequence arg_p_p_dl_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_, TUSubsequence arg_p_p_dr_, TUSubsequence arg_p_p_rb_)
 : arg_p_p_lb(arg_p_p_lb_), arg_p_p_dl(arg_p_p_dl_), arg_p_p_e(arg_p_p_e_), arg_p_p_dr(arg_p_p_dr_), arg_p_p_rb(arg_p_p_rb_)
{}

~Backtrace_mladldr()
{
erase(arg_p_p_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      std::pair<String, shape_t>  mladldr_l(const TUSubsequence & p_lb, const TUSubsequence & p_dl, const std::pair<String, shape_t> & p_e, const TUSubsequence & p_dr, const TUSubsequence & p_rb)
      {
        TUSubsequence l_0 = p_lb;
        TUSubsequence l_1 = p_dl;
        String l_2 = p_e.first;
        TUSubsequence l_3 = p_dr;
        TUSubsequence l_4 = p_rb;
        TUSubsequence r_0 = p_lb;
        TUSubsequence r_1 = p_dl;
        shape_t r_2 = p_e.second;
        TUSubsequence r_3 = p_dr;
        TUSubsequence r_4 = p_rb;
        String ret_left = mladldr_l_l(l_0, l_1, l_2, l_3, l_4);
        shape_t ret_right = mladldr_l_r(r_0, r_1, r_2, r_3, r_4);
        std::pair<String, shape_t>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      String mladldr_l_l(const TUSubsequence & lb, const TUSubsequence & dl, const String & e, const TUSubsequence & dr, const TUSubsequence & rb)
      {
#line 267 ""
        String res;
        append( res, '(');
        append( res, '.');
        append( res, e);
        append( res, '.');
        append( res, ')');
        return res;
#line 4728 ""
      }


      shape_t mladldr_l_r(const TUSubsequence & lb, const TUSubsequence & dl, shape_t e, const TUSubsequence & dr, const TUSubsequence & rb)
      {
#line 1055 ""
        shape_t res;
        append( res, '[');
        if ((shapelevel() == 1))
          {
            append( res, '_');
          }

        append( res, e);
        append( res, ']');
        return res;
#line 4745 ""
      }


      answer_ali_pfunc_macrostate mladldr_r(const TUSubsequence & lb, const TUSubsequence & dl, const answer_ali_pfunc_macrostate & e, const TUSubsequence & dr, const TUSubsequence & rb)
      {
#line 1812 ""
        answer_ali_pfunc_macrostate res;
        res.firststem.i = lb.i;
        res.firststem.j = rb.j;
        res.firststem.seq = lb.seq;
        int dangleInternal_wc = 0;
        int dangleInternal_wob = 0;
        int dangle_l = 0;
        int dangle_r = 0;
        for(        int k = 0; (k < int(rows(lb)));         k = (k + 1))
        {
          base_t leftdanglingBase = base_t(column(seq_char(dl, dl.i), k));
          base_t leftmostBasefirstStem = base_t(column(seq_char(e.firststem, (dl.i + 1)), k));
          dangleInternal_wc = (dangleInternal_wc + dl_dangle_dg(leftdanglingBase, leftmostBasefirstStem, wc_comp(leftmostBasefirstStem)));
          dangleInternal_wob = (dangleInternal_wob + dl_dangle_dg(leftdanglingBase, leftmostBasefirstStem, wob_comp(leftmostBasefirstStem)));
          dangle_l = (dangle_l + getEnergyAtRow(res.firststem, k, 1));
          dangle_r = (dangle_r + getEnergyAtRow(res.firststem, k, 2));
        }

        dangleInternal_wc = int((dangleInternal_wc / float(rows(lb))));
        dangleInternal_wob = int((dangleInternal_wob / float(rows(lb))));
        dangle_l = int((dangle_l / float(rows(lb))));
        dangle_r = int((dangle_r / float(rows(lb))));
        double amdangle =  ( (( ( (e.pf.q1 + e.pf.q2) )  * mk_pf(min(dangleInternal_wc, dangle_l))) + ( ( (e.pf.q3 + (e.pf.q4 * mk_pf(dangle_r))) )  * mk_pf(min(dangleInternal_wob, dangle_l)))) ) ;
        res.pf.q1 = ((scale(4) * amdangle) * mk_pf((((ml_energy() + ul_energy()) + int((termau_energy(res.firststem, res.firststem) / float(rows(lb))))) + covscore(lb, lb.i, rb.i))));
        res.pf.q2 = 0.000000e+00;
        res.pf.q3 = 0.000000e+00;
        res.pf.q4 = 0.000000e+00;
        return res;
#line 4780 ""
      }


      std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  mladldr(const TUSubsequence & p_p_lb, const TUSubsequence & p_p_dl, const std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate> & p_p_e, const TUSubsequence & p_p_dr, const TUSubsequence & p_p_rb)
      {
        TUSubsequence l_0 = p_p_lb;
        TUSubsequence l_1 = p_p_dl;
        std::pair<String, shape_t>  l_2 = p_p_e.first;
        TUSubsequence l_3 = p_p_dr;
        TUSubsequence l_4 = p_p_rb;
        TUSubsequence r_0 = p_p_lb;
        TUSubsequence r_1 = p_p_dl;
        answer_ali_pfunc_macrostate r_2 = p_p_e.second;
        TUSubsequence r_3 = p_p_dr;
        TUSubsequence r_4 = p_p_rb;
        std::pair<String, shape_t>  ret_left = mladldr_l(l_0, l_1, l_2, l_3, l_4);
        answer_ali_pfunc_macrostate ret_right = mladldr_r(r_0, r_1, r_2, r_3, r_4);
        std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_p_p_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_p_p_e);
        if (!arg_p_p_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_bt = arg_p_p_e;
          intrusive_ptr<Eval_List<Value> > arg_p_p_e_elist = evaluate(arg_p_p_e_bt);
          for (typename Eval_List<Value>::iterator arg_p_p_e_elem_itr = arg_p_p_e_elist->begin(); arg_p_p_e_elem_itr != arg_p_p_e_elist->end(); ++ arg_p_p_e_elem_itr) {
            std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_e_elem = *arg_p_p_e_elem_itr;
            std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret = mladldr(arg_p_p_lb, arg_p_p_dl, arg_p_p_e_elem, arg_p_p_dr, arg_p_p_rb);
            push_back( answer, ret);
          }
          erase( arg_p_p_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_p_p_e_bt_itr = arg_p_p_e_t->begin(); arg_p_p_e_bt_itr != arg_p_p_e_t->end(); ++ arg_p_p_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_bt = *arg_p_p_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_p_p_e_elist = evaluate(arg_p_p_e_bt);
          for (typename Eval_List<Value>::iterator arg_p_p_e_elem_itr = arg_p_p_e_elist->begin(); arg_p_p_e_elem_itr != arg_p_p_e_elist->end(); ++ arg_p_p_e_elem_itr) {
            std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_e_elem = *arg_p_p_e_elem_itr;
            std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret = mladldr(arg_p_p_lb, arg_p_p_dl, arg_p_p_e_elem, arg_p_p_dr, arg_p_p_rb);
            push_back( answer, ret);
          }
          erase( arg_p_p_e_elist);
        }
        erase( arg_p_p_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_mladlr : Backtrace_Score<mfecovar_macrostate, Value, pos_int> {
      TUSubsequence arg_p_p_lb;
      TUSubsequence arg_p_p_dl;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e;
      TUSubsequence arg_p_p_dr;
      TUSubsequence arg_p_p_rb;

Backtrace_mladlr(TUSubsequence arg_p_p_lb_, TUSubsequence arg_p_p_dl_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_, TUSubsequence arg_p_p_dr_, TUSubsequence arg_p_p_rb_)
 : arg_p_p_lb(arg_p_p_lb_), arg_p_p_dl(arg_p_p_dl_), arg_p_p_e(arg_p_p_e_), arg_p_p_dr(arg_p_p_dr_), arg_p_p_rb(arg_p_p_rb_)
{}

~Backtrace_mladlr()
{
erase(arg_p_p_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      std::pair<String, shape_t>  mladlr_l(const TUSubsequence & p_lb, const TUSubsequence & p_dl, const std::pair<String, shape_t> & p_e, const TUSubsequence & p_dr, const TUSubsequence & p_rb)
      {
        TUSubsequence l_0 = p_lb;
        TUSubsequence l_1 = p_dl;
        String l_2 = p_e.first;
        TUSubsequence l_3 = p_dr;
        TUSubsequence l_4 = p_rb;
        TUSubsequence r_0 = p_lb;
        TUSubsequence r_1 = p_dl;
        shape_t r_2 = p_e.second;
        TUSubsequence r_3 = p_dr;
        TUSubsequence r_4 = p_rb;
        String ret_left = mladlr_l_l(l_0, l_1, l_2, l_3, l_4);
        shape_t ret_right = mladlr_l_r(r_0, r_1, r_2, r_3, r_4);
        std::pair<String, shape_t>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      String mladlr_l_l(const TUSubsequence & lb, const TUSubsequence & dl, const String & e, const TUSubsequence & dr, const TUSubsequence & rb)
      {
#line 247 ""
        String res;
        append( res, '(');
        append( res, '.');
        append( res, e);
        append( res, '.');
        append( res, ')');
        return res;
#line 4886 ""
      }


      shape_t mladlr_l_r(const TUSubsequence & lb, const TUSubsequence & dl, shape_t e, const TUSubsequence & dr, const TUSubsequence & rb)
      {
#line 1036 ""
        shape_t res;
        append( res, '[');
        if ((shapelevel() == 1))
          {
            append( res, '_');
          }

        append( res, e);
        if ((shapelevel() == 1))
          {
            append( res, '_');
          }

        append( res, ']');
        return res;
#line 4908 ""
      }


      answer_ali_pfunc_macrostate mladlr_r(const TUSubsequence & lb, const TUSubsequence & dl, const answer_ali_pfunc_macrostate & e, const TUSubsequence & dr, const TUSubsequence & rb)
      {
#line 1733 ""
        answer_ali_pfunc_macrostate res;
        res.firststem.i = lb.i;
        res.firststem.j = rb.j;
        res.firststem.seq = lb.seq;
        int dangleInternal_first_wc = 0;
        int dangleInternal_first_wob = 0;
        int dangleInternal_last_wc = 0;
        int dangleInternal_last_wob = 0;
        int dangle_l = 0;
        int dangle_r = 0;
        for(        int k = 0; (k < int(rows(lb)));         k = (k + 1))
        {
          base_t leftdanglingBase = base_t(column(seq_char(dl, dl.i), k));
          base_t rightdanglingBase = base_t(column(seq_char(dr, dr.i), k));
          base_t leftmostBasefirstStem = base_t(column(seq_char(e.firststem, (dl.i + 1)), k));
          base_t rightmostBaselastStem = base_t(column(seq_char(e.firststem, (dr.i - 1)), k));
          dangleInternal_first_wc = (dangleInternal_first_wc + dl_dangle_dg(leftdanglingBase, leftmostBasefirstStem, wc_comp(leftmostBasefirstStem)));
          dangleInternal_first_wob = (dangleInternal_first_wob + dl_dangle_dg(leftdanglingBase, leftmostBasefirstStem, wob_comp(leftmostBasefirstStem)));
          dangle_l = (dangle_l + getEnergyAtRow(res.firststem, k, 1));
          dangleInternal_last_wc = (dangleInternal_last_wc + dr_dangle_dg(wc_comp(rightmostBaselastStem), rightmostBaselastStem, rightdanglingBase));
          dangleInternal_last_wob = (dangleInternal_last_wob + dr_dangle_dg(wob_comp(rightmostBaselastStem), rightmostBaselastStem, rightdanglingBase));
          dangle_r = (dangle_r + getEnergyAtRow(res.firststem, k, 2));
        }

        dangleInternal_first_wc = int((dangleInternal_first_wc / float(rows(lb))));
        dangleInternal_first_wob = int((dangleInternal_first_wob / float(rows(lb))));
        dangleInternal_last_wc = int((dangleInternal_last_wc / float(rows(lb))));
        dangleInternal_last_wob = int((dangleInternal_last_wob / float(rows(lb))));
        dangle_l = int((dangle_l / float(rows(lb))));
        dangle_r = int((dangle_r / float(rows(lb))));
        double amdangle =  ( ((((e.pf.q1 * mk_pf((min(dangleInternal_first_wc, dangle_l) + min(dangleInternal_last_wc, dangle_r)))) + (e.pf.q2 * mk_pf((min(dangleInternal_first_wc, dangle_l) + min(dangleInternal_last_wob, dangle_r))))) + (e.pf.q3 * mk_pf((min(dangleInternal_first_wob, dangle_l) + min(dangleInternal_last_wc, dangle_r))))) + (e.pf.q4 * mk_pf((min(dangleInternal_first_wob, dangle_l) + min(dangleInternal_last_wob, dangle_r))))) ) ;
        res.pf.q1 = ((scale(4) * amdangle) * mk_pf((((ml_energy() + ul_energy()) + int((termau_energy(res.firststem, res.firststem) / float(rows(lb))))) + covscore(lb, lb.i, rb.i))));
        res.pf.q2 = 0.000000e+00;
        res.pf.q3 = 0.000000e+00;
        res.pf.q4 = 0.000000e+00;
        return res;
#line 4951 ""
      }


      std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  mladlr(const TUSubsequence & p_p_lb, const TUSubsequence & p_p_dl, const std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate> & p_p_e, const TUSubsequence & p_p_dr, const TUSubsequence & p_p_rb)
      {
        TUSubsequence l_0 = p_p_lb;
        TUSubsequence l_1 = p_p_dl;
        std::pair<String, shape_t>  l_2 = p_p_e.first;
        TUSubsequence l_3 = p_p_dr;
        TUSubsequence l_4 = p_p_rb;
        TUSubsequence r_0 = p_p_lb;
        TUSubsequence r_1 = p_p_dl;
        answer_ali_pfunc_macrostate r_2 = p_p_e.second;
        TUSubsequence r_3 = p_p_dr;
        TUSubsequence r_4 = p_p_rb;
        std::pair<String, shape_t>  ret_left = mladlr_l(l_0, l_1, l_2, l_3, l_4);
        answer_ali_pfunc_macrostate ret_right = mladlr_r(r_0, r_1, r_2, r_3, r_4);
        std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_p_p_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_p_p_e);
        if (!arg_p_p_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_bt = arg_p_p_e;
          intrusive_ptr<Eval_List<Value> > arg_p_p_e_elist = evaluate(arg_p_p_e_bt);
          for (typename Eval_List<Value>::iterator arg_p_p_e_elem_itr = arg_p_p_e_elist->begin(); arg_p_p_e_elem_itr != arg_p_p_e_elist->end(); ++ arg_p_p_e_elem_itr) {
            std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_e_elem = *arg_p_p_e_elem_itr;
            std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret = mladlr(arg_p_p_lb, arg_p_p_dl, arg_p_p_e_elem, arg_p_p_dr, arg_p_p_rb);
            push_back( answer, ret);
          }
          erase( arg_p_p_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_p_p_e_bt_itr = arg_p_p_e_t->begin(); arg_p_p_e_bt_itr != arg_p_p_e_t->end(); ++ arg_p_p_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_bt = *arg_p_p_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_p_p_e_elist = evaluate(arg_p_p_e_bt);
          for (typename Eval_List<Value>::iterator arg_p_p_e_elem_itr = arg_p_p_e_elist->begin(); arg_p_p_e_elem_itr != arg_p_p_e_elist->end(); ++ arg_p_p_e_elem_itr) {
            std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_e_elem = *arg_p_p_e_elem_itr;
            std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret = mladlr(arg_p_p_lb, arg_p_p_dl, arg_p_p_e_elem, arg_p_p_dr, arg_p_p_rb);
            push_back( answer, ret);
          }
          erase( arg_p_p_e_elist);
        }
        erase( arg_p_p_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_mladr : Backtrace_Score<mfecovar_macrostate, Value, pos_int> {
      TUSubsequence arg_p_p_lb;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e;
      TUSubsequence arg_p_p_dr;
      TUSubsequence arg_p_p_rb;

Backtrace_mladr(TUSubsequence arg_p_p_lb_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_, TUSubsequence arg_p_p_dr_, TUSubsequence arg_p_p_rb_)
 : arg_p_p_lb(arg_p_p_lb_), arg_p_p_e(arg_p_p_e_), arg_p_p_dr(arg_p_p_dr_), arg_p_p_rb(arg_p_p_rb_)
{}

~Backtrace_mladr()
{
erase(arg_p_p_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      std::pair<String, shape_t>  mladr_l(const TUSubsequence & p_lb, const std::pair<String, shape_t> & p_e, const TUSubsequence & p_dr, const TUSubsequence & p_rb)
      {
        TUSubsequence l_0 = p_lb;
        String l_1 = p_e.first;
        TUSubsequence l_2 = p_dr;
        TUSubsequence l_3 = p_rb;
        TUSubsequence r_0 = p_lb;
        shape_t r_1 = p_e.second;
        TUSubsequence r_2 = p_dr;
        TUSubsequence r_3 = p_rb;
        String ret_left = mladr_l_l(l_0, l_1, l_2, l_3);
        shape_t ret_right = mladr_l_r(r_0, r_1, r_2, r_3);
        std::pair<String, shape_t>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      String mladr_l_l(const TUSubsequence & lb, const String & e, const TUSubsequence & dr, const TUSubsequence & rb)
      {
#line 238 ""
        String res;
        append( res, '(');
        append( res, e);
        append( res, '.');
        append( res, ')');
        return res;
#line 5053 ""
      }


      shape_t mladr_l_r(const TUSubsequence & lb, shape_t e, const TUSubsequence & dr, const TUSubsequence & rb)
      {
#line 1027 ""
        shape_t res;
        append( res, '[');
        append( res, e);
        if ((shapelevel() == 1))
          {
            append( res, '_');
          }

        append( res, ']');
        return res;
#line 5070 ""
      }


      answer_ali_pfunc_macrostate mladr_r(const TUSubsequence & lb, const answer_ali_pfunc_macrostate & e, const TUSubsequence & dr, const TUSubsequence & rb)
      {
#line 1683 ""
        answer_ali_pfunc_macrostate res;
        res.firststem.i = lb.i;
        res.firststem.j = rb.j;
        res.firststem.seq = lb.seq;
        int dangleInternal_wc = 0.000000e+00;
        int dangleInternal_wob = 0.000000e+00;
        int dangleClosing = 0.000000e+00;
        for(        int k = 0; (k < int(rows(lb)));         k = (k + 1))
        {
          base_t rightdanglingBase = base_t(column(seq_char(dr, dr.i), k));
          base_t rightmostBaselastStem = base_t(column(seq_char(e.firststem, (dr.i - 1)), k));
          dangleInternal_wc = (dangleInternal_wc + dr_dangle_dg(wc_comp(rightmostBaselastStem), rightmostBaselastStem, rightdanglingBase));
          dangleInternal_wob = (dangleInternal_wob + dr_dangle_dg(wob_comp(rightmostBaselastStem), rightmostBaselastStem, rightdanglingBase));
          dangleClosing = (dangleClosing + getEnergyAtRow(res.firststem, k, 2));
        }

        dangleInternal_wc = int((dangleInternal_wc / float(rows(lb))));
        dangleInternal_wob = int((dangleInternal_wob / float(rows(lb))));
        dangleClosing = int((dangleClosing / float(rows(lb))));
        double amdangle = (( ( (e.pf.q1 + e.pf.q3) )  * mk_pf(min(dangleInternal_wc, dangleClosing))) + ( ( (e.pf.q2 + e.pf.q4) )  * mk_pf(min(dangleInternal_wob, dangleClosing))));
        res.pf.q1 = ((scale(3) * amdangle) * mk_pf((((ml_energy() + ul_energy()) + int((termau_energy(res.firststem, res.firststem) / float(rows(lb))))) + covscore(lb, lb.i, rb.i))));
        res.pf.q2 = 0.000000e+00;
        res.pf.q3 = 0.000000e+00;
        res.pf.q4 = 0.000000e+00;
        return res;
#line 5102 ""
      }


      std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  mladr(const TUSubsequence & p_p_lb, const std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate> & p_p_e, const TUSubsequence & p_p_dr, const TUSubsequence & p_p_rb)
      {
        TUSubsequence l_0 = p_p_lb;
        std::pair<String, shape_t>  l_1 = p_p_e.first;
        TUSubsequence l_2 = p_p_dr;
        TUSubsequence l_3 = p_p_rb;
        TUSubsequence r_0 = p_p_lb;
        answer_ali_pfunc_macrostate r_1 = p_p_e.second;
        TUSubsequence r_2 = p_p_dr;
        TUSubsequence r_3 = p_p_rb;
        std::pair<String, shape_t>  ret_left = mladr_l(l_0, l_1, l_2, l_3);
        answer_ali_pfunc_macrostate ret_right = mladr_r(r_0, r_1, r_2, r_3);
        std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_p_p_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_p_p_e);
        if (!arg_p_p_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_bt = arg_p_p_e;
          intrusive_ptr<Eval_List<Value> > arg_p_p_e_elist = evaluate(arg_p_p_e_bt);
          for (typename Eval_List<Value>::iterator arg_p_p_e_elem_itr = arg_p_p_e_elist->begin(); arg_p_p_e_elem_itr != arg_p_p_e_elist->end(); ++ arg_p_p_e_elem_itr) {
            std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_e_elem = *arg_p_p_e_elem_itr;
            std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret = mladr(arg_p_p_lb, arg_p_p_e_elem, arg_p_p_dr, arg_p_p_rb);
            push_back( answer, ret);
          }
          erase( arg_p_p_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_p_p_e_bt_itr = arg_p_p_e_t->begin(); arg_p_p_e_bt_itr != arg_p_p_e_t->end(); ++ arg_p_p_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_bt = *arg_p_p_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_p_p_e_elist = evaluate(arg_p_p_e_bt);
          for (typename Eval_List<Value>::iterator arg_p_p_e_elem_itr = arg_p_p_e_elist->begin(); arg_p_p_e_elem_itr != arg_p_p_e_elist->end(); ++ arg_p_p_e_elem_itr) {
            std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_e_elem = *arg_p_p_e_elem_itr;
            std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret = mladr(arg_p_p_lb, arg_p_p_e_elem, arg_p_p_dr, arg_p_p_rb);
            push_back( answer, ret);
          }
          erase( arg_p_p_e_elist);
        }
        erase( arg_p_p_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_mldl : Backtrace_Score<mfecovar_macrostate, Value, pos_int> {
      TUSubsequence arg_p_p_lb;
      TUSubsequence arg_p_p_dl;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e;
      TUSubsequence arg_p_p_rb;

Backtrace_mldl(TUSubsequence arg_p_p_lb_, TUSubsequence arg_p_p_dl_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_, TUSubsequence arg_p_p_rb_)
 : arg_p_p_lb(arg_p_p_lb_), arg_p_p_dl(arg_p_p_dl_), arg_p_p_e(arg_p_p_e_), arg_p_p_rb(arg_p_p_rb_)
{}

~Backtrace_mldl()
{
erase(arg_p_p_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      std::pair<String, shape_t>  mldl_l(const TUSubsequence & p_lb, const TUSubsequence & p_dl, const std::pair<String, shape_t> & p_e, const TUSubsequence & p_rb)
      {
        TUSubsequence l_0 = p_lb;
        TUSubsequence l_1 = p_dl;
        String l_2 = p_e.first;
        TUSubsequence l_3 = p_rb;
        TUSubsequence r_0 = p_lb;
        TUSubsequence r_1 = p_dl;
        shape_t r_2 = p_e.second;
        TUSubsequence r_3 = p_rb;
        String ret_left = mldl_l_l(l_0, l_1, l_2, l_3);
        shape_t ret_right = mldl_l_r(r_0, r_1, r_2, r_3);
        std::pair<String, shape_t>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      String mldl_l_l(const TUSubsequence & lb, const TUSubsequence & dl, const String & e, const TUSubsequence & rb)
      {
#line 176 ""
        String res;
        append( res, '(');
        append( res, '.');
        append( res, e);
        append( res, ')');
        return res;
#line 5202 ""
      }


      shape_t mldl_l_r(const TUSubsequence & lb, const TUSubsequence & dl, shape_t e, const TUSubsequence & rb)
      {
#line 966 ""
        shape_t res;
        append( res, openParen);
        if (( ( (shapelevel() == 1) )  &&  ( (front(e) != '_') ) ))
          {
            append( res, '_');
          }

        append( res, e);
        append( res, closeParen);
        return res;
#line 5219 ""
      }


      answer_ali_pfunc_macrostate mldl_r(const TUSubsequence & lb, const TUSubsequence & dl, const answer_ali_pfunc_macrostate & e, const TUSubsequence & rb)
      {
#line 1847 ""
        answer_ali_pfunc_macrostate res;
        res.firststem.i = lb.i;
        res.firststem.j = rb.j;
        res.firststem.seq = lb.seq;
        res.pf.q1 = ((scale(3) * sum_elems(e.pf)) * mk_pf((((ml_energy() + ul_energy()) + int(( ( (dli_energy(res.firststem, res.firststem) + termau_energy(res.firststem, res.firststem)) )  / float(rows(lb))))) + covscore(lb, lb.i, rb.i))));
        res.pf.q2 = 0.000000e+00;
        res.pf.q3 = 0.000000e+00;
        res.pf.q4 = 0.000000e+00;
        return res;
#line 5235 ""
      }


      std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  mldl(const TUSubsequence & p_p_lb, const TUSubsequence & p_p_dl, const std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate> & p_p_e, const TUSubsequence & p_p_rb)
      {
        TUSubsequence l_0 = p_p_lb;
        TUSubsequence l_1 = p_p_dl;
        std::pair<String, shape_t>  l_2 = p_p_e.first;
        TUSubsequence l_3 = p_p_rb;
        TUSubsequence r_0 = p_p_lb;
        TUSubsequence r_1 = p_p_dl;
        answer_ali_pfunc_macrostate r_2 = p_p_e.second;
        TUSubsequence r_3 = p_p_rb;
        std::pair<String, shape_t>  ret_left = mldl_l(l_0, l_1, l_2, l_3);
        answer_ali_pfunc_macrostate ret_right = mldl_r(r_0, r_1, r_2, r_3);
        std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_p_p_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_p_p_e);
        if (!arg_p_p_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_bt = arg_p_p_e;
          intrusive_ptr<Eval_List<Value> > arg_p_p_e_elist = evaluate(arg_p_p_e_bt);
          for (typename Eval_List<Value>::iterator arg_p_p_e_elem_itr = arg_p_p_e_elist->begin(); arg_p_p_e_elem_itr != arg_p_p_e_elist->end(); ++ arg_p_p_e_elem_itr) {
            std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_e_elem = *arg_p_p_e_elem_itr;
            std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret = mldl(arg_p_p_lb, arg_p_p_dl, arg_p_p_e_elem, arg_p_p_rb);
            push_back( answer, ret);
          }
          erase( arg_p_p_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_p_p_e_bt_itr = arg_p_p_e_t->begin(); arg_p_p_e_bt_itr != arg_p_p_e_t->end(); ++ arg_p_p_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_bt = *arg_p_p_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_p_p_e_elist = evaluate(arg_p_p_e_bt);
          for (typename Eval_List<Value>::iterator arg_p_p_e_elem_itr = arg_p_p_e_elist->begin(); arg_p_p_e_elem_itr != arg_p_p_e_elist->end(); ++ arg_p_p_e_elem_itr) {
            std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_e_elem = *arg_p_p_e_elem_itr;
            std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret = mldl(arg_p_p_lb, arg_p_p_dl, arg_p_p_e_elem, arg_p_p_rb);
            push_back( answer, ret);
          }
          erase( arg_p_p_e_elist);
        }
        erase( arg_p_p_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_mldladr : Backtrace_Score<mfecovar_macrostate, Value, pos_int> {
      TUSubsequence arg_p_p_lb;
      TUSubsequence arg_p_p_dl;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e;
      TUSubsequence arg_p_p_dr;
      TUSubsequence arg_p_p_rb;

Backtrace_mldladr(TUSubsequence arg_p_p_lb_, TUSubsequence arg_p_p_dl_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_, TUSubsequence arg_p_p_dr_, TUSubsequence arg_p_p_rb_)
 : arg_p_p_lb(arg_p_p_lb_), arg_p_p_dl(arg_p_p_dl_), arg_p_p_e(arg_p_p_e_), arg_p_p_dr(arg_p_p_dr_), arg_p_p_rb(arg_p_p_rb_)
{}

~Backtrace_mldladr()
{
erase(arg_p_p_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      std::pair<String, shape_t>  mldladr_l(const TUSubsequence & p_lb, const TUSubsequence & p_dl, const std::pair<String, shape_t> & p_e, const TUSubsequence & p_dr, const TUSubsequence & p_rb)
      {
        TUSubsequence l_0 = p_lb;
        TUSubsequence l_1 = p_dl;
        String l_2 = p_e.first;
        TUSubsequence l_3 = p_dr;
        TUSubsequence l_4 = p_rb;
        TUSubsequence r_0 = p_lb;
        TUSubsequence r_1 = p_dl;
        shape_t r_2 = p_e.second;
        TUSubsequence r_3 = p_dr;
        TUSubsequence r_4 = p_rb;
        String ret_left = mldladr_l_l(l_0, l_1, l_2, l_3, l_4);
        shape_t ret_right = mldladr_l_r(r_0, r_1, r_2, r_3, r_4);
        std::pair<String, shape_t>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      String mldladr_l_l(const TUSubsequence & lb, const TUSubsequence & dl, const String & e, const TUSubsequence & dr, const TUSubsequence & rb)
      {
#line 257 ""
        String res;
        append( res, '(');
        append( res, '.');
        append( res, e);
        append( res, '.');
        append( res, ')');
        return res;
#line 5339 ""
      }


      shape_t mldladr_l_r(const TUSubsequence & lb, const TUSubsequence & dl, shape_t e, const TUSubsequence & dr, const TUSubsequence & rb)
      {
#line 1046 ""
        shape_t res;
        append( res, '[');
        append( res, e);
        if ((shapelevel() == 1))
          {
            append( res, '_');
          }

        append( res, ']');
        return res;
#line 5356 ""
      }


      answer_ali_pfunc_macrostate mldladr_r(const TUSubsequence & lb, const TUSubsequence & dl, const answer_ali_pfunc_macrostate & e, const TUSubsequence & dr, const TUSubsequence & rb)
      {
#line 1778 ""
        answer_ali_pfunc_macrostate res;
        res.firststem.i = lb.i;
        res.firststem.j = rb.j;
        res.firststem.seq = lb.seq;
        int dangle_l = 0;
        int dangle_r = 0;
        int dangleInternal_wc = 0;
        int dangleInternal_wob = 0;
        for(        int k = 0; (k < int(rows(lb)));         k = (k + 1))
        {
          base_t rightdanglingBase = base_t(column(seq_char(dr, dr.i), k));
          base_t rightmostBaselastStem = base_t(column(seq_char(e.firststem, (dr.i - 1)), k));
          dangle_l = (dangle_l + getEnergyAtRow(res.firststem, k, 1));
          dangle_r = (dangle_r + getEnergyAtRow(res.firststem, k, 2));
          dangleInternal_wc = (dangleInternal_wc + dr_dangle_dg(wc_comp(rightmostBaselastStem), rightmostBaselastStem, rightdanglingBase));
          dangleInternal_wob = (dangleInternal_wob + dr_dangle_dg(wob_comp(rightmostBaselastStem), rightmostBaselastStem, rightdanglingBase));
        }

        dangle_l = int((dangle_l / float(rows(lb))));
        dangle_r = int((dangle_r / float(rows(lb))));
        dangleInternal_wc = int((dangleInternal_wc / float(rows(lb))));
        dangleInternal_wob = int((dangleInternal_wob / float(rows(lb))));
        double amdangle =  ( (( ( ((e.pf.q1 * mk_pf(dangle_l)) + e.pf.q3) )  * mk_pf(min(dangleInternal_wc, dangle_r))) + ( ( (e.pf.q2 + e.pf.q4) )  * mk_pf(min(dangleInternal_wob, dangle_r)))) ) ;
        res.pf.q1 = ((scale(4) * amdangle) * mk_pf((((ml_energy() + ul_energy()) + int((termau_energy(res.firststem, res.firststem) / float(rows(lb))))) + covscore(lb, lb.i, rb.i))));
        res.pf.q2 = 0.000000e+00;
        res.pf.q3 = 0.000000e+00;
        res.pf.q4 = 0.000000e+00;
        return res;
#line 5391 ""
      }


      std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  mldladr(const TUSubsequence & p_p_lb, const TUSubsequence & p_p_dl, const std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate> & p_p_e, const TUSubsequence & p_p_dr, const TUSubsequence & p_p_rb)
      {
        TUSubsequence l_0 = p_p_lb;
        TUSubsequence l_1 = p_p_dl;
        std::pair<String, shape_t>  l_2 = p_p_e.first;
        TUSubsequence l_3 = p_p_dr;
        TUSubsequence l_4 = p_p_rb;
        TUSubsequence r_0 = p_p_lb;
        TUSubsequence r_1 = p_p_dl;
        answer_ali_pfunc_macrostate r_2 = p_p_e.second;
        TUSubsequence r_3 = p_p_dr;
        TUSubsequence r_4 = p_p_rb;
        std::pair<String, shape_t>  ret_left = mldladr_l(l_0, l_1, l_2, l_3, l_4);
        answer_ali_pfunc_macrostate ret_right = mldladr_r(r_0, r_1, r_2, r_3, r_4);
        std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_p_p_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_p_p_e);
        if (!arg_p_p_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_bt = arg_p_p_e;
          intrusive_ptr<Eval_List<Value> > arg_p_p_e_elist = evaluate(arg_p_p_e_bt);
          for (typename Eval_List<Value>::iterator arg_p_p_e_elem_itr = arg_p_p_e_elist->begin(); arg_p_p_e_elem_itr != arg_p_p_e_elist->end(); ++ arg_p_p_e_elem_itr) {
            std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_e_elem = *arg_p_p_e_elem_itr;
            std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret = mldladr(arg_p_p_lb, arg_p_p_dl, arg_p_p_e_elem, arg_p_p_dr, arg_p_p_rb);
            push_back( answer, ret);
          }
          erase( arg_p_p_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_p_p_e_bt_itr = arg_p_p_e_t->begin(); arg_p_p_e_bt_itr != arg_p_p_e_t->end(); ++ arg_p_p_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_bt = *arg_p_p_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_p_p_e_elist = evaluate(arg_p_p_e_bt);
          for (typename Eval_List<Value>::iterator arg_p_p_e_elem_itr = arg_p_p_e_elist->begin(); arg_p_p_e_elem_itr != arg_p_p_e_elist->end(); ++ arg_p_p_e_elem_itr) {
            std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_e_elem = *arg_p_p_e_elem_itr;
            std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret = mldladr(arg_p_p_lb, arg_p_p_dl, arg_p_p_e_elem, arg_p_p_dr, arg_p_p_rb);
            push_back( answer, ret);
          }
          erase( arg_p_p_e_elist);
        }
        erase( arg_p_p_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_mldlr : Backtrace_Score<mfecovar_macrostate, Value, pos_int> {
      TUSubsequence arg_p_p_lb;
      TUSubsequence arg_p_p_dl;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e;
      TUSubsequence arg_p_p_dr;
      TUSubsequence arg_p_p_rb;

Backtrace_mldlr(TUSubsequence arg_p_p_lb_, TUSubsequence arg_p_p_dl_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_, TUSubsequence arg_p_p_dr_, TUSubsequence arg_p_p_rb_)
 : arg_p_p_lb(arg_p_p_lb_), arg_p_p_dl(arg_p_p_dl_), arg_p_p_e(arg_p_p_e_), arg_p_p_dr(arg_p_p_dr_), arg_p_p_rb(arg_p_p_rb_)
{}

~Backtrace_mldlr()
{
erase(arg_p_p_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      std::pair<String, shape_t>  mldlr_l(const TUSubsequence & p_lb, const TUSubsequence & p_dl, const std::pair<String, shape_t> & p_e, const TUSubsequence & p_dr, const TUSubsequence & p_rb)
      {
        TUSubsequence l_0 = p_lb;
        TUSubsequence l_1 = p_dl;
        String l_2 = p_e.first;
        TUSubsequence l_3 = p_dr;
        TUSubsequence l_4 = p_rb;
        TUSubsequence r_0 = p_lb;
        TUSubsequence r_1 = p_dl;
        shape_t r_2 = p_e.second;
        TUSubsequence r_3 = p_dr;
        TUSubsequence r_4 = p_rb;
        String ret_left = mldlr_l_l(l_0, l_1, l_2, l_3, l_4);
        shape_t ret_right = mldlr_l_r(r_0, r_1, r_2, r_3, r_4);
        std::pair<String, shape_t>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      String mldlr_l_l(const TUSubsequence & lb, const TUSubsequence & dl, const String & e, const TUSubsequence & dr, const TUSubsequence & rb)
      {
#line 166 ""
        String res;
        append( res, '(');
        append( res, '.');
        append( res, e);
        append( res, '.');
        append( res, ')');
        return res;
#line 5497 ""
      }


      shape_t mldlr_l_r(const TUSubsequence & lb, const TUSubsequence & dl, shape_t e, const TUSubsequence & dr, const TUSubsequence & rb)
      {
#line 955 ""
        shape_t res;
        append( res, openParen);
        if (( ( (shapelevel() == 1) )  &&  ( (front(e) != '_') ) ))
          {
            append( res, '_');
          }

        append( res, e);
        if (( ( (shapelevel() == 1) )  &&  ( (back(e) != '_') ) ))
          {
            append( res, '_');
          }

        append( res, closeParen);
        return res;
#line 5519 ""
      }


      answer_ali_pfunc_macrostate mldlr_r(const TUSubsequence & lb, const TUSubsequence & dl, const answer_ali_pfunc_macrostate & e, const TUSubsequence & dr, const TUSubsequence & rb)
      {
#line 1715 ""
        answer_ali_pfunc_macrostate res;
        res.firststem.i = lb.i;
        res.firststem.j = rb.j;
        res.firststem.seq = lb.seq;
        int help = min(min(ml_mismatch_energy(res.firststem, res.firststem), dli_energy(res.firststem, res.firststem)), dri_energy(res.firststem, res.firststem));
        res.pf.q1 = ((scale(4) * sum_elems(e.pf)) * mk_pf((((ml_energy() + ul_energy()) + int(( ( (help + termau_energy(res.firststem, res.firststem)) )  / float(rows(lb))))) + covscore(lb, lb.i, rb.i))));
        res.pf.q2 = 0.000000e+00;
        res.pf.q3 = 0.000000e+00;
        res.pf.q4 = 0.000000e+00;
        return res;
#line 5536 ""
      }


      std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  mldlr(const TUSubsequence & p_p_lb, const TUSubsequence & p_p_dl, const std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate> & p_p_e, const TUSubsequence & p_p_dr, const TUSubsequence & p_p_rb)
      {
        TUSubsequence l_0 = p_p_lb;
        TUSubsequence l_1 = p_p_dl;
        std::pair<String, shape_t>  l_2 = p_p_e.first;
        TUSubsequence l_3 = p_p_dr;
        TUSubsequence l_4 = p_p_rb;
        TUSubsequence r_0 = p_p_lb;
        TUSubsequence r_1 = p_p_dl;
        answer_ali_pfunc_macrostate r_2 = p_p_e.second;
        TUSubsequence r_3 = p_p_dr;
        TUSubsequence r_4 = p_p_rb;
        std::pair<String, shape_t>  ret_left = mldlr_l(l_0, l_1, l_2, l_3, l_4);
        answer_ali_pfunc_macrostate ret_right = mldlr_r(r_0, r_1, r_2, r_3, r_4);
        std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_p_p_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_p_p_e);
        if (!arg_p_p_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_bt = arg_p_p_e;
          intrusive_ptr<Eval_List<Value> > arg_p_p_e_elist = evaluate(arg_p_p_e_bt);
          for (typename Eval_List<Value>::iterator arg_p_p_e_elem_itr = arg_p_p_e_elist->begin(); arg_p_p_e_elem_itr != arg_p_p_e_elist->end(); ++ arg_p_p_e_elem_itr) {
            std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_e_elem = *arg_p_p_e_elem_itr;
            std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret = mldlr(arg_p_p_lb, arg_p_p_dl, arg_p_p_e_elem, arg_p_p_dr, arg_p_p_rb);
            push_back( answer, ret);
          }
          erase( arg_p_p_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_p_p_e_bt_itr = arg_p_p_e_t->begin(); arg_p_p_e_bt_itr != arg_p_p_e_t->end(); ++ arg_p_p_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_bt = *arg_p_p_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_p_p_e_elist = evaluate(arg_p_p_e_bt);
          for (typename Eval_List<Value>::iterator arg_p_p_e_elem_itr = arg_p_p_e_elist->begin(); arg_p_p_e_elem_itr != arg_p_p_e_elist->end(); ++ arg_p_p_e_elem_itr) {
            std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_e_elem = *arg_p_p_e_elem_itr;
            std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret = mldlr(arg_p_p_lb, arg_p_p_dl, arg_p_p_e_elem, arg_p_p_dr, arg_p_p_rb);
            push_back( answer, ret);
          }
          erase( arg_p_p_e_elist);
        }
        erase( arg_p_p_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_mldr : Backtrace_Score<mfecovar_macrostate, Value, pos_int> {
      TUSubsequence arg_p_p_lb;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e;
      TUSubsequence arg_p_p_dr;
      TUSubsequence arg_p_p_rb;

Backtrace_mldr(TUSubsequence arg_p_p_lb_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_, TUSubsequence arg_p_p_dr_, TUSubsequence arg_p_p_rb_)
 : arg_p_p_lb(arg_p_p_lb_), arg_p_p_e(arg_p_p_e_), arg_p_p_dr(arg_p_p_dr_), arg_p_p_rb(arg_p_p_rb_)
{}

~Backtrace_mldr()
{
erase(arg_p_p_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      std::pair<String, shape_t>  mldr_l(const TUSubsequence & p_lb, const std::pair<String, shape_t> & p_e, const TUSubsequence & p_dr, const TUSubsequence & p_rb)
      {
        TUSubsequence l_0 = p_lb;
        String l_1 = p_e.first;
        TUSubsequence l_2 = p_dr;
        TUSubsequence l_3 = p_rb;
        TUSubsequence r_0 = p_lb;
        shape_t r_1 = p_e.second;
        TUSubsequence r_2 = p_dr;
        TUSubsequence r_3 = p_rb;
        String ret_left = mldr_l_l(l_0, l_1, l_2, l_3);
        shape_t ret_right = mldr_l_r(r_0, r_1, r_2, r_3);
        std::pair<String, shape_t>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      String mldr_l_l(const TUSubsequence & lb, const String & e, const TUSubsequence & dr, const TUSubsequence & rb)
      {
#line 157 ""
        String res;
        append( res, '(');
        append( res, e);
        append( res, '.');
        append( res, ')');
        return res;
#line 5638 ""
      }


      shape_t mldr_l_r(const TUSubsequence & lb, shape_t e, const TUSubsequence & dr, const TUSubsequence & rb)
      {
#line 946 ""
        shape_t res;
        append( res, openParen);
        append( res, e);
        if (( ( (shapelevel() == 1) )  &&  ( (back(e) != '_') ) ))
          {
            append( res, '_');
          }

        append( res, closeParen);
        return res;
#line 5655 ""
      }


      answer_ali_pfunc_macrostate mldr_r(const TUSubsequence & lb, const answer_ali_pfunc_macrostate & e, const TUSubsequence & dr, const TUSubsequence & rb)
      {
#line 1668 ""
        answer_ali_pfunc_macrostate res;
        res.firststem.i = lb.i;
        res.firststem.j = rb.j;
        res.firststem.seq = lb.seq;
        res.pf.q1 = ((scale(3) * sum_elems(e.pf)) * mk_pf((((ml_energy() + ul_energy()) + int(( ( (dri_energy(res.firststem, res.firststem) + termau_energy(res.firststem, res.firststem)) )  / float(rows(lb))))) + covscore(lb, lb.i, rb.i))));
        res.pf.q2 = 0.000000e+00;
        res.pf.q3 = 0.000000e+00;
        res.pf.q4 = 0.000000e+00;
        return res;
#line 5671 ""
      }


      std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  mldr(const TUSubsequence & p_p_lb, const std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate> & p_p_e, const TUSubsequence & p_p_dr, const TUSubsequence & p_p_rb)
      {
        TUSubsequence l_0 = p_p_lb;
        std::pair<String, shape_t>  l_1 = p_p_e.first;
        TUSubsequence l_2 = p_p_dr;
        TUSubsequence l_3 = p_p_rb;
        TUSubsequence r_0 = p_p_lb;
        answer_ali_pfunc_macrostate r_1 = p_p_e.second;
        TUSubsequence r_2 = p_p_dr;
        TUSubsequence r_3 = p_p_rb;
        std::pair<String, shape_t>  ret_left = mldr_l(l_0, l_1, l_2, l_3);
        answer_ali_pfunc_macrostate ret_right = mldr_r(r_0, r_1, r_2, r_3);
        std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_p_p_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_p_p_e);
        if (!arg_p_p_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_bt = arg_p_p_e;
          intrusive_ptr<Eval_List<Value> > arg_p_p_e_elist = evaluate(arg_p_p_e_bt);
          for (typename Eval_List<Value>::iterator arg_p_p_e_elem_itr = arg_p_p_e_elist->begin(); arg_p_p_e_elem_itr != arg_p_p_e_elist->end(); ++ arg_p_p_e_elem_itr) {
            std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_e_elem = *arg_p_p_e_elem_itr;
            std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret = mldr(arg_p_p_lb, arg_p_p_e_elem, arg_p_p_dr, arg_p_p_rb);
            push_back( answer, ret);
          }
          erase( arg_p_p_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_p_p_e_bt_itr = arg_p_p_e_t->begin(); arg_p_p_e_bt_itr != arg_p_p_e_t->end(); ++ arg_p_p_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_bt = *arg_p_p_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_p_p_e_elist = evaluate(arg_p_p_e_bt);
          for (typename Eval_List<Value>::iterator arg_p_p_e_elem_itr = arg_p_p_e_elist->begin(); arg_p_p_e_elem_itr != arg_p_p_e_elist->end(); ++ arg_p_p_e_elem_itr) {
            std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_e_elem = *arg_p_p_e_elem_itr;
            std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret = mldr(arg_p_p_lb, arg_p_p_e_elem, arg_p_p_dr, arg_p_p_rb);
            push_back( answer, ret);
          }
          erase( arg_p_p_e_elist);
        }
        erase( arg_p_p_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_nil : Backtrace_Score<mfecovar_macrostate, Value, pos_int> {
      TUSubsequence arg_p_p_loc;

Backtrace_nil(TUSubsequence arg_p_p_loc_)
 : arg_p_p_loc(arg_p_p_loc_)
{}

~Backtrace_nil()
{
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      std::pair<String, shape_t>  nil_l(const TUSubsequence & p_loc)
      {
        TUSubsequence l_0 = p_loc;
        TUSubsequence r_0 = p_loc;
        String ret_left = nil_l_l(l_0);
        shape_t ret_right = nil_l_r(r_0);
        std::pair<String, shape_t>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      String nil_l_l(const TUSubsequence & loc)
      {
#line 73 ""
        String r;
        return r;
#line 5757 ""
      }


      shape_t nil_l_r(const TUSubsequence & loc)
      {
#line 860 ""
        shape_t r;
        return r;
#line 5766 ""
      }


      answer_ali_pfunc_macrostate nil_r(const TUSubsequence & loc)
      {
#line 1508 ""
        answer_ali_pfunc_macrostate res;
        res.firststem.i = seq_size(loc);
        res.firststem.j = seq_size(loc);
        res.firststem.seq = loc.seq;
        res.pf.q1 = 1.000000e+00;
        res.pf.q2 = 0.000000e+00;
        res.pf.q3 = 0.000000e+00;
        res.pf.q4 = 0.000000e+00;
        return res;
#line 5782 ""
      }


      std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  nil(const TUSubsequence & p_p_loc)
      {
        TUSubsequence l_0 = p_p_loc;
        TUSubsequence r_0 = p_p_loc;
        std::pair<String, shape_t>  ret_left = nil_l(l_0);
        answer_ali_pfunc_macrostate ret_right = nil_r(r_0);
        std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret = nil(arg_p_p_loc);
        push_back( answer, ret);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_sadd : Backtrace_Score<mfecovar_macrostate, Value, pos_int> {
      TUSubsequence arg_p_p_lb;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e;

Backtrace_sadd(TUSubsequence arg_p_p_lb_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_)
 : arg_p_p_lb(arg_p_p_lb_), arg_p_p_e(arg_p_p_e_)
{}

~Backtrace_sadd()
{
erase(arg_p_p_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      std::pair<String, shape_t>  sadd_l(const TUSubsequence & p_lb, const std::pair<String, shape_t> & p_e)
      {
        TUSubsequence l_0 = p_lb;
        String l_1 = p_e.first;
        TUSubsequence r_0 = p_lb;
        shape_t r_1 = p_e.second;
        String ret_left = sadd_l_l(l_0, l_1);
        shape_t ret_right = sadd_l_r(r_0, r_1);
        std::pair<String, shape_t>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      String sadd_l_l(const TUSubsequence & lb, const String & e)
      {
#line 59 ""
        String res;
        append( res, '.');
        append( res, e);
        return res;
#line 5848 ""
      }


      shape_t sadd_l_r(const TUSubsequence & b, shape_t x)
      {
#line 830 ""
        shape_t emptyShape;
        if ((x == emptyShape))
          {
            return shape_t('_');
          }

        else
          {
            if (( ( (shapelevel() == 1) )  &&  ( (front(x) != '_') ) ))
              {
                return (shape_t('_') + x);
              }

            else
              {
                return x;
              }

          }

#line 5875 ""
      }


      answer_ali_pfunc_macrostate sadd_r(const TUSubsequence & lb, const answer_ali_pfunc_macrostate & e)
      {
#line 1422 ""
        answer_ali_pfunc_macrostate res;
        res.firststem = e.firststem;
        double sbase_sum = 0;
        for(        int k = 0; (k < int(rows(lb)));         k = (k + 1))
        {
          if ((column(seq_char(lb, lb.i), k) != GAP_BASE))
            {
              sbase_sum = (sbase_sum + sbase_energy());
            }

        }

        res.pf.q1 = ((scale(1) * e.pf.q1) * mk_pf((sbase_sum / float(rows(lb)))));
        res.pf.q2 = 0.000000e+00;
        res.pf.q3 = 0.000000e+00;
        res.pf.q4 = 0.000000e+00;
        return res;
#line 5899 ""
      }


      std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  sadd(const TUSubsequence & p_p_lb, const std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate> & p_p_e)
      {
        TUSubsequence l_0 = p_p_lb;
        std::pair<String, shape_t>  l_1 = p_p_e.first;
        TUSubsequence r_0 = p_p_lb;
        answer_ali_pfunc_macrostate r_1 = p_p_e.second;
        std::pair<String, shape_t>  ret_left = sadd_l(l_0, l_1);
        answer_ali_pfunc_macrostate ret_right = sadd_r(r_0, r_1);
        std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_p_p_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_p_p_e);
        if (!arg_p_p_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_bt = arg_p_p_e;
          intrusive_ptr<Eval_List<Value> > arg_p_p_e_elist = evaluate(arg_p_p_e_bt);
          for (typename Eval_List<Value>::iterator arg_p_p_e_elem_itr = arg_p_p_e_elist->begin(); arg_p_p_e_elem_itr != arg_p_p_e_elist->end(); ++ arg_p_p_e_elem_itr) {
            std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_e_elem = *arg_p_p_e_elem_itr;
            std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret = sadd(arg_p_p_lb, arg_p_p_e_elem);
            push_back( answer, ret);
          }
          erase( arg_p_p_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_p_p_e_bt_itr = arg_p_p_e_t->begin(); arg_p_p_e_bt_itr != arg_p_p_e_t->end(); ++ arg_p_p_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_bt = *arg_p_p_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_p_p_e_elist = evaluate(arg_p_p_e_bt);
          for (typename Eval_List<Value>::iterator arg_p_p_e_elem_itr = arg_p_p_e_elist->begin(); arg_p_p_e_elem_itr != arg_p_p_e_elist->end(); ++ arg_p_p_e_elem_itr) {
            std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_e_elem = *arg_p_p_e_elem_itr;
            std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret = sadd(arg_p_p_lb, arg_p_p_e_elem);
            push_back( answer, ret);
          }
          erase( arg_p_p_e_elist);
        }
        erase( arg_p_p_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_sr : Backtrace_Score<mfecovar_macrostate, Value, pos_int> {
      TUSubsequence arg_p_p_lb;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e;
      TUSubsequence arg_p_p_rb;

Backtrace_sr(TUSubsequence arg_p_p_lb_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_, TUSubsequence arg_p_p_rb_)
 : arg_p_p_lb(arg_p_p_lb_), arg_p_p_e(arg_p_p_e_), arg_p_p_rb(arg_p_p_rb_)
{}

~Backtrace_sr()
{
erase(arg_p_p_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      std::pair<String, shape_t>  sr_l(const TUSubsequence & p_lb, const std::pair<String, shape_t> & p_e, const TUSubsequence & p_rb)
      {
        TUSubsequence l_0 = p_lb;
        String l_1 = p_e.first;
        TUSubsequence l_2 = p_rb;
        TUSubsequence r_0 = p_lb;
        shape_t r_1 = p_e.second;
        TUSubsequence r_2 = p_rb;
        String ret_left = sr_l_l(l_0, l_1, l_2);
        shape_t ret_right = sr_l_r(r_0, r_1, r_2);
        std::pair<String, shape_t>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      String sr_l_l(const TUSubsequence & lb, const String & e, const TUSubsequence & rb)
      {
#line 104 ""
        String res;
        append( res, '(');
        append( res, e);
        append( res, ')');
        return res;
#line 5991 ""
      }


      shape_t sr_l_r(const TUSubsequence & lb, shape_t e, const TUSubsequence & rb)
      {
#line 893 ""
        return e;
#line 5999 ""
      }


      answer_ali_pfunc_macrostate sr_r(const TUSubsequence & lb, const answer_ali_pfunc_macrostate & e, const TUSubsequence & rb)
      {
#line 1577 ""
        answer_ali_pfunc_macrostate res;
        res.firststem.seq = lb.seq;
        res.firststem.i = lb.i;
        res.firststem.j = rb.j;
        res.pf.q1 = ((scale(2) * e.pf.q1) * mk_pf((int((sr_energy(res.firststem, res.firststem) / float(rows(lb)))) + covscore(lb, lb.i, rb.i))));
        res.pf.q2 = 0.000000e+00;
        res.pf.q3 = 0.000000e+00;
        res.pf.q4 = 0.000000e+00;
        return res;
#line 6015 ""
      }


      std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  sr(const TUSubsequence & p_p_lb, const std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate> & p_p_e, const TUSubsequence & p_p_rb)
      {
        TUSubsequence l_0 = p_p_lb;
        std::pair<String, shape_t>  l_1 = p_p_e.first;
        TUSubsequence l_2 = p_p_rb;
        TUSubsequence r_0 = p_p_lb;
        answer_ali_pfunc_macrostate r_1 = p_p_e.second;
        TUSubsequence r_2 = p_p_rb;
        std::pair<String, shape_t>  ret_left = sr_l(l_0, l_1, l_2);
        answer_ali_pfunc_macrostate ret_right = sr_r(r_0, r_1, r_2);
        std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_p_p_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_p_p_e);
        if (!arg_p_p_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_bt = arg_p_p_e;
          intrusive_ptr<Eval_List<Value> > arg_p_p_e_elist = evaluate(arg_p_p_e_bt);
          for (typename Eval_List<Value>::iterator arg_p_p_e_elem_itr = arg_p_p_e_elist->begin(); arg_p_p_e_elem_itr != arg_p_p_e_elist->end(); ++ arg_p_p_e_elem_itr) {
            std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_e_elem = *arg_p_p_e_elem_itr;
            std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret = sr(arg_p_p_lb, arg_p_p_e_elem, arg_p_p_rb);
            push_back( answer, ret);
          }
          erase( arg_p_p_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_p_p_e_bt_itr = arg_p_p_e_t->begin(); arg_p_p_e_bt_itr != arg_p_p_e_t->end(); ++ arg_p_p_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_bt = *arg_p_p_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_p_p_e_elist = evaluate(arg_p_p_e_bt);
          for (typename Eval_List<Value>::iterator arg_p_p_e_elem_itr = arg_p_p_e_elist->begin(); arg_p_p_e_elem_itr != arg_p_p_e_elist->end(); ++ arg_p_p_e_elem_itr) {
            std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_e_elem = *arg_p_p_e_elem_itr;
            std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret = sr(arg_p_p_lb, arg_p_p_e_elem, arg_p_p_rb);
            push_back( answer, ret);
          }
          erase( arg_p_p_e_elist);
        }
        erase( arg_p_p_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_ssadd : Backtrace_Score<mfecovar_macrostate, Value, pos_int> {
      TUSubsequence arg_p_p_lb;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e;

Backtrace_ssadd(TUSubsequence arg_p_p_lb_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_)
 : arg_p_p_lb(arg_p_p_lb_), arg_p_p_e(arg_p_p_e_)
{}

~Backtrace_ssadd()
{
erase(arg_p_p_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      std::pair<String, shape_t>  ssadd_l(const TUSubsequence & p_lb, const std::pair<String, shape_t> & p_e)
      {
        TUSubsequence l_0 = p_lb;
        String l_1 = p_e.first;
        TUSubsequence r_0 = p_lb;
        shape_t r_1 = p_e.second;
        String ret_left = ssadd_l_l(l_0, l_1);
        shape_t ret_right = ssadd_l_r(r_0, r_1);
        std::pair<String, shape_t>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      String ssadd_l_l(const TUSubsequence & lb, const String & e)
      {
#line 286 ""
        String res;
        append( res, '.', size(lb));
        append( res, e);
        return res;
#line 6105 ""
      }


      shape_t ssadd_l_r(const TUSubsequence & lb, shape_t e)
      {
#line 1073 ""
        return e;
#line 6113 ""
      }


      answer_ali_pfunc_macrostate ssadd_r(const TUSubsequence & lregion, const answer_ali_pfunc_macrostate & e)
      {
#line 1903 ""
        answer_ali_pfunc_macrostate res;
        res.firststem = e.firststem;
        res.pf = mk_tuple(e.firststem, ((scale((lregion.j - lregion.i)) * e.pf.q1) * mk_pf((ul_energy() + (int(ss_energy(lregion)) / float(rows(lregion)))))));
        return res;
#line 6124 ""
      }


      std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ssadd(const TUSubsequence & p_p_lb, const std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate> & p_p_e)
      {
        TUSubsequence l_0 = p_p_lb;
        std::pair<String, shape_t>  l_1 = p_p_e.first;
        TUSubsequence r_0 = p_p_lb;
        answer_ali_pfunc_macrostate r_1 = p_p_e.second;
        std::pair<String, shape_t>  ret_left = ssadd_l(l_0, l_1);
        answer_ali_pfunc_macrostate ret_right = ssadd_r(r_0, r_1);
        std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_p_p_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_p_p_e);
        if (!arg_p_p_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_bt = arg_p_p_e;
          intrusive_ptr<Eval_List<Value> > arg_p_p_e_elist = evaluate(arg_p_p_e_bt);
          for (typename Eval_List<Value>::iterator arg_p_p_e_elem_itr = arg_p_p_e_elist->begin(); arg_p_p_e_elem_itr != arg_p_p_e_elist->end(); ++ arg_p_p_e_elem_itr) {
            std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_e_elem = *arg_p_p_e_elem_itr;
            std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret = ssadd(arg_p_p_lb, arg_p_p_e_elem);
            push_back( answer, ret);
          }
          erase( arg_p_p_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_p_p_e_bt_itr = arg_p_p_e_t->begin(); arg_p_p_e_bt_itr != arg_p_p_e_t->end(); ++ arg_p_p_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_bt = *arg_p_p_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_p_p_e_elist = evaluate(arg_p_p_e_bt);
          for (typename Eval_List<Value>::iterator arg_p_p_e_elem_itr = arg_p_p_e_elist->begin(); arg_p_p_e_elem_itr != arg_p_p_e_elist->end(); ++ arg_p_p_e_elem_itr) {
            std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_e_elem = *arg_p_p_e_elem_itr;
            std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret = ssadd(arg_p_p_lb, arg_p_p_e_elem);
            push_back( answer, ret);
          }
          erase( arg_p_p_e_elist);
        }
        erase( arg_p_p_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_trafo : Backtrace_Score<mfecovar_macrostate, Value, pos_int> {
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e;

Backtrace_trafo(intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_)
 : arg_p_p_e(arg_p_p_e_)
{}

~Backtrace_trafo()
{
erase(arg_p_p_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      std::pair<String, shape_t>  trafo_l(const std::pair<String, shape_t> & p_e)
      {
        String l_0 = p_e.first;
        shape_t r_0 = p_e.second;
        String ret_left = trafo_l_l(l_0);
        shape_t ret_right = trafo_l_r(r_0);
        std::pair<String, shape_t>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      String trafo_l_l(const String & e)
      {
#line 293 ""
        return e;
#line 6206 ""
      }


      shape_t trafo_l_r(shape_t e)
      {
#line 1077 ""
        return e;
#line 6214 ""
      }


      answer_ali_pfunc_macrostate trafo_r(const answer_ali_pfunc_macrostate & e)
      {
#line 1912 ""
        answer_ali_pfunc_macrostate res;
        res.firststem = e.firststem;
        res.pf.q1 = sum_elems(e.pf);
        res.pf.q2 = 0.000000e+00;
        res.pf.q3 = 0.000000e+00;
        res.pf.q4 = 0.000000e+00;
        return res;
#line 6228 ""
      }


      std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  trafo(const std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate> & p_p_e)
      {
        std::pair<String, shape_t>  l_0 = p_p_e.first;
        answer_ali_pfunc_macrostate r_0 = p_p_e.second;
        std::pair<String, shape_t>  ret_left = trafo_l(l_0);
        answer_ali_pfunc_macrostate ret_right = trafo_r(r_0);
        std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_p_p_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_p_p_e);
        if (!arg_p_p_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_bt = arg_p_p_e;
          intrusive_ptr<Eval_List<Value> > arg_p_p_e_elist = evaluate(arg_p_p_e_bt);
          for (typename Eval_List<Value>::iterator arg_p_p_e_elem_itr = arg_p_p_e_elist->begin(); arg_p_p_e_elem_itr != arg_p_p_e_elist->end(); ++ arg_p_p_e_elem_itr) {
            std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_e_elem = *arg_p_p_e_elem_itr;
            std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret = trafo(arg_p_p_e_elem);
            push_back( answer, ret);
          }
          erase( arg_p_p_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_p_p_e_bt_itr = arg_p_p_e_t->begin(); arg_p_p_e_bt_itr != arg_p_p_e_t->end(); ++ arg_p_p_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_bt = *arg_p_p_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_p_p_e_elist = evaluate(arg_p_p_e_bt);
          for (typename Eval_List<Value>::iterator arg_p_p_e_elem_itr = arg_p_p_e_elist->begin(); arg_p_p_e_elem_itr != arg_p_p_e_elist->end(); ++ arg_p_p_e_elem_itr) {
            std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  arg_p_p_e_elem = *arg_p_p_e_elem_itr;
            std::pair<std::pair<String, shape_t> , answer_ali_pfunc_macrostate>  ret = trafo(arg_p_p_e_elem);
            push_back( answer, ret);
          }
          erase( arg_p_p_e_elist);
        }
        erase( arg_p_p_e);
        return answer;
      }


};
template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_struct_Back : public Backtrace_NT_Back_Base<mfecovar_macrostate, Klass, Value, pos_int>
{
Backtrace_nt_struct_Back(Klass *klass_)
  : Backtrace_NT_Back_Base<mfecovar_macrostate, Klass, Value, pos_int>(klass_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_struct());
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_struct_Front : public Backtrace_Score<mfecovar_macrostate , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_struct_Back<mfe_macrostate, Value, pos_int> > back;

Backtrace_nt_struct_Front(intrusive_ptr<Backtrace_nt_struct_Back<mfe_macrostate, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<mfecovar_macrostate, mfe_macrostate, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_left_unpaired_Back : public Backtrace_NT_Back_Base<mfecovar_macrostate, Klass, Value, pos_int>
{
pos_int t_0_i;
Backtrace_nt_left_unpaired_Back(Klass *klass_, pos_int t_0_i_)
  : Backtrace_NT_Back_Base<mfecovar_macrostate, Klass, Value, pos_int>(klass_), t_0_i(t_0_i_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_left_unpaired(t_0_i));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_left_unpaired_Front : public Backtrace_Score<mfecovar_macrostate , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_left_unpaired_Back<mfe_macrostate, Value, pos_int> > back;

Backtrace_nt_left_unpaired_Front(intrusive_ptr<Backtrace_nt_left_unpaired_Back<mfe_macrostate, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<mfecovar_macrostate, mfe_macrostate, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_left_dangle_Back : public Backtrace_NT_Back_Base<mfecovar_macrostate, Klass, Value, pos_int>
{
pos_int t_0_i;
Backtrace_nt_left_dangle_Back(Klass *klass_, pos_int t_0_i_)
  : Backtrace_NT_Back_Base<mfecovar_macrostate, Klass, Value, pos_int>(klass_), t_0_i(t_0_i_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_left_dangle(t_0_i));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_left_dangle_Front : public Backtrace_Score<mfecovar_macrostate , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_left_dangle_Back<mfe_macrostate, Value, pos_int> > back;

Backtrace_nt_left_dangle_Front(intrusive_ptr<Backtrace_nt_left_dangle_Back<mfe_macrostate, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<mfecovar_macrostate, mfe_macrostate, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_noleft_dangle_Back : public Backtrace_NT_Back_Base<mfecovar_macrostate, Klass, Value, pos_int>
{
pos_int t_0_i;
Backtrace_nt_noleft_dangle_Back(Klass *klass_, pos_int t_0_i_)
  : Backtrace_NT_Back_Base<mfecovar_macrostate, Klass, Value, pos_int>(klass_), t_0_i(t_0_i_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_noleft_dangle(t_0_i));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_noleft_dangle_Front : public Backtrace_Score<mfecovar_macrostate , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_noleft_dangle_Back<mfe_macrostate, Value, pos_int> > back;

Backtrace_nt_noleft_dangle_Front(intrusive_ptr<Backtrace_nt_noleft_dangle_Back<mfe_macrostate, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<mfecovar_macrostate, mfe_macrostate, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_edanglel_Back : public Backtrace_NT_Back_Base<mfecovar_macrostate, Klass, Value, pos_int>
{
pos_int t_0_i;
pos_int t_0_j;
Backtrace_nt_edanglel_Back(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_)
  : Backtrace_NT_Back_Base<mfecovar_macrostate, Klass, Value, pos_int>(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_edanglel(t_0_i, t_0_j));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_edanglel_Front : public Backtrace_Score<mfecovar_macrostate , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_edanglel_Back<mfe_macrostate, Value, pos_int> > back;

Backtrace_nt_edanglel_Front(intrusive_ptr<Backtrace_nt_edanglel_Back<mfe_macrostate, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<mfecovar_macrostate, mfe_macrostate, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_edangler_Back : public Backtrace_NT_Back_Base<mfecovar_macrostate, Klass, Value, pos_int>
{
pos_int t_0_i;
pos_int t_0_j;
Backtrace_nt_edangler_Back(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_)
  : Backtrace_NT_Back_Base<mfecovar_macrostate, Klass, Value, pos_int>(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_edangler(t_0_i, t_0_j));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_edangler_Front : public Backtrace_Score<mfecovar_macrostate , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_edangler_Back<mfe_macrostate, Value, pos_int> > back;

Backtrace_nt_edangler_Front(intrusive_ptr<Backtrace_nt_edangler_Back<mfe_macrostate, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<mfecovar_macrostate, mfe_macrostate, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_edanglelr_Back : public Backtrace_NT_Back_Base<mfecovar_macrostate, Klass, Value, pos_int>
{
pos_int t_0_i;
pos_int t_0_j;
Backtrace_nt_edanglelr_Back(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_)
  : Backtrace_NT_Back_Base<mfecovar_macrostate, Klass, Value, pos_int>(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_edanglelr(t_0_i, t_0_j));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_edanglelr_Front : public Backtrace_Score<mfecovar_macrostate , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_edanglelr_Back<mfe_macrostate, Value, pos_int> > back;

Backtrace_nt_edanglelr_Front(intrusive_ptr<Backtrace_nt_edanglelr_Back<mfe_macrostate, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<mfecovar_macrostate, mfe_macrostate, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_nodangle_Back : public Backtrace_NT_Back_Base<mfecovar_macrostate, Klass, Value, pos_int>
{
pos_int t_0_i;
pos_int t_0_j;
Backtrace_nt_nodangle_Back(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_)
  : Backtrace_NT_Back_Base<mfecovar_macrostate, Klass, Value, pos_int>(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_nodangle(t_0_i, t_0_j));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_nodangle_Front : public Backtrace_Score<mfecovar_macrostate , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_nodangle_Back<mfe_macrostate, Value, pos_int> > back;

Backtrace_nt_nodangle_Front(intrusive_ptr<Backtrace_nt_nodangle_Back<mfe_macrostate, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<mfecovar_macrostate, mfe_macrostate, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_strong_Back : public Backtrace_NT_Back_Base<mfecovar_macrostate, Klass, Value, pos_int>
{
pos_int t_0_i;
pos_int t_0_j;
Backtrace_nt_strong_Back(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_)
  : Backtrace_NT_Back_Base<mfecovar_macrostate, Klass, Value, pos_int>(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_strong(t_0_i, t_0_j));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_strong_Front : public Backtrace_Score<mfecovar_macrostate , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_strong_Back<mfe_macrostate, Value, pos_int> > back;

Backtrace_nt_strong_Front(intrusive_ptr<Backtrace_nt_strong_Back<mfe_macrostate, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<mfecovar_macrostate, mfe_macrostate, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_weak_Back : public Backtrace_NT_Back_Base<mfecovar_macrostate, Klass, Value, pos_int>
{
pos_int t_0_i;
pos_int t_0_j;
Backtrace_nt_weak_Back(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_)
  : Backtrace_NT_Back_Base<mfecovar_macrostate, Klass, Value, pos_int>(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_weak(t_0_i, t_0_j));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_weak_Front : public Backtrace_Score<mfecovar_macrostate , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_weak_Back<mfe_macrostate, Value, pos_int> > back;

Backtrace_nt_weak_Front(intrusive_ptr<Backtrace_nt_weak_Back<mfe_macrostate, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<mfecovar_macrostate, mfe_macrostate, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_multiloop_Back : public Backtrace_NT_Back_Base<mfecovar_macrostate, Klass, Value, pos_int>
{
pos_int t_0_i;
pos_int t_0_j;
Backtrace_nt_multiloop_Back(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_)
  : Backtrace_NT_Back_Base<mfecovar_macrostate, Klass, Value, pos_int>(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_multiloop(t_0_i, t_0_j));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_multiloop_Front : public Backtrace_Score<mfecovar_macrostate , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_multiloop_Back<mfe_macrostate, Value, pos_int> > back;

Backtrace_nt_multiloop_Front(intrusive_ptr<Backtrace_nt_multiloop_Back<mfe_macrostate, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<mfecovar_macrostate, mfe_macrostate, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_ml_comps1_Back : public Backtrace_NT_Back_Base<mfecovar_macrostate, Klass, Value, pos_int>
{
pos_int t_0_i;
pos_int t_0_j;
Backtrace_nt_ml_comps1_Back(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_)
  : Backtrace_NT_Back_Base<mfecovar_macrostate, Klass, Value, pos_int>(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_ml_comps1(t_0_i, t_0_j));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_ml_comps1_Front : public Backtrace_Score<mfecovar_macrostate , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_ml_comps1_Back<mfe_macrostate, Value, pos_int> > back;

Backtrace_nt_ml_comps1_Front(intrusive_ptr<Backtrace_nt_ml_comps1_Back<mfe_macrostate, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<mfecovar_macrostate, mfe_macrostate, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_ml_comps2_Back : public Backtrace_NT_Back_Base<mfecovar_macrostate, Klass, Value, pos_int>
{
pos_int t_0_i;
pos_int t_0_j;
Backtrace_nt_ml_comps2_Back(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_)
  : Backtrace_NT_Back_Base<mfecovar_macrostate, Klass, Value, pos_int>(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_ml_comps2(t_0_i, t_0_j));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_ml_comps2_Front : public Backtrace_Score<mfecovar_macrostate , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_ml_comps2_Back<mfe_macrostate, Value, pos_int> > back;

Backtrace_nt_ml_comps2_Front(intrusive_ptr<Backtrace_nt_ml_comps2_Back<mfe_macrostate, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<mfecovar_macrostate, mfe_macrostate, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_ml_comps3_Back : public Backtrace_NT_Back_Base<mfecovar_macrostate, Klass, Value, pos_int>
{
pos_int t_0_i;
pos_int t_0_j;
Backtrace_nt_ml_comps3_Back(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_)
  : Backtrace_NT_Back_Base<mfecovar_macrostate, Klass, Value, pos_int>(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_ml_comps3(t_0_i, t_0_j));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_ml_comps3_Front : public Backtrace_Score<mfecovar_macrostate , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_ml_comps3_Back<mfe_macrostate, Value, pos_int> > back;

Backtrace_nt_ml_comps3_Front(intrusive_ptr<Backtrace_nt_ml_comps3_Back<mfe_macrostate, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<mfecovar_macrostate, mfe_macrostate, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_ml_comps4_Back : public Backtrace_NT_Back_Base<mfecovar_macrostate, Klass, Value, pos_int>
{
pos_int t_0_i;
pos_int t_0_j;
Backtrace_nt_ml_comps4_Back(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_)
  : Backtrace_NT_Back_Base<mfecovar_macrostate, Klass, Value, pos_int>(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_ml_comps4(t_0_i, t_0_j));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_ml_comps4_Front : public Backtrace_Score<mfecovar_macrostate , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_ml_comps4_Back<mfe_macrostate, Value, pos_int> > back;

Backtrace_nt_ml_comps4_Front(intrusive_ptr<Backtrace_nt_ml_comps4_Back<mfe_macrostate, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<mfecovar_macrostate, mfe_macrostate, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_block_dl_Back : public Backtrace_NT_Back_Base<mfecovar_macrostate, Klass, Value, pos_int>
{
pos_int t_0_i;
pos_int t_0_j;
Backtrace_nt_block_dl_Back(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_)
  : Backtrace_NT_Back_Base<mfecovar_macrostate, Klass, Value, pos_int>(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_block_dl(t_0_i, t_0_j));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_block_dl_Front : public Backtrace_Score<mfecovar_macrostate , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_block_dl_Back<mfe_macrostate, Value, pos_int> > back;

Backtrace_nt_block_dl_Front(intrusive_ptr<Backtrace_nt_block_dl_Back<mfe_macrostate, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<mfecovar_macrostate, mfe_macrostate, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_block_dlr_Back : public Backtrace_NT_Back_Base<mfecovar_macrostate, Klass, Value, pos_int>
{
pos_int t_0_i;
pos_int t_0_j;
Backtrace_nt_block_dlr_Back(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_)
  : Backtrace_NT_Back_Base<mfecovar_macrostate, Klass, Value, pos_int>(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_block_dlr(t_0_i, t_0_j));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_block_dlr_Front : public Backtrace_Score<mfecovar_macrostate , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_block_dlr_Back<mfe_macrostate, Value, pos_int> > back;

Backtrace_nt_block_dlr_Front(intrusive_ptr<Backtrace_nt_block_dlr_Back<mfe_macrostate, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<mfecovar_macrostate, mfe_macrostate, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_no_dl_no_ss_end_Back : public Backtrace_NT_Back_Base<mfecovar_macrostate, Klass, Value, pos_int>
{
pos_int t_0_i;
pos_int t_0_j;
Backtrace_nt_no_dl_no_ss_end_Back(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_)
  : Backtrace_NT_Back_Base<mfecovar_macrostate, Klass, Value, pos_int>(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_no_dl_no_ss_end(t_0_i, t_0_j));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_no_dl_no_ss_end_Front : public Backtrace_Score<mfecovar_macrostate , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_no_dl_no_ss_end_Back<mfe_macrostate, Value, pos_int> > back;

Backtrace_nt_no_dl_no_ss_end_Front(intrusive_ptr<Backtrace_nt_no_dl_no_ss_end_Back<mfe_macrostate, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<mfecovar_macrostate, mfe_macrostate, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_dl_or_ss_left_no_ss_end_Back : public Backtrace_NT_Back_Base<mfecovar_macrostate, Klass, Value, pos_int>
{
pos_int t_0_i;
pos_int t_0_j;
Backtrace_nt_dl_or_ss_left_no_ss_end_Back(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_)
  : Backtrace_NT_Back_Base<mfecovar_macrostate, Klass, Value, pos_int>(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_dl_or_ss_left_no_ss_end(t_0_i, t_0_j));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_dl_or_ss_left_no_ss_end_Front : public Backtrace_Score<mfecovar_macrostate , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_dl_or_ss_left_no_ss_end_Back<mfe_macrostate, Value, pos_int> > back;

Backtrace_nt_dl_or_ss_left_no_ss_end_Front(intrusive_ptr<Backtrace_nt_dl_or_ss_left_no_ss_end_Back<mfe_macrostate, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<mfecovar_macrostate, mfe_macrostate, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_no_dl_ss_end_Back : public Backtrace_NT_Back_Base<mfecovar_macrostate, Klass, Value, pos_int>
{
pos_int t_0_i;
pos_int t_0_j;
Backtrace_nt_no_dl_ss_end_Back(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_)
  : Backtrace_NT_Back_Base<mfecovar_macrostate, Klass, Value, pos_int>(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_no_dl_ss_end(t_0_i, t_0_j));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_no_dl_ss_end_Front : public Backtrace_Score<mfecovar_macrostate , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_no_dl_ss_end_Back<mfe_macrostate, Value, pos_int> > back;

Backtrace_nt_no_dl_ss_end_Front(intrusive_ptr<Backtrace_nt_no_dl_ss_end_Back<mfe_macrostate, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<mfecovar_macrostate, mfe_macrostate, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_dl_or_ss_left_ss_end_Back : public Backtrace_NT_Back_Base<mfecovar_macrostate, Klass, Value, pos_int>
{
pos_int t_0_i;
pos_int t_0_j;
Backtrace_nt_dl_or_ss_left_ss_end_Back(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_)
  : Backtrace_NT_Back_Base<mfecovar_macrostate, Klass, Value, pos_int>(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_dl_or_ss_left_ss_end(t_0_i, t_0_j));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_dl_or_ss_left_ss_end_Front : public Backtrace_Score<mfecovar_macrostate , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_dl_or_ss_left_ss_end_Back<mfe_macrostate, Value, pos_int> > back;

Backtrace_nt_dl_or_ss_left_ss_end_Front(intrusive_ptr<Backtrace_nt_dl_or_ss_left_ss_end_Back<mfe_macrostate, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<mfecovar_macrostate, mfe_macrostate, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_stack_Back : public Backtrace_NT_Back_Base<mfecovar_macrostate, Klass, Value, pos_int>
{
pos_int t_0_i;
pos_int t_0_j;
Backtrace_nt_stack_Back(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_)
  : Backtrace_NT_Back_Base<mfecovar_macrostate, Klass, Value, pos_int>(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_stack(t_0_i, t_0_j));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_stack_Front : public Backtrace_Score<mfecovar_macrostate , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_stack_Back<mfe_macrostate, Value, pos_int> > back;

Backtrace_nt_stack_Front(intrusive_ptr<Backtrace_nt_stack_Back<mfe_macrostate, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<mfecovar_macrostate, mfe_macrostate, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_hairpin_Back : public Backtrace_NT_Back_Base<mfecovar_macrostate, Klass, Value, pos_int>
{
pos_int t_0_i;
pos_int t_0_j;
Backtrace_nt_hairpin_Back(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_)
  : Backtrace_NT_Back_Base<mfecovar_macrostate, Klass, Value, pos_int>(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_hairpin(t_0_i, t_0_j));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_hairpin_Front : public Backtrace_Score<mfecovar_macrostate , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_hairpin_Back<mfe_macrostate, Value, pos_int> > back;

Backtrace_nt_hairpin_Front(intrusive_ptr<Backtrace_nt_hairpin_Back<mfe_macrostate, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<mfecovar_macrostate, mfe_macrostate, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_leftB_Back : public Backtrace_NT_Back_Base<mfecovar_macrostate, Klass, Value, pos_int>
{
pos_int t_0_i;
pos_int t_0_j;
Backtrace_nt_leftB_Back(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_)
  : Backtrace_NT_Back_Base<mfecovar_macrostate, Klass, Value, pos_int>(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_leftB(t_0_i, t_0_j));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_leftB_Front : public Backtrace_Score<mfecovar_macrostate , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_leftB_Back<mfe_macrostate, Value, pos_int> > back;

Backtrace_nt_leftB_Front(intrusive_ptr<Backtrace_nt_leftB_Back<mfe_macrostate, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<mfecovar_macrostate, mfe_macrostate, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_rightB_Back : public Backtrace_NT_Back_Base<mfecovar_macrostate, Klass, Value, pos_int>
{
pos_int t_0_i;
pos_int t_0_j;
Backtrace_nt_rightB_Back(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_)
  : Backtrace_NT_Back_Base<mfecovar_macrostate, Klass, Value, pos_int>(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_rightB(t_0_i, t_0_j));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_rightB_Front : public Backtrace_Score<mfecovar_macrostate , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_rightB_Back<mfe_macrostate, Value, pos_int> > back;

Backtrace_nt_rightB_Front(intrusive_ptr<Backtrace_nt_rightB_Back<mfe_macrostate, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<mfecovar_macrostate, mfe_macrostate, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_iloop_Back : public Backtrace_NT_Back_Base<mfecovar_macrostate, Klass, Value, pos_int>
{
pos_int t_0_i;
pos_int t_0_j;
Backtrace_nt_iloop_Back(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_)
  : Backtrace_NT_Back_Base<mfecovar_macrostate, Klass, Value, pos_int>(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_iloop(t_0_i, t_0_j));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_iloop_Front : public Backtrace_Score<mfecovar_macrostate , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_iloop_Back<mfe_macrostate, Value, pos_int> > back;

Backtrace_nt_iloop_Front(intrusive_ptr<Backtrace_nt_iloop_Back<mfe_macrostate, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<mfecovar_macrostate, mfe_macrostate, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

    List_Ref<std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > > > bt_proxy_nt_struct();
    List_Ref<std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > > > bt_proxy_nt_left_unpaired(unsigned int t_0_i);
    List_Ref<std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > > > bt_proxy_nt_left_dangle(unsigned int t_0_i);
    List_Ref<std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > > > bt_proxy_nt_noleft_dangle(unsigned int t_0_i);
    List_Ref<std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > > > bt_proxy_nt_edanglel(unsigned int t_0_i, unsigned int t_0_j);
    List_Ref<std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > > > bt_proxy_nt_edangler(unsigned int t_0_i, unsigned int t_0_j);
    List_Ref<std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > > > bt_proxy_nt_edanglelr(unsigned int t_0_i, unsigned int t_0_j);
    List_Ref<std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > > > bt_proxy_nt_nodangle(unsigned int t_0_i, unsigned int t_0_j);
    List_Ref<std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > > > bt_proxy_nt_strong(unsigned int t_0_i, unsigned int t_0_j);
    List_Ref<std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > > > bt_proxy_nt_weak(unsigned int t_0_i, unsigned int t_0_j);
    List_Ref<std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > > > bt_proxy_nt_multiloop(unsigned int t_0_i, unsigned int t_0_j);
    List_Ref<std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > > > bt_proxy_nt_ml_comps1(unsigned int t_0_i, unsigned int t_0_j);
    List_Ref<std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > > > bt_proxy_nt_ml_comps2(unsigned int t_0_i, unsigned int t_0_j);
    List_Ref<std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > > > bt_proxy_nt_ml_comps3(unsigned int t_0_i, unsigned int t_0_j);
    List_Ref<std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > > > bt_proxy_nt_ml_comps4(unsigned int t_0_i, unsigned int t_0_j);
    List_Ref<std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > > > bt_proxy_nt_block_dl(unsigned int t_0_i, unsigned int t_0_j);
    List_Ref<std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > > > bt_proxy_nt_block_dlr(unsigned int t_0_i, unsigned int t_0_j);
    List_Ref<std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > > > bt_proxy_nt_no_dl_no_ss_end(unsigned int t_0_i, unsigned int t_0_j);
    List_Ref<std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > > > bt_proxy_nt_dl_or_ss_left_no_ss_end(unsigned int t_0_i, unsigned int t_0_j);
    List_Ref<std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > > > bt_proxy_nt_no_dl_ss_end(unsigned int t_0_i, unsigned int t_0_j);
    List_Ref<std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > > > bt_proxy_nt_dl_or_ss_left_ss_end(unsigned int t_0_i, unsigned int t_0_j);
    List_Ref<std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > > > bt_proxy_nt_stack(unsigned int t_0_i, unsigned int t_0_j);
    std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > >  bt_proxy_nt_hairpin(unsigned int t_0_i, unsigned int t_0_j);
    List_Ref<std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > > > bt_proxy_nt_leftB(unsigned int t_0_i, unsigned int t_0_j);
    List_Ref<std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > > > bt_proxy_nt_rightB(unsigned int t_0_i, unsigned int t_0_j);
    List_Ref<std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > > > bt_proxy_nt_iloop(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  bt_nt_block_dl(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  bt_nt_block_dlr(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  bt_nt_dl_or_ss_left_no_ss_end(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  bt_nt_dl_or_ss_left_ss_end(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  bt_nt_edanglel(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  bt_nt_edanglelr(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  bt_nt_edangler(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  bt_nt_hairpin(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  bt_nt_iloop(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  bt_nt_leftB(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  bt_nt_left_dangle(unsigned int t_0_i);
    intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  bt_nt_left_unpaired(unsigned int t_0_i);
    intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  bt_nt_ml_comps1(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  bt_nt_ml_comps2(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  bt_nt_ml_comps3(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  bt_nt_ml_comps4(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  bt_nt_multiloop(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  bt_nt_no_dl_no_ss_end(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  bt_nt_no_dl_ss_end(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  bt_nt_nodangle(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  bt_nt_noleft_dangle(unsigned int t_0_i);
    intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  bt_nt_rightB(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  bt_nt_stack(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  bt_nt_strong(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  bt_nt_struct();
    intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  bt_nt_weak(unsigned int t_0_i, unsigned int t_0_j);

    intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  acomb_bt_r(intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  param_0, const TUSubsequence & param_1, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  param_2);
    intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  addss_bt_r(intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  param_0, const TUSubsequence & param_1);
    intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  ambd_bt_r(intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  param_0, const TUSubsequence & param_1, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  param_2);
    intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  ambd_Pr_bt_r(intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  param_0, const TUSubsequence & param_1, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  param_2);
    intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  bl_bt_r(const TUSubsequence & param_0, const TUSubsequence & param_1, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  param_2, const TUSubsequence & param_3);
    intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  br_bt_r(const TUSubsequence & param_0, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  param_1, const TUSubsequence & param_2, const TUSubsequence & param_3);
    intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  cadd_bt_r(intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  param_0, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  param_1);
    intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  cadd_Pr_bt_r(intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  param_0, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  param_1);
    intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  cadd_Pr_Pr_bt_r(intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  param_0, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  param_1);
    intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  cadd_Pr_Pr_Pr_bt_r(intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  param_0, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  param_1);
    intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  combine_bt_r(intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  param_0, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  param_1);
    intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  drem_bt_r(const TUSubsequence & param_0, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  param_1, const TUSubsequence & param_2);
    intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  edl_bt_r(const TUSubsequence & param_0, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  param_1, const TUSubsequence & param_2);
    intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  edlr_bt_r(const TUSubsequence & param_0, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  param_1, const TUSubsequence & param_2);
    intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  edr_bt_r(const TUSubsequence & param_0, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  param_1, const TUSubsequence & param_2);
    List_Ref<intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > > h_bt_r(List_Ref<intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > > param_0);
    intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  hl_bt_r(const TUSubsequence & param_0, const TUSubsequence & param_1, const TUSubsequence & param_2);
    intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  il_bt_r(const TUSubsequence & param_0, const TUSubsequence & param_1, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  param_2, const TUSubsequence & param_3, const TUSubsequence & param_4);
    intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  incl_bt_r(intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  param_0);
    intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  ml_bt_r(const TUSubsequence & param_0, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  param_1, const TUSubsequence & param_2);
    intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  mladl_bt_r(const TUSubsequence & param_0, const TUSubsequence & param_1, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  param_2, const TUSubsequence & param_3);
    intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  mladldr_bt_r(const TUSubsequence & param_0, const TUSubsequence & param_1, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  param_2, const TUSubsequence & param_3, const TUSubsequence & param_4);
    intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  mladlr_bt_r(const TUSubsequence & param_0, const TUSubsequence & param_1, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  param_2, const TUSubsequence & param_3, const TUSubsequence & param_4);
    intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  mladr_bt_r(const TUSubsequence & param_0, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  param_1, const TUSubsequence & param_2, const TUSubsequence & param_3);
    intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  mldl_bt_r(const TUSubsequence & param_0, const TUSubsequence & param_1, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  param_2, const TUSubsequence & param_3);
    intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  mldladr_bt_r(const TUSubsequence & param_0, const TUSubsequence & param_1, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  param_2, const TUSubsequence & param_3, const TUSubsequence & param_4);
    intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  mldlr_bt_r(const TUSubsequence & param_0, const TUSubsequence & param_1, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  param_2, const TUSubsequence & param_3, const TUSubsequence & param_4);
    intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  mldr_bt_r(const TUSubsequence & param_0, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  param_1, const TUSubsequence & param_2, const TUSubsequence & param_3);
    intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  nil_bt_r(const TUSubsequence & param_0);
    intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  sadd_bt_r(const TUSubsequence & param_0, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  param_1);
    intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  sr_bt_r(const TUSubsequence & param_0, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  param_1, const TUSubsequence & param_2);
    intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  ssadd_bt_r(const TUSubsequence & param_0, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  param_1);
    intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  trafo_bt_r(intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  param_0);


    std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > >  acomb_bt(const std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > > & p_le, const TUSubsequence & p_b, const std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > > & p_re);
    std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > >  addss_bt(const std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > > & p_e, const TUSubsequence & p_rb);
    std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > >  ambd_bt(const std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > > & p_le, const TUSubsequence & p_b, const std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > > & p_re);
    std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > >  ambd_Pr_bt(const std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > > & p_le, const TUSubsequence & p_b, const std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > > & p_re);
    std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > >  bl_bt(const TUSubsequence & p_lb, const TUSubsequence & p_lregion, const std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > > & p_e, const TUSubsequence & p_rb);
    std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > >  br_bt(const TUSubsequence & p_lb, const std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > > & p_e, const TUSubsequence & p_rregion, const TUSubsequence & p_rb);
    std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > >  cadd_bt(const std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > > & p_le, const std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > > & p_re);
    std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > >  cadd_Pr_bt(const std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > > & p_le, const std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > > & p_re);
    std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > >  cadd_Pr_Pr_bt(const std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > > & p_le, const std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > > & p_re);
    std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > >  cadd_Pr_Pr_Pr_bt(const std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > > & p_le, const std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > > & p_re);
    std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > >  combine_bt(const std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > > & p_le, const std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > > & p_re);
    std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > >  drem_bt(const TUSubsequence & p_lloc, const std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > > & p_e, const TUSubsequence & p_rloc);
    std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > >  edl_bt(const TUSubsequence & p_lb, const std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > > & p_e, const TUSubsequence & p_rloc);
    std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > >  edlr_bt(const TUSubsequence & p_lb, const std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > > & p_e, const TUSubsequence & p_rb);
    std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > >  edr_bt(const TUSubsequence & p_lloc, const std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > > & p_e, const TUSubsequence & p_rb);
    List_Ref<std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > > > h_bt(List_Ref<std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > > > i, mfecovar_macrostate &  left);
    List_Ref<std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > > > h_bt(List_Ref<std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > > > i);
    std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > >  hl_bt(const TUSubsequence & p_lb, const TUSubsequence & p_region, const TUSubsequence & p_rb);
    std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > >  il_bt(const TUSubsequence & p_lb, const TUSubsequence & p_lregion, const std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > > & p_e, const TUSubsequence & p_rregion, const TUSubsequence & p_rb);
    std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > >  incl_bt(const std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > > & p_e);
    std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > >  ml_bt(const TUSubsequence & p_lb, const std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > > & p_e, const TUSubsequence & p_rb);
    std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > >  mladl_bt(const TUSubsequence & p_lb, const TUSubsequence & p_dl, const std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > > & p_e, const TUSubsequence & p_rb);
    std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > >  mladldr_bt(const TUSubsequence & p_lb, const TUSubsequence & p_dl, const std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > > & p_e, const TUSubsequence & p_dr, const TUSubsequence & p_rb);
    std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > >  mladlr_bt(const TUSubsequence & p_lb, const TUSubsequence & p_dl, const std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > > & p_e, const TUSubsequence & p_dr, const TUSubsequence & p_rb);
    std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > >  mladr_bt(const TUSubsequence & p_lb, const std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > > & p_e, const TUSubsequence & p_dr, const TUSubsequence & p_rb);
    std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > >  mldl_bt(const TUSubsequence & p_lb, const TUSubsequence & p_dl, const std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > > & p_e, const TUSubsequence & p_rb);
    std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > >  mldladr_bt(const TUSubsequence & p_lb, const TUSubsequence & p_dl, const std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > > & p_e, const TUSubsequence & p_dr, const TUSubsequence & p_rb);
    std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > >  mldlr_bt(const TUSubsequence & p_lb, const TUSubsequence & p_dl, const std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > > & p_e, const TUSubsequence & p_dr, const TUSubsequence & p_rb);
    std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > >  mldr_bt(const TUSubsequence & p_lb, const std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > > & p_e, const TUSubsequence & p_dr, const TUSubsequence & p_rb);
    std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > >  nil_bt(const TUSubsequence & p_loc);
    std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > >  sadd_bt(const TUSubsequence & p_lb, const std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > > & p_e);
    std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > >  sr_bt(const TUSubsequence & p_lb, const std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > > & p_e, const TUSubsequence & p_rb);
    std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > >  ssadd_bt(const TUSubsequence & p_lb, const std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > > & p_e);
    std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > >  trafo_bt(const std::pair<mfecovar_macrostate, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > > & p_e);

template <typename Value>   void  print_result(std::ostream &out, Value& res)

{
}
   intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  backtrack()
{
  return bt_nt_struct();
}
template <typename Value>   void  print_backtrack(std::ostream &out, Value& value)

{
intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> >  bt    = backtrack();
intrusive_ptr<Backtrace_List<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > l =
  boost::dynamic_pointer_cast<Backtrace_List<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int> > (bt);
assert(!bt || (bt && l));
if (l) {
for (Backtrace_List<std::pair<std::pair<String, Shape> , answer_ali_pfunc_macrostate> , unsigned int>::iterator i = l->begin();
     i != l->end(); ++i)
  (*i)->print(out);
}
}
   void  print_subopt(std::ostream &out, int  delta = 0) {}

};

#ifndef NO_GAPC_TYPEDEFS
namespace gapc {
  typedef mfe_macrostate class_name;
  typedef mfecovar_macrostate return_type;
}
#endif

#endif

