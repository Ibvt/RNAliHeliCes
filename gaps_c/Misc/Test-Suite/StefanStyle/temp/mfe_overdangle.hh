
// A dynamic programming evaluator generated by GAP-C.
// 
//   GAP-C version:
//     bellmansgapc-2013.05.02
// 
//   GAP-C call:
//     /home/jhuang/local/gapc/bin/gapc -I ../../../../ -p alg_ali_mfe_overdangle * (alg_ali_dotBracket * alg_ali_shapeX * alg_ali_pfunc_overdangle) ../../../../ali_overdangle.gap --kbacktrace --no-coopt -o mfe_overdangle.cc 
// 
// 


#ifndef mfe_overdangle_hh
#define mfe_overdangle_hh

#include "rtlib/adp.hh"

typedef Basic_Subsequence<M_Char, unsigned> TUSubsequence;

typedef Shape shape_t;
#include <rtlib/subopt.hh>
#include "rna.hh"
#include "Extensions/alifold.hh"
#include "Extensions/mfesubopt.hh"
#include "Extensions/probabilities.hh"
#include "Extensions/typesRNAfolding.hh"
#include "Extensions/shapes.hh"

#include "Extensions/rnaoptions.hh"

class mfe_overdangle {

  public:
Basic_Sequence<M_Char> t_0_seq;
unsigned int t_0_left_most;
unsigned int t_0_right_most;

mfecovar mfecovar_zero;

class dangle_table_t {

private:

unsigned int t_0_left_most;
unsigned int t_0_right_most;
std::vector<mfecovar > array;
std::vector<bool> tabulated;
unsigned int t_0_n;
mfecovar zero;
unsigned int size()
{
  return (1 * ((((t_0_n * (t_0_n + 1)) / 2) + t_0_n) + 1));
}


public:

dangle_table_t()
{
  empty(zero);
}

void init(unsigned int t_0_n_, const std::string &tname)
{
t_0_n = t_0_n_;
t_0_left_most = 0;
t_0_right_most = t_0_n;
unsigned int newsize = size();
array.resize(newsize);
tabulated.clear();
tabulated.resize(newsize);
}
bool is_tabulated(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 5))
    {
      return true;
    }

  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  return tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void clear() { tabulated.clear(); }
mfecovar &  get(unsigned int t_0_i, unsigned int t_0_j)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 5))
    {
      return zero;
    }

  assert( tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))]);
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  return array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void set(unsigned int t_0_i, unsigned int t_0_j, const mfecovar & e)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 5))
    {
      assert( 0);
    }

  assert( !is_tabulated(t_0_i, t_0_j));
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = e;
  tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = true;
}


};
dangle_table_t dangle_table;


class iloop_table_t {

private:

unsigned int t_0_left_most;
unsigned int t_0_right_most;
std::vector<mfecovar > array;
std::vector<bool> tabulated;
unsigned int t_0_n;
mfecovar zero;
unsigned int size()
{
  return (1 * ((((t_0_n * (t_0_n + 1)) / 2) + t_0_n) + 1));
}


public:

iloop_table_t()
{
  empty(zero);
}

void init(unsigned int t_0_n_, const std::string &tname)
{
t_0_n = t_0_n_;
t_0_left_most = 0;
t_0_right_most = t_0_n;
unsigned int newsize = size();
array.resize(newsize);
tabulated.clear();
tabulated.resize(newsize);
}
bool is_tabulated(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 9))
    {
      return true;
    }

  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  return tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void clear() { tabulated.clear(); }
mfecovar &  get(unsigned int t_0_i, unsigned int t_0_j)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 9))
    {
      return zero;
    }

  assert( tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))]);
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  return array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void set(unsigned int t_0_i, unsigned int t_0_j, const mfecovar & e)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 9))
    {
      assert( 0);
    }

  assert( !is_tabulated(t_0_i, t_0_j));
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = e;
  tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = true;
}


};
iloop_table_t iloop_table;


class ml_comps_table_t {

private:

unsigned int t_0_left_most;
unsigned int t_0_right_most;
std::vector<mfecovar > array;
std::vector<bool> tabulated;
unsigned int t_0_n;
mfecovar zero;
unsigned int size()
{
  return (1 * ((((t_0_n * (t_0_n + 1)) / 2) + t_0_n) + 1));
}


public:

ml_comps_table_t()
{
  empty(zero);
}

void init(unsigned int t_0_n_, const std::string &tname)
{
t_0_n = t_0_n_;
t_0_left_most = 0;
t_0_right_most = t_0_n;
unsigned int newsize = size();
array.resize(newsize);
tabulated.clear();
tabulated.resize(newsize);
}
bool is_tabulated(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 10))
    {
      return true;
    }

  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  return tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void clear() { tabulated.clear(); }
mfecovar &  get(unsigned int t_0_i, unsigned int t_0_j)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 10))
    {
      return zero;
    }

  assert( tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))]);
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  return array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void set(unsigned int t_0_i, unsigned int t_0_j, const mfecovar & e)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 10))
    {
      assert( 0);
    }

  assert( !is_tabulated(t_0_i, t_0_j));
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = e;
  tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = true;
}


};
ml_comps_table_t ml_comps_table;


class ml_comps1_table_t {

private:

unsigned int t_0_left_most;
unsigned int t_0_right_most;
std::vector<mfecovar > array;
std::vector<bool> tabulated;
unsigned int t_0_n;
mfecovar zero;
unsigned int size()
{
  return (1 * ((((t_0_n * (t_0_n + 1)) / 2) + t_0_n) + 1));
}


public:

ml_comps1_table_t()
{
  empty(zero);
}

void init(unsigned int t_0_n_, const std::string &tname)
{
t_0_n = t_0_n_;
t_0_left_most = 0;
t_0_right_most = t_0_n;
unsigned int newsize = size();
array.resize(newsize);
tabulated.clear();
tabulated.resize(newsize);
}
bool is_tabulated(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 5))
    {
      return true;
    }

  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  return tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void clear() { tabulated.clear(); }
mfecovar &  get(unsigned int t_0_i, unsigned int t_0_j)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 5))
    {
      return zero;
    }

  assert( tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))]);
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  return array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void set(unsigned int t_0_i, unsigned int t_0_j, const mfecovar & e)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 5))
    {
      assert( 0);
    }

  assert( !is_tabulated(t_0_i, t_0_j));
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = e;
  tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = true;
}


};
ml_comps1_table_t ml_comps1_table;


class strong_table_t {

private:

unsigned int t_0_left_most;
unsigned int t_0_right_most;
std::vector<mfecovar > array;
std::vector<bool> tabulated;
unsigned int t_0_n;
mfecovar zero;
unsigned int size()
{
  return (1 * ((((t_0_n * (t_0_n + 1)) / 2) + t_0_n) + 1));
}


public:

strong_table_t()
{
  empty(zero);
}

void init(unsigned int t_0_n_, const std::string &tname)
{
t_0_n = t_0_n_;
t_0_left_most = 0;
t_0_right_most = t_0_n;
unsigned int newsize = size();
array.resize(newsize);
tabulated.clear();
tabulated.resize(newsize);
}
bool is_tabulated(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 5))
    {
      return true;
    }

  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  return tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void clear() { tabulated.clear(); }
mfecovar &  get(unsigned int t_0_i, unsigned int t_0_j)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 5))
    {
      return zero;
    }

  assert( tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))]);
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  return array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void set(unsigned int t_0_i, unsigned int t_0_j, const mfecovar & e)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 5))
    {
      assert( 0);
    }

  assert( !is_tabulated(t_0_i, t_0_j));
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = e;
  tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = true;
}


};
strong_table_t strong_table;


class struct_table_t {

private:

unsigned int t_0_left_most;
unsigned int t_0_right_most;
std::vector<mfecovar > array;
std::vector<bool> tabulated;
unsigned int t_0_n;
mfecovar zero;
unsigned int size()
{
  return (1 * ((t_0_n + 1) * 1));
}


public:

struct_table_t()
{
  empty(zero);
}

void init(unsigned int t_0_n_, const std::string &tname)
{
t_0_n = t_0_n_;
t_0_left_most = 0;
t_0_right_most = t_0_n;
unsigned int newsize = size();
array.resize(newsize);
tabulated.clear();
tabulated.resize(newsize);
}
bool is_tabulated(unsigned int t_0_i)
{
  unsigned int t_0_j = t_0_n;
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if ((t_0_j < (t_0_n - 0)))
    {
      return true;
    }

  unsigned int t_0_real_j = (t_0_n - t_0_j);
  return tabulated[(0 + (1 * (t_0_i + (t_0_real_j * (t_0_n + 1)))))];
}


void clear() { tabulated.clear(); }
mfecovar &  get(unsigned int t_0_i)
{
  unsigned int t_0_j = t_0_n;
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if ((t_0_j < (t_0_n - 0)))
    {
      return zero;
    }

  unsigned int t_0_real_j = (t_0_n - t_0_j);
  assert( tabulated[(0 + (1 * (t_0_i + (t_0_real_j * (t_0_n + 1)))))]);
  assert( ((0 + (1 * (t_0_i + (t_0_real_j * (t_0_n + 1))))) < size()));
  return array[(0 + (1 * (t_0_i + (t_0_real_j * (t_0_n + 1)))))];
}


void set(unsigned int t_0_i, const mfecovar & e)
{
  unsigned int t_0_j = t_0_n;
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if ((t_0_j < (t_0_n - 0)))
    {
      return;
    }

  unsigned int t_0_real_j = (t_0_n - t_0_j);
  assert( !is_tabulated(t_0_i));
  assert( ((0 + (1 * (t_0_i + (t_0_real_j * (t_0_n + 1))))) < size()));
  array[(0 + (1 * (t_0_i + (t_0_real_j * (t_0_n + 1)))))] = e;
  tabulated[(0 + (1 * (t_0_i + (t_0_real_j * (t_0_n + 1)))))] = true;
}


};
struct_table_t struct_table;


class weak_table_t {

private:

unsigned int t_0_left_most;
unsigned int t_0_right_most;
std::vector<mfecovar > array;
std::vector<bool> tabulated;
unsigned int t_0_n;
mfecovar zero;
unsigned int size()
{
  return (1 * ((((t_0_n * (t_0_n + 1)) / 2) + t_0_n) + 1));
}


public:

weak_table_t()
{
  empty(zero);
}

void init(unsigned int t_0_n_, const std::string &tname)
{
t_0_n = t_0_n_;
t_0_left_most = 0;
t_0_right_most = t_0_n;
unsigned int newsize = size();
array.resize(newsize);
tabulated.clear();
tabulated.resize(newsize);
}
bool is_tabulated(unsigned int t_0_i, unsigned int t_0_j)
{
  if (((t_0_j - t_0_i) < 5))
    {
      return true;
    }

  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  return tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void clear() { tabulated.clear(); }
mfecovar &  get(unsigned int t_0_i, unsigned int t_0_j)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 5))
    {
      return zero;
    }

  assert( tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))]);
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  return array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))];
}


void set(unsigned int t_0_i, unsigned int t_0_j, const mfecovar & e)
{
  assert( (t_0_i <= t_0_j));
  assert( (t_0_j <= t_0_n));
  if (((t_0_j - t_0_i) < 5))
    {
      assert( 0);
    }

  assert( !is_tabulated(t_0_i, t_0_j));
  assert( ((0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i))) < size()));
  array[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = e;
  tabulated[(0 + (1 * (((t_0_j * (t_0_j + 1)) / 2) + t_0_i)))] = true;
}


};
weak_table_t weak_table;



void init(const gapc::Opts &opts)
{
const std::vector<std::pair<const char *, unsigned> > &inp = opts.inputs;
if(inp.size() != 1)
  throw gapc::OptException("Number of input sequences does not match.");

  t_0_seq.copy(inp[0].first, inp[0].second);
char_to_rna(t_0_seq);
  dangle_table.init( t_0_seq.size(), "dangle_table");
  iloop_table.init( t_0_seq.size(), "iloop_table");
  ml_comps_table.init( t_0_seq.size(), "ml_comps_table");
  ml_comps1_table.init( t_0_seq.size(), "ml_comps1_table");
  strong_table.init( t_0_seq.size(), "strong_table");
  struct_table.init( t_0_seq.size(), "struct_table");
  weak_table.init( t_0_seq.size(), "weak_table");
empty(mfecovar_zero);

t_0_left_most = 0;
t_0_right_most = t_0_seq.size();
}

  private:
    mfecovar &  nt_dangle(unsigned int t_0_i, unsigned int t_0_j);
    mfecovar nt_hairpin(unsigned int t_0_i, unsigned int t_0_j);
    mfecovar &  nt_iloop(unsigned int t_0_i, unsigned int t_0_j);
    mfecovar nt_leftB(unsigned int t_0_i, unsigned int t_0_j);
    mfecovar &  nt_ml_comps(unsigned int t_0_i, unsigned int t_0_j);
    mfecovar &  nt_ml_comps1(unsigned int t_0_i, unsigned int t_0_j);
    mfecovar nt_multiloop(unsigned int t_0_i, unsigned int t_0_j);
    mfecovar nt_rightB(unsigned int t_0_i, unsigned int t_0_j);
    mfecovar nt_stack(unsigned int t_0_i, unsigned int t_0_j);
    mfecovar &  nt_strong(unsigned int t_0_i, unsigned int t_0_j);
    mfecovar &  nt_struct(unsigned int t_0_i);
    mfecovar &  nt_weak(unsigned int t_0_i, unsigned int t_0_j);

    mfecovar addss(const mfecovar & x, const TUSubsequence & r);
    mfecovar bl(const TUSubsequence & lb, const TUSubsequence & lr, const mfecovar & x, const TUSubsequence & rb);
    mfecovar br(const TUSubsequence & lb, const mfecovar & x, const TUSubsequence & rr, const TUSubsequence & rb);
    mfecovar cadd(const mfecovar & x, const mfecovar & y);
    mfecovar drem(const TUSubsequence & lb, const mfecovar & x, const TUSubsequence & rb);
    mfecovar h(mfecovar i);
    mfecovar hl(const TUSubsequence & lb, const TUSubsequence & r, const TUSubsequence & rb);
    mfecovar il(const TUSubsequence & lb, const TUSubsequence & lr, const mfecovar & x, const TUSubsequence & rr, const TUSubsequence & rb);
    mfecovar incl(const mfecovar & x);
    mfecovar ml(const TUSubsequence & lb, const mfecovar & x, const TUSubsequence & rb);
    mfecovar nil(const TUSubsequence & n);
    mfecovar sadd(const TUSubsequence & lb, const mfecovar & x);
    mfecovar sr(const TUSubsequence & lb, const mfecovar & x, const TUSubsequence & rb);


 public:
   void cyk();

 public:
   mfecovar &  run()
{
  return nt_struct(t_0_left_most);
}
void print_stats(std::ostream &o)
{
#ifdef STATS
      o << "\n\nN = " << seq.size() << '\n';
      dangle_table.print_stats(o, "dangle_table");
      iloop_table.print_stats(o, "iloop_table");
      ml_comps_table.print_stats(o, "ml_comps_table");
      ml_comps1_table.print_stats(o, "ml_comps1_table");
      strong_table.print_stats(o, "strong_table");
      struct_table.print_stats(o, "struct_table");
      weak_table.print_stats(o, "weak_table");
#endif
}

template <typename Value, typename pos_int>
struct Backtrace_addss : Backtrace_Score<mfecovar, Value, pos_int> {
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e;
      TUSubsequence arg_p_p_rb;

Backtrace_addss(intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_, TUSubsequence arg_p_p_rb_)
 : arg_p_p_e(arg_p_p_e_), arg_p_p_rb(arg_p_p_rb_)
{}

~Backtrace_addss()
{
erase(arg_p_p_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      std::pair<String, shape_t>  addss_l(const std::pair<String, shape_t> & p_e, const TUSubsequence & p_rb)
      {
        String l_0 = p_e.first;
        TUSubsequence l_1 = p_rb;
        shape_t r_0 = p_e.second;
        TUSubsequence r_1 = p_rb;
        String ret_left = addss_l_l(l_0, l_1);
        shape_t ret_right = addss_l_r(r_0, r_1);
        std::pair<String, shape_t>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      String addss_l_l(const String & e, const TUSubsequence & rb)
      {
#line 184 ""
        String res;
        append( res, e);
        append( res, '.', size(rb));
        return res;
#line 705 ""
      }


      shape_t addss_l_r(shape_t x, const TUSubsequence & rb)
      {
#line 974 ""
        if (( ( (shapelevel() == 1) )  &&  ( (back(x) != '_') ) ))
          {
            return (x + shape_t('_'));
          }

        else
          {
            return x;
          }

#line 722 ""
      }


      double addss_r(double x, const TUSubsequence & r)
      {
#line 1688 ""
        return ((x * scale((r.j - r.i))) * mk_pf((ss_energy(r) / float(rows(r)))));
#line 730 ""
      }


      std::pair<std::pair<String, shape_t> , double>  addss(const std::pair<std::pair<String, shape_t> , double> & p_p_e, const TUSubsequence & p_p_rb)
      {
        std::pair<String, shape_t>  l_0 = p_p_e.first;
        TUSubsequence l_1 = p_p_rb;
        double r_0 = p_p_e.second;
        TUSubsequence r_1 = p_p_rb;
        std::pair<String, shape_t>  ret_left = addss_l(l_0, l_1);
        double ret_right = addss_r(r_0, r_1);
        std::pair<std::pair<String, shape_t> , double>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_p_p_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_p_p_e);
        if (!arg_p_p_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_bt = arg_p_p_e;
          intrusive_ptr<Eval_List<Value> > arg_p_p_e_elist = evaluate(arg_p_p_e_bt);
          for (typename Eval_List<Value>::iterator arg_p_p_e_elem_itr = arg_p_p_e_elist->begin(); arg_p_p_e_elem_itr != arg_p_p_e_elist->end(); ++ arg_p_p_e_elem_itr) {
            std::pair<std::pair<String, shape_t> , double>  arg_p_p_e_elem = *arg_p_p_e_elem_itr;
            std::pair<std::pair<String, shape_t> , double>  ret = addss(arg_p_p_e_elem, arg_p_p_rb);
            push_back( answer, ret);
          }
          erase( arg_p_p_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_p_p_e_bt_itr = arg_p_p_e_t->begin(); arg_p_p_e_bt_itr != arg_p_p_e_t->end(); ++ arg_p_p_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_bt = *arg_p_p_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_p_p_e_elist = evaluate(arg_p_p_e_bt);
          for (typename Eval_List<Value>::iterator arg_p_p_e_elem_itr = arg_p_p_e_elist->begin(); arg_p_p_e_elem_itr != arg_p_p_e_elist->end(); ++ arg_p_p_e_elem_itr) {
            std::pair<std::pair<String, shape_t> , double>  arg_p_p_e_elem = *arg_p_p_e_elem_itr;
            std::pair<std::pair<String, shape_t> , double>  ret = addss(arg_p_p_e_elem, arg_p_p_rb);
            push_back( answer, ret);
          }
          erase( arg_p_p_e_elist);
        }
        erase( arg_p_p_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_bl : Backtrace_Score<mfecovar, Value, pos_int> {
      TUSubsequence arg_p_p_lb;
      TUSubsequence arg_p_p_lregion;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e;
      TUSubsequence arg_p_p_rb;

Backtrace_bl(TUSubsequence arg_p_p_lb_, TUSubsequence arg_p_p_lregion_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_, TUSubsequence arg_p_p_rb_)
 : arg_p_p_lb(arg_p_p_lb_), arg_p_p_lregion(arg_p_p_lregion_), arg_p_p_e(arg_p_p_e_), arg_p_p_rb(arg_p_p_rb_)
{}

~Backtrace_bl()
{
erase(arg_p_p_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      std::pair<String, shape_t>  bl_l(const TUSubsequence & p_lb, const TUSubsequence & p_lregion, const std::pair<String, shape_t> & p_e, const TUSubsequence & p_rb)
      {
        TUSubsequence l_0 = p_lb;
        TUSubsequence l_1 = p_lregion;
        String l_2 = p_e.first;
        TUSubsequence l_3 = p_rb;
        TUSubsequence r_0 = p_lb;
        TUSubsequence r_1 = p_lregion;
        shape_t r_2 = p_e.second;
        TUSubsequence r_3 = p_rb;
        String ret_left = bl_l_l(l_0, l_1, l_2, l_3);
        shape_t ret_right = bl_l_r(r_0, r_1, r_2, r_3);
        std::pair<String, shape_t>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      String bl_l_l(const TUSubsequence & lb, const TUSubsequence & lregion, const String & e, const TUSubsequence & rb)
      {
#line 120 ""
        String res;
        append( res, '(');
        append( res, '.', size(lregion));
        append( res, e);
        append( res, ')');
        return res;
#line 826 ""
      }


      shape_t bl_l_r(const TUSubsequence & lb, const TUSubsequence & lregion, shape_t x, const TUSubsequence & rb)
      {
#line 901 ""
        if ((shapelevel() <= 3))
        {
          shape_t res;
          append( res, openParen);
          if ((shapelevel() <= 2))
            {
              append( res, '_');
            }

          append( res, x);
          append( res, closeParen);
          return res;
        }

        else
          {
            return x;
          }

#line 852 ""
      }


      double bl_r(const TUSubsequence & lb, const TUSubsequence & lr, double x, const TUSubsequence & rb)
      {
#line 1663 ""
        return ((x * scale(((2 + lr.j) - lr.i))) * mk_pf(((bl_energy(lr, rb) / float(rows(lb))) + covscore(lb, lb.i, rb.i))));
#line 860 ""
      }


      std::pair<std::pair<String, shape_t> , double>  bl(const TUSubsequence & p_p_lb, const TUSubsequence & p_p_lregion, const std::pair<std::pair<String, shape_t> , double> & p_p_e, const TUSubsequence & p_p_rb)
      {
        TUSubsequence l_0 = p_p_lb;
        TUSubsequence l_1 = p_p_lregion;
        std::pair<String, shape_t>  l_2 = p_p_e.first;
        TUSubsequence l_3 = p_p_rb;
        TUSubsequence r_0 = p_p_lb;
        TUSubsequence r_1 = p_p_lregion;
        double r_2 = p_p_e.second;
        TUSubsequence r_3 = p_p_rb;
        std::pair<String, shape_t>  ret_left = bl_l(l_0, l_1, l_2, l_3);
        double ret_right = bl_r(r_0, r_1, r_2, r_3);
        std::pair<std::pair<String, shape_t> , double>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_p_p_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_p_p_e);
        if (!arg_p_p_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_bt = arg_p_p_e;
          intrusive_ptr<Eval_List<Value> > arg_p_p_e_elist = evaluate(arg_p_p_e_bt);
          for (typename Eval_List<Value>::iterator arg_p_p_e_elem_itr = arg_p_p_e_elist->begin(); arg_p_p_e_elem_itr != arg_p_p_e_elist->end(); ++ arg_p_p_e_elem_itr) {
            std::pair<std::pair<String, shape_t> , double>  arg_p_p_e_elem = *arg_p_p_e_elem_itr;
            std::pair<std::pair<String, shape_t> , double>  ret = bl(arg_p_p_lb, arg_p_p_lregion, arg_p_p_e_elem, arg_p_p_rb);
            push_back( answer, ret);
          }
          erase( arg_p_p_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_p_p_e_bt_itr = arg_p_p_e_t->begin(); arg_p_p_e_bt_itr != arg_p_p_e_t->end(); ++ arg_p_p_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_bt = *arg_p_p_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_p_p_e_elist = evaluate(arg_p_p_e_bt);
          for (typename Eval_List<Value>::iterator arg_p_p_e_elem_itr = arg_p_p_e_elist->begin(); arg_p_p_e_elem_itr != arg_p_p_e_elist->end(); ++ arg_p_p_e_elem_itr) {
            std::pair<std::pair<String, shape_t> , double>  arg_p_p_e_elem = *arg_p_p_e_elem_itr;
            std::pair<std::pair<String, shape_t> , double>  ret = bl(arg_p_p_lb, arg_p_p_lregion, arg_p_p_e_elem, arg_p_p_rb);
            push_back( answer, ret);
          }
          erase( arg_p_p_e_elist);
        }
        erase( arg_p_p_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_br : Backtrace_Score<mfecovar, Value, pos_int> {
      TUSubsequence arg_p_p_lb;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e;
      TUSubsequence arg_p_p_rregion;
      TUSubsequence arg_p_p_rb;

Backtrace_br(TUSubsequence arg_p_p_lb_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_, TUSubsequence arg_p_p_rregion_, TUSubsequence arg_p_p_rb_)
 : arg_p_p_lb(arg_p_p_lb_), arg_p_p_e(arg_p_p_e_), arg_p_p_rregion(arg_p_p_rregion_), arg_p_p_rb(arg_p_p_rb_)
{}

~Backtrace_br()
{
erase(arg_p_p_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      std::pair<String, shape_t>  br_l(const TUSubsequence & p_lb, const std::pair<String, shape_t> & p_e, const TUSubsequence & p_rregion, const TUSubsequence & p_rb)
      {
        TUSubsequence l_0 = p_lb;
        String l_1 = p_e.first;
        TUSubsequence l_2 = p_rregion;
        TUSubsequence l_3 = p_rb;
        TUSubsequence r_0 = p_lb;
        shape_t r_1 = p_e.second;
        TUSubsequence r_2 = p_rregion;
        TUSubsequence r_3 = p_rb;
        String ret_left = br_l_l(l_0, l_1, l_2, l_3);
        shape_t ret_right = br_l_r(r_0, r_1, r_2, r_3);
        std::pair<String, shape_t>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      String br_l_l(const TUSubsequence & lb, const String & e, const TUSubsequence & rregion, const TUSubsequence & rb)
      {
#line 129 ""
        String res;
        append( res, '(');
        append( res, e);
        append( res, '.', size(rregion));
        append( res, ')');
        return res;
#line 960 ""
      }


      shape_t br_l_r(const TUSubsequence & lb, shape_t x, const TUSubsequence & rregion, const TUSubsequence & rb)
      {
#line 914 ""
        if ((shapelevel() <= 3))
        {
          shape_t res;
          append( res, openParen);
          append( res, x);
          if ((shapelevel() <= 2))
            {
              append( res, '_');
            }

          append( res, closeParen);
          return res;
        }

        else
          {
            return x;
          }

#line 986 ""
      }


      double br_r(const TUSubsequence & lb, double x, const TUSubsequence & rr, const TUSubsequence & rb)
      {
#line 1666 ""
        return ((x * scale(((2 + rr.j) - rr.i))) * mk_pf(((br_energy(lb, rr) / float(rows(lb))) + covscore(lb, lb.i, rb.i))));
#line 994 ""
      }


      std::pair<std::pair<String, shape_t> , double>  br(const TUSubsequence & p_p_lb, const std::pair<std::pair<String, shape_t> , double> & p_p_e, const TUSubsequence & p_p_rregion, const TUSubsequence & p_p_rb)
      {
        TUSubsequence l_0 = p_p_lb;
        std::pair<String, shape_t>  l_1 = p_p_e.first;
        TUSubsequence l_2 = p_p_rregion;
        TUSubsequence l_3 = p_p_rb;
        TUSubsequence r_0 = p_p_lb;
        double r_1 = p_p_e.second;
        TUSubsequence r_2 = p_p_rregion;
        TUSubsequence r_3 = p_p_rb;
        std::pair<String, shape_t>  ret_left = br_l(l_0, l_1, l_2, l_3);
        double ret_right = br_r(r_0, r_1, r_2, r_3);
        std::pair<std::pair<String, shape_t> , double>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_p_p_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_p_p_e);
        if (!arg_p_p_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_bt = arg_p_p_e;
          intrusive_ptr<Eval_List<Value> > arg_p_p_e_elist = evaluate(arg_p_p_e_bt);
          for (typename Eval_List<Value>::iterator arg_p_p_e_elem_itr = arg_p_p_e_elist->begin(); arg_p_p_e_elem_itr != arg_p_p_e_elist->end(); ++ arg_p_p_e_elem_itr) {
            std::pair<std::pair<String, shape_t> , double>  arg_p_p_e_elem = *arg_p_p_e_elem_itr;
            std::pair<std::pair<String, shape_t> , double>  ret = br(arg_p_p_lb, arg_p_p_e_elem, arg_p_p_rregion, arg_p_p_rb);
            push_back( answer, ret);
          }
          erase( arg_p_p_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_p_p_e_bt_itr = arg_p_p_e_t->begin(); arg_p_p_e_bt_itr != arg_p_p_e_t->end(); ++ arg_p_p_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_bt = *arg_p_p_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_p_p_e_elist = evaluate(arg_p_p_e_bt);
          for (typename Eval_List<Value>::iterator arg_p_p_e_elem_itr = arg_p_p_e_elist->begin(); arg_p_p_e_elem_itr != arg_p_p_e_elist->end(); ++ arg_p_p_e_elem_itr) {
            std::pair<std::pair<String, shape_t> , double>  arg_p_p_e_elem = *arg_p_p_e_elem_itr;
            std::pair<std::pair<String, shape_t> , double>  ret = br(arg_p_p_lb, arg_p_p_e_elem, arg_p_p_rregion, arg_p_p_rb);
            push_back( answer, ret);
          }
          erase( arg_p_p_e_elist);
        }
        erase( arg_p_p_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_cadd : Backtrace_Score<mfecovar, Value, pos_int> {
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_le;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_re;

Backtrace_cadd(intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_le_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_re_)
 : arg_p_p_le(arg_p_p_le_), arg_p_p_re(arg_p_p_re_)
{}

~Backtrace_cadd()
{
erase(arg_p_p_le);
erase(arg_p_p_re);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      std::pair<String, shape_t>  cadd_l(const std::pair<String, shape_t> & p_le, const std::pair<String, shape_t> & p_re)
      {
        String l_0 = p_le.first;
        String l_1 = p_re.first;
        shape_t r_0 = p_le.second;
        shape_t r_1 = p_re.second;
        String ret_left = cadd_l_l(l_0, l_1);
        shape_t ret_right = cadd_l_r(r_0, r_1);
        std::pair<String, shape_t>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      String cadd_l_l(const String & le, const String & re)
      {
#line 65 ""
        String res;
        append( res, le);
        append( res, re);
        return res;
#line 1087 ""
      }


      shape_t cadd_l_r(shape_t le, shape_t re)
      {
#line 843 ""
        if ((shapelevel() == 1))
          {
            if (((back(le) == '_') && (front(re) == '_')))
              {
                return (le + tail(re));
              }

            else
              {
                return (le + re);
              }

          }

        else
          {
            if ((re == '_'))
              {
                return le;
              }

            else
              {
                return (le + re);
              }

          }

#line 1122 ""
      }


      double cadd_r(double x, double y)
      {
#line 1631 ""
        return (x * y);
#line 1130 ""
      }


      std::pair<std::pair<String, shape_t> , double>  cadd(const std::pair<std::pair<String, shape_t> , double> & p_p_le, const std::pair<std::pair<String, shape_t> , double> & p_p_re)
      {
        std::pair<String, shape_t>  l_0 = p_p_le.first;
        std::pair<String, shape_t>  l_1 = p_p_re.first;
        double r_0 = p_p_le.second;
        double r_1 = p_p_re.second;
        std::pair<String, shape_t>  ret_left = cadd_l(l_0, l_1);
        double ret_right = cadd_r(r_0, r_1);
        std::pair<std::pair<String, shape_t> , double>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_p_p_le_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_p_p_le);
        if (!arg_p_p_le_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_le_bt = arg_p_p_le;
          intrusive_ptr<Backtrace_List<Value, pos_int> > arg_p_p_re_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_p_p_re);
          if (!arg_p_p_re_t) {
            intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_re_bt = arg_p_p_re;
            intrusive_ptr<Eval_List<Value> > arg_p_p_le_elist = evaluate(arg_p_p_le_bt);
            intrusive_ptr<Eval_List<Value> > arg_p_p_re_elist = evaluate(arg_p_p_re_bt);
            for (typename Eval_List<Value>::iterator arg_p_p_le_elem_itr = arg_p_p_le_elist->begin(); arg_p_p_le_elem_itr != arg_p_p_le_elist->end(); ++ arg_p_p_le_elem_itr) {
              std::pair<std::pair<String, shape_t> , double>  arg_p_p_le_elem = *arg_p_p_le_elem_itr;
              for (typename Eval_List<Value>::iterator arg_p_p_re_elem_itr = arg_p_p_re_elist->begin(); arg_p_p_re_elem_itr != arg_p_p_re_elist->end(); ++ arg_p_p_re_elem_itr) {
                std::pair<std::pair<String, shape_t> , double>  arg_p_p_re_elem = *arg_p_p_re_elem_itr;
                std::pair<std::pair<String, shape_t> , double>  ret = cadd(arg_p_p_le_elem, arg_p_p_re_elem);
                push_back( answer, ret);
              }
            }
            erase( arg_p_p_le_elist);
            erase( arg_p_p_re_elist);
          } else 
          for (typename Backtrace_List<Value, pos_int>::iterator arg_p_p_re_bt_itr = arg_p_p_re_t->begin(); arg_p_p_re_bt_itr != arg_p_p_re_t->end(); ++ arg_p_p_re_bt_itr) {
            intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_re_bt = *arg_p_p_re_bt_itr;
            intrusive_ptr<Eval_List<Value> > arg_p_p_le_elist = evaluate(arg_p_p_le_bt);
            intrusive_ptr<Eval_List<Value> > arg_p_p_re_elist = evaluate(arg_p_p_re_bt);
            for (typename Eval_List<Value>::iterator arg_p_p_le_elem_itr = arg_p_p_le_elist->begin(); arg_p_p_le_elem_itr != arg_p_p_le_elist->end(); ++ arg_p_p_le_elem_itr) {
              std::pair<std::pair<String, shape_t> , double>  arg_p_p_le_elem = *arg_p_p_le_elem_itr;
              for (typename Eval_List<Value>::iterator arg_p_p_re_elem_itr = arg_p_p_re_elist->begin(); arg_p_p_re_elem_itr != arg_p_p_re_elist->end(); ++ arg_p_p_re_elem_itr) {
                std::pair<std::pair<String, shape_t> , double>  arg_p_p_re_elem = *arg_p_p_re_elem_itr;
                std::pair<std::pair<String, shape_t> , double>  ret = cadd(arg_p_p_le_elem, arg_p_p_re_elem);
                push_back( answer, ret);
              }
            }
            erase( arg_p_p_le_elist);
            erase( arg_p_p_re_elist);
          }
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_p_p_le_bt_itr = arg_p_p_le_t->begin(); arg_p_p_le_bt_itr != arg_p_p_le_t->end(); ++ arg_p_p_le_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_le_bt = *arg_p_p_le_bt_itr;
          intrusive_ptr<Backtrace_List<Value, pos_int> > arg_p_p_re_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_p_p_re);
          if (!arg_p_p_re_t) {
            intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_re_bt = arg_p_p_re;
            intrusive_ptr<Eval_List<Value> > arg_p_p_le_elist = evaluate(arg_p_p_le_bt);
            intrusive_ptr<Eval_List<Value> > arg_p_p_re_elist = evaluate(arg_p_p_re_bt);
            for (typename Eval_List<Value>::iterator arg_p_p_le_elem_itr = arg_p_p_le_elist->begin(); arg_p_p_le_elem_itr != arg_p_p_le_elist->end(); ++ arg_p_p_le_elem_itr) {
              std::pair<std::pair<String, shape_t> , double>  arg_p_p_le_elem = *arg_p_p_le_elem_itr;
              for (typename Eval_List<Value>::iterator arg_p_p_re_elem_itr = arg_p_p_re_elist->begin(); arg_p_p_re_elem_itr != arg_p_p_re_elist->end(); ++ arg_p_p_re_elem_itr) {
                std::pair<std::pair<String, shape_t> , double>  arg_p_p_re_elem = *arg_p_p_re_elem_itr;
                std::pair<std::pair<String, shape_t> , double>  ret = cadd(arg_p_p_le_elem, arg_p_p_re_elem);
                push_back( answer, ret);
              }
            }
            erase( arg_p_p_le_elist);
            erase( arg_p_p_re_elist);
          } else 
          for (typename Backtrace_List<Value, pos_int>::iterator arg_p_p_re_bt_itr = arg_p_p_re_t->begin(); arg_p_p_re_bt_itr != arg_p_p_re_t->end(); ++ arg_p_p_re_bt_itr) {
            intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_re_bt = *arg_p_p_re_bt_itr;
            intrusive_ptr<Eval_List<Value> > arg_p_p_le_elist = evaluate(arg_p_p_le_bt);
            intrusive_ptr<Eval_List<Value> > arg_p_p_re_elist = evaluate(arg_p_p_re_bt);
            for (typename Eval_List<Value>::iterator arg_p_p_le_elem_itr = arg_p_p_le_elist->begin(); arg_p_p_le_elem_itr != arg_p_p_le_elist->end(); ++ arg_p_p_le_elem_itr) {
              std::pair<std::pair<String, shape_t> , double>  arg_p_p_le_elem = *arg_p_p_le_elem_itr;
              for (typename Eval_List<Value>::iterator arg_p_p_re_elem_itr = arg_p_p_re_elist->begin(); arg_p_p_re_elem_itr != arg_p_p_re_elist->end(); ++ arg_p_p_re_elem_itr) {
                std::pair<std::pair<String, shape_t> , double>  arg_p_p_re_elem = *arg_p_p_re_elem_itr;
                std::pair<std::pair<String, shape_t> , double>  ret = cadd(arg_p_p_le_elem, arg_p_p_re_elem);
                push_back( answer, ret);
              }
            }
            erase( arg_p_p_le_elist);
            erase( arg_p_p_re_elist);
          }
        }
        erase( arg_p_p_le);
        erase( arg_p_p_re);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_drem : Backtrace_Score<mfecovar, Value, pos_int> {
      TUSubsequence arg_p_p_lloc;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e;
      TUSubsequence arg_p_p_rloc;

Backtrace_drem(TUSubsequence arg_p_p_lloc_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_, TUSubsequence arg_p_p_rloc_)
 : arg_p_p_lloc(arg_p_p_lloc_), arg_p_p_e(arg_p_p_e_), arg_p_p_rloc(arg_p_p_rloc_)
{}

~Backtrace_drem()
{
erase(arg_p_p_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      std::pair<String, shape_t>  drem_l(const TUSubsequence & p_lloc, const std::pair<String, shape_t> & p_e, const TUSubsequence & p_rloc)
      {
        TUSubsequence l_0 = p_lloc;
        String l_1 = p_e.first;
        TUSubsequence l_2 = p_rloc;
        TUSubsequence r_0 = p_lloc;
        shape_t r_1 = p_e.second;
        TUSubsequence r_2 = p_rloc;
        String ret_left = drem_l_l(l_0, l_1, l_2);
        shape_t ret_right = drem_l_r(r_0, r_1, r_2);
        std::pair<String, shape_t>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      String drem_l_l(const TUSubsequence & lloc, const String & e, const TUSubsequence & rloc)
      {
#line 99 ""
        return e;
#line 1267 ""
      }


      shape_t drem_l_r(const TUSubsequence & lloc, shape_t e, const TUSubsequence & rloc)
      {
#line 888 ""
        return e;
#line 1275 ""
      }


      double drem_r(const TUSubsequence & lb, double x, const TUSubsequence & rb)
      {
#line 1725 ""
        return (x * mk_pf(( ( (termau_energy(lb, rb) + ext_mismatch_energy(lb, rb)) )  / float(rows(lb)))));
#line 1283 ""
      }


      std::pair<std::pair<String, shape_t> , double>  drem(const TUSubsequence & p_p_lloc, const std::pair<std::pair<String, shape_t> , double> & p_p_e, const TUSubsequence & p_p_rloc)
      {
        TUSubsequence l_0 = p_p_lloc;
        std::pair<String, shape_t>  l_1 = p_p_e.first;
        TUSubsequence l_2 = p_p_rloc;
        TUSubsequence r_0 = p_p_lloc;
        double r_1 = p_p_e.second;
        TUSubsequence r_2 = p_p_rloc;
        std::pair<String, shape_t>  ret_left = drem_l(l_0, l_1, l_2);
        double ret_right = drem_r(r_0, r_1, r_2);
        std::pair<std::pair<String, shape_t> , double>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_p_p_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_p_p_e);
        if (!arg_p_p_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_bt = arg_p_p_e;
          intrusive_ptr<Eval_List<Value> > arg_p_p_e_elist = evaluate(arg_p_p_e_bt);
          for (typename Eval_List<Value>::iterator arg_p_p_e_elem_itr = arg_p_p_e_elist->begin(); arg_p_p_e_elem_itr != arg_p_p_e_elist->end(); ++ arg_p_p_e_elem_itr) {
            std::pair<std::pair<String, shape_t> , double>  arg_p_p_e_elem = *arg_p_p_e_elem_itr;
            std::pair<std::pair<String, shape_t> , double>  ret = drem(arg_p_p_lloc, arg_p_p_e_elem, arg_p_p_rloc);
            push_back( answer, ret);
          }
          erase( arg_p_p_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_p_p_e_bt_itr = arg_p_p_e_t->begin(); arg_p_p_e_bt_itr != arg_p_p_e_t->end(); ++ arg_p_p_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_bt = *arg_p_p_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_p_p_e_elist = evaluate(arg_p_p_e_bt);
          for (typename Eval_List<Value>::iterator arg_p_p_e_elem_itr = arg_p_p_e_elist->begin(); arg_p_p_e_elem_itr != arg_p_p_e_elist->end(); ++ arg_p_p_e_elem_itr) {
            std::pair<std::pair<String, shape_t> , double>  arg_p_p_e_elem = *arg_p_p_e_elem_itr;
            std::pair<std::pair<String, shape_t> , double>  ret = drem(arg_p_p_lloc, arg_p_p_e_elem, arg_p_p_rloc);
            push_back( answer, ret);
          }
          erase( arg_p_p_e_elist);
        }
        erase( arg_p_p_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_hl : Backtrace_Score<mfecovar, Value, pos_int> {
      TUSubsequence arg_p_p_lb;
      TUSubsequence arg_p_p_region;
      TUSubsequence arg_p_p_rb;

Backtrace_hl(TUSubsequence arg_p_p_lb_, TUSubsequence arg_p_p_region_, TUSubsequence arg_p_p_rb_)
 : arg_p_p_lb(arg_p_p_lb_), arg_p_p_region(arg_p_p_region_), arg_p_p_rb(arg_p_p_rb_)
{}

~Backtrace_hl()
{
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      std::pair<String, shape_t>  hl_l(const TUSubsequence & p_lb, const TUSubsequence & p_region, const TUSubsequence & p_rb)
      {
        TUSubsequence l_0 = p_lb;
        TUSubsequence l_1 = p_region;
        TUSubsequence l_2 = p_rb;
        TUSubsequence r_0 = p_lb;
        TUSubsequence r_1 = p_region;
        TUSubsequence r_2 = p_rb;
        String ret_left = hl_l_l(l_0, l_1, l_2);
        shape_t ret_right = hl_l_r(r_0, r_1, r_2);
        std::pair<String, shape_t>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      String hl_l_l(const TUSubsequence & lb, const TUSubsequence & region, const TUSubsequence & rb)
      {
#line 111 ""
        String res;
        append( res, '(');
        append( res, '.', size(region));
        append( res, ')');
        return res;
#line 1376 ""
      }


      shape_t hl_l_r(const TUSubsequence & lb, const TUSubsequence & region, const TUSubsequence & rb)
      {
#line 896 ""
        return (openParen + closeParen);
#line 1384 ""
      }


      double hl_r(const TUSubsequence & lb, const TUSubsequence & r, const TUSubsequence & rb)
      {
#line 1660 ""
        return (scale(((2 + r.j) - r.i)) * mk_pf((int((hl_energy(r) / float(rows(r)))) + covscore(lb, lb.i, rb.i))));
#line 1392 ""
      }


      std::pair<std::pair<String, shape_t> , double>  hl(const TUSubsequence & p_p_lb, const TUSubsequence & p_p_region, const TUSubsequence & p_p_rb)
      {
        TUSubsequence l_0 = p_p_lb;
        TUSubsequence l_1 = p_p_region;
        TUSubsequence l_2 = p_p_rb;
        TUSubsequence r_0 = p_p_lb;
        TUSubsequence r_1 = p_p_region;
        TUSubsequence r_2 = p_p_rb;
        std::pair<String, shape_t>  ret_left = hl_l(l_0, l_1, l_2);
        double ret_right = hl_r(r_0, r_1, r_2);
        std::pair<std::pair<String, shape_t> , double>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        std::pair<std::pair<String, shape_t> , double>  ret = hl(arg_p_p_lb, arg_p_p_region, arg_p_p_rb);
        push_back( answer, ret);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_il : Backtrace_Score<mfecovar, Value, pos_int> {
      TUSubsequence arg_p_p_lb;
      TUSubsequence arg_p_p_lregion;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e;
      TUSubsequence arg_p_p_rregion;
      TUSubsequence arg_p_p_rb;

Backtrace_il(TUSubsequence arg_p_p_lb_, TUSubsequence arg_p_p_lregion_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_, TUSubsequence arg_p_p_rregion_, TUSubsequence arg_p_p_rb_)
 : arg_p_p_lb(arg_p_p_lb_), arg_p_p_lregion(arg_p_p_lregion_), arg_p_p_e(arg_p_p_e_), arg_p_p_rregion(arg_p_p_rregion_), arg_p_p_rb(arg_p_p_rb_)
{}

~Backtrace_il()
{
erase(arg_p_p_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      std::pair<String, shape_t>  il_l(const TUSubsequence & p_lb, const TUSubsequence & p_lregion, const std::pair<String, shape_t> & p_e, const TUSubsequence & p_rregion, const TUSubsequence & p_rb)
      {
        TUSubsequence l_0 = p_lb;
        TUSubsequence l_1 = p_lregion;
        String l_2 = p_e.first;
        TUSubsequence l_3 = p_rregion;
        TUSubsequence l_4 = p_rb;
        TUSubsequence r_0 = p_lb;
        TUSubsequence r_1 = p_lregion;
        shape_t r_2 = p_e.second;
        TUSubsequence r_3 = p_rregion;
        TUSubsequence r_4 = p_rb;
        String ret_left = il_l_l(l_0, l_1, l_2, l_3, l_4);
        shape_t ret_right = il_l_r(r_0, r_1, r_2, r_3, r_4);
        std::pair<String, shape_t>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      String il_l_l(const TUSubsequence & lb, const TUSubsequence & lregion, const String & e, const TUSubsequence & rregion, const TUSubsequence & rb)
      {
#line 138 ""
        String res;
        append( res, '(');
        append( res, '.', size(lregion));
        append( res, e);
        append( res, '.', size(rregion));
        append( res, ')');
        return res;
#line 1474 ""
      }


      shape_t il_l_r(const TUSubsequence & lb, const TUSubsequence & lregion, shape_t x, const TUSubsequence & rregion, const TUSubsequence & rb)
      {
#line 927 ""
        if ((shapelevel() <= 4))
        {
          shape_t res;
          append( res, openParen);
          if ((shapelevel() <= 2))
            {
              append( res, '_');
            }

          append( res, x);
          if ((shapelevel() <= 2))
            {
              append( res, '_');
            }

          append( res, closeParen);
          return res;
        }

        else
          {
            return x;
          }

#line 1505 ""
      }


      double il_r(const TUSubsequence & lb, const TUSubsequence & lr, double x, const TUSubsequence & rr, const TUSubsequence & rb)
      {
#line 1669 ""
        return ((x * scale(((((2 + lr.j) - lr.i) + rr.j) - rr.i))) * mk_pf(((il_energy(lr, rr) / float(rows(lr))) + covscore(lb, lb.i, rb.i))));
#line 1513 ""
      }


      std::pair<std::pair<String, shape_t> , double>  il(const TUSubsequence & p_p_lb, const TUSubsequence & p_p_lregion, const std::pair<std::pair<String, shape_t> , double> & p_p_e, const TUSubsequence & p_p_rregion, const TUSubsequence & p_p_rb)
      {
        TUSubsequence l_0 = p_p_lb;
        TUSubsequence l_1 = p_p_lregion;
        std::pair<String, shape_t>  l_2 = p_p_e.first;
        TUSubsequence l_3 = p_p_rregion;
        TUSubsequence l_4 = p_p_rb;
        TUSubsequence r_0 = p_p_lb;
        TUSubsequence r_1 = p_p_lregion;
        double r_2 = p_p_e.second;
        TUSubsequence r_3 = p_p_rregion;
        TUSubsequence r_4 = p_p_rb;
        std::pair<String, shape_t>  ret_left = il_l(l_0, l_1, l_2, l_3, l_4);
        double ret_right = il_r(r_0, r_1, r_2, r_3, r_4);
        std::pair<std::pair<String, shape_t> , double>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_p_p_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_p_p_e);
        if (!arg_p_p_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_bt = arg_p_p_e;
          intrusive_ptr<Eval_List<Value> > arg_p_p_e_elist = evaluate(arg_p_p_e_bt);
          for (typename Eval_List<Value>::iterator arg_p_p_e_elem_itr = arg_p_p_e_elist->begin(); arg_p_p_e_elem_itr != arg_p_p_e_elist->end(); ++ arg_p_p_e_elem_itr) {
            std::pair<std::pair<String, shape_t> , double>  arg_p_p_e_elem = *arg_p_p_e_elem_itr;
            std::pair<std::pair<String, shape_t> , double>  ret = il(arg_p_p_lb, arg_p_p_lregion, arg_p_p_e_elem, arg_p_p_rregion, arg_p_p_rb);
            push_back( answer, ret);
          }
          erase( arg_p_p_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_p_p_e_bt_itr = arg_p_p_e_t->begin(); arg_p_p_e_bt_itr != arg_p_p_e_t->end(); ++ arg_p_p_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_bt = *arg_p_p_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_p_p_e_elist = evaluate(arg_p_p_e_bt);
          for (typename Eval_List<Value>::iterator arg_p_p_e_elem_itr = arg_p_p_e_elist->begin(); arg_p_p_e_elem_itr != arg_p_p_e_elist->end(); ++ arg_p_p_e_elem_itr) {
            std::pair<std::pair<String, shape_t> , double>  arg_p_p_e_elem = *arg_p_p_e_elem_itr;
            std::pair<std::pair<String, shape_t> , double>  ret = il(arg_p_p_lb, arg_p_p_lregion, arg_p_p_e_elem, arg_p_p_rregion, arg_p_p_rb);
            push_back( answer, ret);
          }
          erase( arg_p_p_e_elist);
        }
        erase( arg_p_p_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_incl : Backtrace_Score<mfecovar, Value, pos_int> {
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e;

Backtrace_incl(intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_)
 : arg_p_p_e(arg_p_p_e_)
{}

~Backtrace_incl()
{
erase(arg_p_p_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      std::pair<String, shape_t>  incl_l(const std::pair<String, shape_t> & p_e)
      {
        String l_0 = p_e.first;
        shape_t r_0 = p_e.second;
        String ret_left = incl_l_l(l_0);
        shape_t ret_right = incl_l_r(r_0);
        std::pair<String, shape_t>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      String incl_l_l(const String & e)
      {
#line 191 ""
        return e;
#line 1601 ""
      }


      shape_t incl_l_r(shape_t e)
      {
#line 982 ""
        return e;
#line 1609 ""
      }


      double incl_r(double x)
      {
#line 1685 ""
        return (x * mk_pf(ul_energy()));
#line 1617 ""
      }


      std::pair<std::pair<String, shape_t> , double>  incl(const std::pair<std::pair<String, shape_t> , double> & p_p_e)
      {
        std::pair<String, shape_t>  l_0 = p_p_e.first;
        double r_0 = p_p_e.second;
        std::pair<String, shape_t>  ret_left = incl_l(l_0);
        double ret_right = incl_r(r_0);
        std::pair<std::pair<String, shape_t> , double>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_p_p_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_p_p_e);
        if (!arg_p_p_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_bt = arg_p_p_e;
          intrusive_ptr<Eval_List<Value> > arg_p_p_e_elist = evaluate(arg_p_p_e_bt);
          for (typename Eval_List<Value>::iterator arg_p_p_e_elem_itr = arg_p_p_e_elist->begin(); arg_p_p_e_elem_itr != arg_p_p_e_elist->end(); ++ arg_p_p_e_elem_itr) {
            std::pair<std::pair<String, shape_t> , double>  arg_p_p_e_elem = *arg_p_p_e_elem_itr;
            std::pair<std::pair<String, shape_t> , double>  ret = incl(arg_p_p_e_elem);
            push_back( answer, ret);
          }
          erase( arg_p_p_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_p_p_e_bt_itr = arg_p_p_e_t->begin(); arg_p_p_e_bt_itr != arg_p_p_e_t->end(); ++ arg_p_p_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_bt = *arg_p_p_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_p_p_e_elist = evaluate(arg_p_p_e_bt);
          for (typename Eval_List<Value>::iterator arg_p_p_e_elem_itr = arg_p_p_e_elist->begin(); arg_p_p_e_elem_itr != arg_p_p_e_elist->end(); ++ arg_p_p_e_elem_itr) {
            std::pair<std::pair<String, shape_t> , double>  arg_p_p_e_elem = *arg_p_p_e_elem_itr;
            std::pair<std::pair<String, shape_t> , double>  ret = incl(arg_p_p_e_elem);
            push_back( answer, ret);
          }
          erase( arg_p_p_e_elist);
        }
        erase( arg_p_p_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_ml : Backtrace_Score<mfecovar, Value, pos_int> {
      TUSubsequence arg_p_p_lb;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e;
      TUSubsequence arg_p_p_rb;

Backtrace_ml(TUSubsequence arg_p_p_lb_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_, TUSubsequence arg_p_p_rb_)
 : arg_p_p_lb(arg_p_p_lb_), arg_p_p_e(arg_p_p_e_), arg_p_p_rb(arg_p_p_rb_)
{}

~Backtrace_ml()
{
erase(arg_p_p_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      std::pair<String, shape_t>  ml_l(const TUSubsequence & p_lb, const std::pair<String, shape_t> & p_e, const TUSubsequence & p_rb)
      {
        TUSubsequence l_0 = p_lb;
        String l_1 = p_e.first;
        TUSubsequence l_2 = p_rb;
        TUSubsequence r_0 = p_lb;
        shape_t r_1 = p_e.second;
        TUSubsequence r_2 = p_rb;
        String ret_left = ml_l_l(l_0, l_1, l_2);
        shape_t ret_right = ml_l_r(r_0, r_1, r_2);
        std::pair<String, shape_t>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      String ml_l_l(const TUSubsequence & lb, const String & e, const TUSubsequence & rb)
      {
#line 148 ""
        String res;
        append( res, '(');
        append( res, e);
        append( res, ')');
        return res;
#line 1707 ""
      }


      shape_t ml_l_r(const TUSubsequence & lb, shape_t e, const TUSubsequence & rb)
      {
#line 941 ""
        return ((openParen + e) + closeParen);
#line 1715 ""
      }


      double ml_r(const TUSubsequence & lb, double x, const TUSubsequence & rb)
      {
#line 1728 ""
        return ((x * scale(2)) * mk_pf((((ml_energy() + ul_energy()) +  ( ( ( (termau_energy(lb, rb) + ml_mismatch_energy(lb, rb)) )  / float(rows(lb))) ) ) + covscore(lb, lb.i, rb.i))));
#line 1723 ""
      }


      std::pair<std::pair<String, shape_t> , double>  ml(const TUSubsequence & p_p_lb, const std::pair<std::pair<String, shape_t> , double> & p_p_e, const TUSubsequence & p_p_rb)
      {
        TUSubsequence l_0 = p_p_lb;
        std::pair<String, shape_t>  l_1 = p_p_e.first;
        TUSubsequence l_2 = p_p_rb;
        TUSubsequence r_0 = p_p_lb;
        double r_1 = p_p_e.second;
        TUSubsequence r_2 = p_p_rb;
        std::pair<String, shape_t>  ret_left = ml_l(l_0, l_1, l_2);
        double ret_right = ml_r(r_0, r_1, r_2);
        std::pair<std::pair<String, shape_t> , double>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_p_p_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_p_p_e);
        if (!arg_p_p_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_bt = arg_p_p_e;
          intrusive_ptr<Eval_List<Value> > arg_p_p_e_elist = evaluate(arg_p_p_e_bt);
          for (typename Eval_List<Value>::iterator arg_p_p_e_elem_itr = arg_p_p_e_elist->begin(); arg_p_p_e_elem_itr != arg_p_p_e_elist->end(); ++ arg_p_p_e_elem_itr) {
            std::pair<std::pair<String, shape_t> , double>  arg_p_p_e_elem = *arg_p_p_e_elem_itr;
            std::pair<std::pair<String, shape_t> , double>  ret = ml(arg_p_p_lb, arg_p_p_e_elem, arg_p_p_rb);
            push_back( answer, ret);
          }
          erase( arg_p_p_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_p_p_e_bt_itr = arg_p_p_e_t->begin(); arg_p_p_e_bt_itr != arg_p_p_e_t->end(); ++ arg_p_p_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_bt = *arg_p_p_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_p_p_e_elist = evaluate(arg_p_p_e_bt);
          for (typename Eval_List<Value>::iterator arg_p_p_e_elem_itr = arg_p_p_e_elist->begin(); arg_p_p_e_elem_itr != arg_p_p_e_elist->end(); ++ arg_p_p_e_elem_itr) {
            std::pair<std::pair<String, shape_t> , double>  arg_p_p_e_elem = *arg_p_p_e_elem_itr;
            std::pair<std::pair<String, shape_t> , double>  ret = ml(arg_p_p_lb, arg_p_p_e_elem, arg_p_p_rb);
            push_back( answer, ret);
          }
          erase( arg_p_p_e_elist);
        }
        erase( arg_p_p_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_nil : Backtrace_Score<mfecovar, Value, pos_int> {
      TUSubsequence arg_p_p_loc;

Backtrace_nil(TUSubsequence arg_p_p_loc_)
 : arg_p_p_loc(arg_p_p_loc_)
{}

~Backtrace_nil()
{
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      std::pair<String, shape_t>  nil_l(const TUSubsequence & p_loc)
      {
        TUSubsequence l_0 = p_loc;
        TUSubsequence r_0 = p_loc;
        String ret_left = nil_l_l(l_0);
        shape_t ret_right = nil_l_r(r_0);
        std::pair<String, shape_t>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      String nil_l_l(const TUSubsequence & loc)
      {
#line 72 ""
        String r;
        return r;
#line 1807 ""
      }


      shape_t nil_l_r(const TUSubsequence & loc)
      {
#line 859 ""
        shape_t r;
        return r;
#line 1816 ""
      }


      double nil_r(const TUSubsequence & n)
      {
#line 1691 ""
        return 1.000000e+00;
#line 1824 ""
      }


      std::pair<std::pair<String, shape_t> , double>  nil(const TUSubsequence & p_p_loc)
      {
        TUSubsequence l_0 = p_p_loc;
        TUSubsequence r_0 = p_p_loc;
        std::pair<String, shape_t>  ret_left = nil_l(l_0);
        double ret_right = nil_r(r_0);
        std::pair<std::pair<String, shape_t> , double>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        std::pair<std::pair<String, shape_t> , double>  ret = nil(arg_p_p_loc);
        push_back( answer, ret);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_sadd : Backtrace_Score<mfecovar, Value, pos_int> {
      TUSubsequence arg_p_p_lb;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e;

Backtrace_sadd(TUSubsequence arg_p_p_lb_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_)
 : arg_p_p_lb(arg_p_p_lb_), arg_p_p_e(arg_p_p_e_)
{}

~Backtrace_sadd()
{
erase(arg_p_p_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      std::pair<String, shape_t>  sadd_l(const TUSubsequence & p_lb, const std::pair<String, shape_t> & p_e)
      {
        TUSubsequence l_0 = p_lb;
        String l_1 = p_e.first;
        TUSubsequence r_0 = p_lb;
        shape_t r_1 = p_e.second;
        String ret_left = sadd_l_l(l_0, l_1);
        shape_t ret_right = sadd_l_r(r_0, r_1);
        std::pair<String, shape_t>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      String sadd_l_l(const TUSubsequence & lb, const String & e)
      {
#line 58 ""
        String res;
        append( res, '.');
        append( res, e);
        return res;
#line 1890 ""
      }


      shape_t sadd_l_r(const TUSubsequence & b, shape_t x)
      {
#line 829 ""
        shape_t emptyShape;
        if ((x == emptyShape))
          {
            return shape_t('_');
          }

        else
          {
            if (( ( (shapelevel() == 1) )  &&  ( (front(x) != '_') ) ))
              {
                return (shape_t('_') + x);
              }

            else
              {
                return x;
              }

          }

#line 1917 ""
      }


      double sadd_r(const TUSubsequence & lb, double x)
      {
        double sbase_sum = 0;
        for(        int k = 0; (k < int(rows(lb)));         k = (k + 1))
        {
          if ((column(seq_char(lb, lb.i), k) != GAP_BASE))
            {
              sbase_sum = (sbase_sum + sbase_energy());
            }

        }

        return ((x * scale(1)) * mk_pf((sbase_sum / float(rows(lb)))));
      }


      std::pair<std::pair<String, shape_t> , double>  sadd(const TUSubsequence & p_p_lb, const std::pair<std::pair<String, shape_t> , double> & p_p_e)
      {
        TUSubsequence l_0 = p_p_lb;
        std::pair<String, shape_t>  l_1 = p_p_e.first;
        TUSubsequence r_0 = p_p_lb;
        double r_1 = p_p_e.second;
        std::pair<String, shape_t>  ret_left = sadd_l(l_0, l_1);
        double ret_right = sadd_r(r_0, r_1);
        std::pair<std::pair<String, shape_t> , double>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_p_p_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_p_p_e);
        if (!arg_p_p_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_bt = arg_p_p_e;
          intrusive_ptr<Eval_List<Value> > arg_p_p_e_elist = evaluate(arg_p_p_e_bt);
          for (typename Eval_List<Value>::iterator arg_p_p_e_elem_itr = arg_p_p_e_elist->begin(); arg_p_p_e_elem_itr != arg_p_p_e_elist->end(); ++ arg_p_p_e_elem_itr) {
            std::pair<std::pair<String, shape_t> , double>  arg_p_p_e_elem = *arg_p_p_e_elem_itr;
            std::pair<std::pair<String, shape_t> , double>  ret = sadd(arg_p_p_lb, arg_p_p_e_elem);
            push_back( answer, ret);
          }
          erase( arg_p_p_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_p_p_e_bt_itr = arg_p_p_e_t->begin(); arg_p_p_e_bt_itr != arg_p_p_e_t->end(); ++ arg_p_p_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_bt = *arg_p_p_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_p_p_e_elist = evaluate(arg_p_p_e_bt);
          for (typename Eval_List<Value>::iterator arg_p_p_e_elem_itr = arg_p_p_e_elist->begin(); arg_p_p_e_elem_itr != arg_p_p_e_elist->end(); ++ arg_p_p_e_elem_itr) {
            std::pair<std::pair<String, shape_t> , double>  arg_p_p_e_elem = *arg_p_p_e_elem_itr;
            std::pair<std::pair<String, shape_t> , double>  ret = sadd(arg_p_p_lb, arg_p_p_e_elem);
            push_back( answer, ret);
          }
          erase( arg_p_p_e_elist);
        }
        erase( arg_p_p_e);
        return answer;
      }


};
template <typename Value, typename pos_int>
struct Backtrace_sr : Backtrace_Score<mfecovar, Value, pos_int> {
      TUSubsequence arg_p_p_lb;
      intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e;
      TUSubsequence arg_p_p_rb;

Backtrace_sr(TUSubsequence arg_p_p_lb_, intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_, TUSubsequence arg_p_p_rb_)
 : arg_p_p_lb(arg_p_p_lb_), arg_p_p_e(arg_p_p_e_), arg_p_p_rb(arg_p_p_rb_)
{}

~Backtrace_sr()
{
erase(arg_p_p_e);
}

      intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{ return intrusive_ptr<Backtrace<Value, pos_int> >(this); }

      std::pair<String, shape_t>  sr_l(const TUSubsequence & p_lb, const std::pair<String, shape_t> & p_e, const TUSubsequence & p_rb)
      {
        TUSubsequence l_0 = p_lb;
        String l_1 = p_e.first;
        TUSubsequence l_2 = p_rb;
        TUSubsequence r_0 = p_lb;
        shape_t r_1 = p_e.second;
        TUSubsequence r_2 = p_rb;
        String ret_left = sr_l_l(l_0, l_1, l_2);
        shape_t ret_right = sr_l_r(r_0, r_1, r_2);
        std::pair<String, shape_t>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      String sr_l_l(const TUSubsequence & lb, const String & e, const TUSubsequence & rb)
      {
#line 103 ""
        String res;
        append( res, '(');
        append( res, e);
        append( res, ')');
        return res;
#line 2025 ""
      }


      shape_t sr_l_r(const TUSubsequence & lb, shape_t e, const TUSubsequence & rb)
      {
#line 892 ""
        return e;
#line 2033 ""
      }


      double sr_r(const TUSubsequence & lb, double x, const TUSubsequence & rb)
      {
#line 1657 ""
        return ((x * scale(2)) * mk_pf((int((sr_energy(lb, rb) / float(rows(lb)))) + covscore(lb, lb.i, rb.i))));
#line 2041 ""
      }


      std::pair<std::pair<String, shape_t> , double>  sr(const TUSubsequence & p_p_lb, const std::pair<std::pair<String, shape_t> , double> & p_p_e, const TUSubsequence & p_p_rb)
      {
        TUSubsequence l_0 = p_p_lb;
        std::pair<String, shape_t>  l_1 = p_p_e.first;
        TUSubsequence l_2 = p_p_rb;
        TUSubsequence r_0 = p_p_lb;
        double r_1 = p_p_e.second;
        TUSubsequence r_2 = p_p_rb;
        std::pair<String, shape_t>  ret_left = sr_l(l_0, l_1, l_2);
        double ret_right = sr_r(r_0, r_1, r_2);
        std::pair<std::pair<String, shape_t> , double>  ret;
        ret.first = ret_left;
        ret.second = ret_right;
        return ret;
      }


      intrusive_ptr<Eval_List<Value> > eval()
      {
        intrusive_ptr<Eval_List<Value> > answer = new Eval_List<Value>();
        intrusive_ptr<Backtrace_List<Value, pos_int> > arg_p_p_e_t = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >(arg_p_p_e);
        if (!arg_p_p_e_t) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_bt = arg_p_p_e;
          intrusive_ptr<Eval_List<Value> > arg_p_p_e_elist = evaluate(arg_p_p_e_bt);
          for (typename Eval_List<Value>::iterator arg_p_p_e_elem_itr = arg_p_p_e_elist->begin(); arg_p_p_e_elem_itr != arg_p_p_e_elist->end(); ++ arg_p_p_e_elem_itr) {
            std::pair<std::pair<String, shape_t> , double>  arg_p_p_e_elem = *arg_p_p_e_elem_itr;
            std::pair<std::pair<String, shape_t> , double>  ret = sr(arg_p_p_lb, arg_p_p_e_elem, arg_p_p_rb);
            push_back( answer, ret);
          }
          erase( arg_p_p_e_elist);
        } else 
        for (typename Backtrace_List<Value, pos_int>::iterator arg_p_p_e_bt_itr = arg_p_p_e_t->begin(); arg_p_p_e_bt_itr != arg_p_p_e_t->end(); ++ arg_p_p_e_bt_itr) {
          intrusive_ptr<Backtrace<Value, pos_int> >  arg_p_p_e_bt = *arg_p_p_e_bt_itr;
          intrusive_ptr<Eval_List<Value> > arg_p_p_e_elist = evaluate(arg_p_p_e_bt);
          for (typename Eval_List<Value>::iterator arg_p_p_e_elem_itr = arg_p_p_e_elist->begin(); arg_p_p_e_elem_itr != arg_p_p_e_elist->end(); ++ arg_p_p_e_elem_itr) {
            std::pair<std::pair<String, shape_t> , double>  arg_p_p_e_elem = *arg_p_p_e_elem_itr;
            std::pair<std::pair<String, shape_t> , double>  ret = sr(arg_p_p_lb, arg_p_p_e_elem, arg_p_p_rb);
            push_back( answer, ret);
          }
          erase( arg_p_p_e_elist);
        }
        erase( arg_p_p_e);
        return answer;
      }


};
template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_struct_Back : public Backtrace_NT_Back_Base<mfecovar, Klass, Value, pos_int>
{
pos_int t_0_i;
Backtrace_nt_struct_Back(Klass *klass_, pos_int t_0_i_)
  : Backtrace_NT_Back_Base<mfecovar, Klass, Value, pos_int>(klass_), t_0_i(t_0_i_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_struct(t_0_i));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_struct_Front : public Backtrace_Score<mfecovar , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_struct_Back<mfe_overdangle, Value, pos_int> > back;

Backtrace_nt_struct_Front(intrusive_ptr<Backtrace_nt_struct_Back<mfe_overdangle, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<mfecovar, mfe_overdangle, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_dangle_Back : public Backtrace_NT_Back_Base<mfecovar, Klass, Value, pos_int>
{
pos_int t_0_i;
pos_int t_0_j;
Backtrace_nt_dangle_Back(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_)
  : Backtrace_NT_Back_Base<mfecovar, Klass, Value, pos_int>(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_dangle(t_0_i, t_0_j));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_dangle_Front : public Backtrace_Score<mfecovar , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_dangle_Back<mfe_overdangle, Value, pos_int> > back;

Backtrace_nt_dangle_Front(intrusive_ptr<Backtrace_nt_dangle_Back<mfe_overdangle, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<mfecovar, mfe_overdangle, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_strong_Back : public Backtrace_NT_Back_Base<mfecovar, Klass, Value, pos_int>
{
pos_int t_0_i;
pos_int t_0_j;
Backtrace_nt_strong_Back(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_)
  : Backtrace_NT_Back_Base<mfecovar, Klass, Value, pos_int>(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_strong(t_0_i, t_0_j));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_strong_Front : public Backtrace_Score<mfecovar , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_strong_Back<mfe_overdangle, Value, pos_int> > back;

Backtrace_nt_strong_Front(intrusive_ptr<Backtrace_nt_strong_Back<mfe_overdangle, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<mfecovar, mfe_overdangle, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_weak_Back : public Backtrace_NT_Back_Base<mfecovar, Klass, Value, pos_int>
{
pos_int t_0_i;
pos_int t_0_j;
Backtrace_nt_weak_Back(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_)
  : Backtrace_NT_Back_Base<mfecovar, Klass, Value, pos_int>(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_weak(t_0_i, t_0_j));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_weak_Front : public Backtrace_Score<mfecovar , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_weak_Back<mfe_overdangle, Value, pos_int> > back;

Backtrace_nt_weak_Front(intrusive_ptr<Backtrace_nt_weak_Back<mfe_overdangle, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<mfecovar, mfe_overdangle, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_stack_Back : public Backtrace_NT_Back_Base<mfecovar, Klass, Value, pos_int>
{
pos_int t_0_i;
pos_int t_0_j;
Backtrace_nt_stack_Back(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_)
  : Backtrace_NT_Back_Base<mfecovar, Klass, Value, pos_int>(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_stack(t_0_i, t_0_j));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_stack_Front : public Backtrace_Score<mfecovar , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_stack_Back<mfe_overdangle, Value, pos_int> > back;

Backtrace_nt_stack_Front(intrusive_ptr<Backtrace_nt_stack_Back<mfe_overdangle, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<mfecovar, mfe_overdangle, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_hairpin_Back : public Backtrace_NT_Back_Base<mfecovar, Klass, Value, pos_int>
{
pos_int t_0_i;
pos_int t_0_j;
Backtrace_nt_hairpin_Back(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_)
  : Backtrace_NT_Back_Base<mfecovar, Klass, Value, pos_int>(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_hairpin(t_0_i, t_0_j));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_hairpin_Front : public Backtrace_Score<mfecovar , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_hairpin_Back<mfe_overdangle, Value, pos_int> > back;

Backtrace_nt_hairpin_Front(intrusive_ptr<Backtrace_nt_hairpin_Back<mfe_overdangle, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<mfecovar, mfe_overdangle, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_leftB_Back : public Backtrace_NT_Back_Base<mfecovar, Klass, Value, pos_int>
{
pos_int t_0_i;
pos_int t_0_j;
Backtrace_nt_leftB_Back(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_)
  : Backtrace_NT_Back_Base<mfecovar, Klass, Value, pos_int>(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_leftB(t_0_i, t_0_j));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_leftB_Front : public Backtrace_Score<mfecovar , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_leftB_Back<mfe_overdangle, Value, pos_int> > back;

Backtrace_nt_leftB_Front(intrusive_ptr<Backtrace_nt_leftB_Back<mfe_overdangle, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<mfecovar, mfe_overdangle, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_rightB_Back : public Backtrace_NT_Back_Base<mfecovar, Klass, Value, pos_int>
{
pos_int t_0_i;
pos_int t_0_j;
Backtrace_nt_rightB_Back(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_)
  : Backtrace_NT_Back_Base<mfecovar, Klass, Value, pos_int>(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_rightB(t_0_i, t_0_j));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_rightB_Front : public Backtrace_Score<mfecovar , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_rightB_Back<mfe_overdangle, Value, pos_int> > back;

Backtrace_nt_rightB_Front(intrusive_ptr<Backtrace_nt_rightB_Back<mfe_overdangle, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<mfecovar, mfe_overdangle, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_iloop_Back : public Backtrace_NT_Back_Base<mfecovar, Klass, Value, pos_int>
{
pos_int t_0_i;
pos_int t_0_j;
Backtrace_nt_iloop_Back(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_)
  : Backtrace_NT_Back_Base<mfecovar, Klass, Value, pos_int>(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_iloop(t_0_i, t_0_j));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_iloop_Front : public Backtrace_Score<mfecovar , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_iloop_Back<mfe_overdangle, Value, pos_int> > back;

Backtrace_nt_iloop_Front(intrusive_ptr<Backtrace_nt_iloop_Back<mfe_overdangle, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<mfecovar, mfe_overdangle, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_multiloop_Back : public Backtrace_NT_Back_Base<mfecovar, Klass, Value, pos_int>
{
pos_int t_0_i;
pos_int t_0_j;
Backtrace_nt_multiloop_Back(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_)
  : Backtrace_NT_Back_Base<mfecovar, Klass, Value, pos_int>(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_multiloop(t_0_i, t_0_j));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_multiloop_Front : public Backtrace_Score<mfecovar , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_multiloop_Back<mfe_overdangle, Value, pos_int> > back;

Backtrace_nt_multiloop_Front(intrusive_ptr<Backtrace_nt_multiloop_Back<mfe_overdangle, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<mfecovar, mfe_overdangle, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_ml_comps_Back : public Backtrace_NT_Back_Base<mfecovar, Klass, Value, pos_int>
{
pos_int t_0_i;
pos_int t_0_j;
Backtrace_nt_ml_comps_Back(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_)
  : Backtrace_NT_Back_Base<mfecovar, Klass, Value, pos_int>(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_ml_comps(t_0_i, t_0_j));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_ml_comps_Front : public Backtrace_Score<mfecovar , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_ml_comps_Back<mfe_overdangle, Value, pos_int> > back;

Backtrace_nt_ml_comps_Front(intrusive_ptr<Backtrace_nt_ml_comps_Back<mfe_overdangle, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<mfecovar, mfe_overdangle, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

template <typename Klass, typename Value, typename pos_int> struct Backtrace_nt_ml_comps1_Back : public Backtrace_NT_Back_Base<mfecovar, Klass, Value, pos_int>
{
pos_int t_0_i;
pos_int t_0_j;
Backtrace_nt_ml_comps1_Back(Klass *klass_, pos_int t_0_i_, pos_int t_0_j_)
  : Backtrace_NT_Back_Base<mfecovar, Klass, Value, pos_int>(klass_), t_0_i(t_0_i_), t_0_j(t_0_j_) {}
void backtrack()
{
assert(this->scores == 0);
this->scores = boost::dynamic_pointer_cast<Backtrace_List<Value, pos_int> >
  (this->klass->bt_nt_ml_comps1(t_0_i, t_0_j));
assert(this->scores != 0);
}

};

template <typename Value, typename pos_int> struct Backtrace_nt_ml_comps1_Front : public Backtrace_Score<mfecovar , Value, pos_int> 
{
  intrusive_ptr<Backtrace_nt_ml_comps1_Back<mfe_overdangle, Value, pos_int> > back;

Backtrace_nt_ml_comps1_Front(intrusive_ptr<Backtrace_nt_ml_comps1_Back<mfe_overdangle, Value, pos_int> > b) : back(b) {}
intrusive_ptr<Backtrace<Value, pos_int> > backtrack()
{
  intrusive_ptr<Backtrace_NT_Back_Base<mfecovar, mfe_overdangle, Value, pos_int> > t = back;
  return t->backtrack(this->score());
}

intrusive_ptr<Eval_List<Value> > eval()
{
  intrusive_ptr<Backtrace<Value, pos_int> > t;
  t = backtrack();
  return t->eval();
}
};

    List_Ref<std::pair<mfecovar, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , double> , unsigned int> > > > bt_proxy_nt_struct(unsigned int t_0_i);
    List_Ref<std::pair<mfecovar, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , double> , unsigned int> > > > bt_proxy_nt_dangle(unsigned int t_0_i, unsigned int t_0_j);
    List_Ref<std::pair<mfecovar, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , double> , unsigned int> > > > bt_proxy_nt_strong(unsigned int t_0_i, unsigned int t_0_j);
    List_Ref<std::pair<mfecovar, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , double> , unsigned int> > > > bt_proxy_nt_weak(unsigned int t_0_i, unsigned int t_0_j);
    List_Ref<std::pair<mfecovar, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , double> , unsigned int> > > > bt_proxy_nt_stack(unsigned int t_0_i, unsigned int t_0_j);
    std::pair<mfecovar, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , double> , unsigned int> > >  bt_proxy_nt_hairpin(unsigned int t_0_i, unsigned int t_0_j);
    List_Ref<std::pair<mfecovar, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , double> , unsigned int> > > > bt_proxy_nt_leftB(unsigned int t_0_i, unsigned int t_0_j);
    List_Ref<std::pair<mfecovar, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , double> , unsigned int> > > > bt_proxy_nt_rightB(unsigned int t_0_i, unsigned int t_0_j);
    List_Ref<std::pair<mfecovar, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , double> , unsigned int> > > > bt_proxy_nt_iloop(unsigned int t_0_i, unsigned int t_0_j);
    List_Ref<std::pair<mfecovar, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , double> , unsigned int> > > > bt_proxy_nt_multiloop(unsigned int t_0_i, unsigned int t_0_j);
    List_Ref<std::pair<mfecovar, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , double> , unsigned int> > > > bt_proxy_nt_ml_comps(unsigned int t_0_i, unsigned int t_0_j);
    List_Ref<std::pair<mfecovar, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , double> , unsigned int> > > > bt_proxy_nt_ml_comps1(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , double> , unsigned int> >  bt_nt_dangle(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , double> , unsigned int> >  bt_nt_hairpin(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , double> , unsigned int> >  bt_nt_iloop(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , double> , unsigned int> >  bt_nt_leftB(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , double> , unsigned int> >  bt_nt_ml_comps(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , double> , unsigned int> >  bt_nt_ml_comps1(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , double> , unsigned int> >  bt_nt_multiloop(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , double> , unsigned int> >  bt_nt_rightB(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , double> , unsigned int> >  bt_nt_stack(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , double> , unsigned int> >  bt_nt_strong(unsigned int t_0_i, unsigned int t_0_j);
    intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , double> , unsigned int> >  bt_nt_struct(unsigned int t_0_i);
    intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , double> , unsigned int> >  bt_nt_weak(unsigned int t_0_i, unsigned int t_0_j);

    intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , double> , unsigned int> >  addss_bt_r(intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , double> , unsigned int> >  param_0, const TUSubsequence & param_1);
    intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , double> , unsigned int> >  bl_bt_r(const TUSubsequence & param_0, const TUSubsequence & param_1, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , double> , unsigned int> >  param_2, const TUSubsequence & param_3);
    intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , double> , unsigned int> >  br_bt_r(const TUSubsequence & param_0, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , double> , unsigned int> >  param_1, const TUSubsequence & param_2, const TUSubsequence & param_3);
    intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , double> , unsigned int> >  cadd_bt_r(intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , double> , unsigned int> >  param_0, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , double> , unsigned int> >  param_1);
    intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , double> , unsigned int> >  drem_bt_r(const TUSubsequence & param_0, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , double> , unsigned int> >  param_1, const TUSubsequence & param_2);
    List_Ref<intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , double> , unsigned int> > > h_bt_r(List_Ref<intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , double> , unsigned int> > > param_0);
    intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , double> , unsigned int> >  hl_bt_r(const TUSubsequence & param_0, const TUSubsequence & param_1, const TUSubsequence & param_2);
    intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , double> , unsigned int> >  il_bt_r(const TUSubsequence & param_0, const TUSubsequence & param_1, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , double> , unsigned int> >  param_2, const TUSubsequence & param_3, const TUSubsequence & param_4);
    intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , double> , unsigned int> >  incl_bt_r(intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , double> , unsigned int> >  param_0);
    intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , double> , unsigned int> >  ml_bt_r(const TUSubsequence & param_0, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , double> , unsigned int> >  param_1, const TUSubsequence & param_2);
    intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , double> , unsigned int> >  nil_bt_r(const TUSubsequence & param_0);
    intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , double> , unsigned int> >  sadd_bt_r(const TUSubsequence & param_0, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , double> , unsigned int> >  param_1);
    intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , double> , unsigned int> >  sr_bt_r(const TUSubsequence & param_0, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , double> , unsigned int> >  param_1, const TUSubsequence & param_2);


    std::pair<mfecovar, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , double> , unsigned int> > >  addss_bt(const std::pair<mfecovar, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , double> , unsigned int> > > & p_x, const TUSubsequence & p_r);
    std::pair<mfecovar, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , double> , unsigned int> > >  bl_bt(const TUSubsequence & p_lb, const TUSubsequence & p_lr, const std::pair<mfecovar, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , double> , unsigned int> > > & p_x, const TUSubsequence & p_rb);
    std::pair<mfecovar, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , double> , unsigned int> > >  br_bt(const TUSubsequence & p_lb, const std::pair<mfecovar, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , double> , unsigned int> > > & p_x, const TUSubsequence & p_rr, const TUSubsequence & p_rb);
    std::pair<mfecovar, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , double> , unsigned int> > >  cadd_bt(const std::pair<mfecovar, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , double> , unsigned int> > > & p_x, const std::pair<mfecovar, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , double> , unsigned int> > > & p_y);
    std::pair<mfecovar, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , double> , unsigned int> > >  drem_bt(const TUSubsequence & p_lb, const std::pair<mfecovar, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , double> , unsigned int> > > & p_x, const TUSubsequence & p_rb);
    List_Ref<std::pair<mfecovar, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , double> , unsigned int> > > > h_bt(List_Ref<std::pair<mfecovar, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , double> , unsigned int> > > > i, mfecovar &  left);
    List_Ref<std::pair<mfecovar, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , double> , unsigned int> > > > h_bt(List_Ref<std::pair<mfecovar, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , double> , unsigned int> > > > i);
    std::pair<mfecovar, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , double> , unsigned int> > >  hl_bt(const TUSubsequence & p_lb, const TUSubsequence & p_r, const TUSubsequence & p_rb);
    std::pair<mfecovar, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , double> , unsigned int> > >  il_bt(const TUSubsequence & p_lb, const TUSubsequence & p_lr, const std::pair<mfecovar, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , double> , unsigned int> > > & p_x, const TUSubsequence & p_rr, const TUSubsequence & p_rb);
    std::pair<mfecovar, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , double> , unsigned int> > >  incl_bt(const std::pair<mfecovar, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , double> , unsigned int> > > & p_x);
    std::pair<mfecovar, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , double> , unsigned int> > >  ml_bt(const TUSubsequence & p_lb, const std::pair<mfecovar, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , double> , unsigned int> > > & p_x, const TUSubsequence & p_rb);
    std::pair<mfecovar, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , double> , unsigned int> > >  nil_bt(const TUSubsequence & p_n);
    std::pair<mfecovar, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , double> , unsigned int> > >  sadd_bt(const TUSubsequence & p_lb, const std::pair<mfecovar, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , double> , unsigned int> > > & p_x);
    std::pair<mfecovar, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , double> , unsigned int> > >  sr_bt(const TUSubsequence & p_lb, const std::pair<mfecovar, intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , double> , unsigned int> > > & p_x, const TUSubsequence & p_rb);

template <typename Value>   void  print_result(std::ostream &out, Value& res)

{
}
   intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , double> , unsigned int> >  backtrack(unsigned int t_0_i)
{
  return bt_nt_struct(t_0_i);
}
template <typename Value>   void  print_backtrack(std::ostream &out, Value& value)

{
intrusive_ptr<Backtrace<std::pair<std::pair<String, Shape> , double> , unsigned int> >  bt    = backtrack(t_0_left_most);
intrusive_ptr<Backtrace_List<std::pair<std::pair<String, Shape> , double> , unsigned int> > l =
  boost::dynamic_pointer_cast<Backtrace_List<std::pair<std::pair<String, Shape> , double> , unsigned int> > (bt);
assert(!bt || (bt && l));
if (l) {
for (Backtrace_List<std::pair<std::pair<String, Shape> , double> , unsigned int>::iterator i = l->begin();
     i != l->end(); ++i)
  (*i)->print(out);
}
}
   void  print_subopt(std::ostream &out, int  delta = 0) {}

};

#ifndef NO_GAPC_TYPEDEFS
namespace gapc {
  typedef mfe_overdangle class_name;
  typedef mfecovar &  return_type;
}
#endif

#endif

